(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["wg-ol-mixins"] = factory();
	else
		root["wg-ol-mixins"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "00ee":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "01b4":
/***/ (function(module, exports) {

var Queue = function () {
  this.head = null;
  this.tail = null;
};

Queue.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    if (this.head) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  }
};

module.exports = Queue;


/***/ }),

/***/ "01d4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/events/EventType
 */
/**
 * @enum {string}
 * @const
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */
    CHANGE: 'change',
    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */
    ERROR: 'error',
    BLUR: 'blur',
    CLEAR: 'clear',
    CONTEXTMENU: 'contextmenu',
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DRAGENTER: 'dragenter',
    DRAGOVER: 'dragover',
    DROP: 'drop',
    FOCUS: 'focus',
    KEYDOWN: 'keydown',
    KEYPRESS: 'keypress',
    LOAD: 'load',
    RESIZE: 'resize',
    TOUCHMOVE: 'touchmove',
    WHEEL: 'wheel',
});
//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "01db":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "01f7":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0093.8de2ccf9.png";

/***/ }),

/***/ "02de":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAT2SURBVEhLrVdraFxVEJ6kebSbx+69uzQtkU2bitGmoTYVfDQVRapSKWrBH/5RUYqpv4pRFApCfkQFH1grVMgv/4goCBZ8tIKiPwJqjI9UUh8tSXb33r37SLLJJrvZ1/jNuae2aUyym/aDy909d858Z+bMmZlDlYJpqydGvrtjZD5jkfG8Q+ZTCTLvYKIaLXL9YFPL5jj5n4uT+YVDRtgmM2uRWcKb3beRwQLGIfPpFJlPXiDDq6euD8NQAGUDsCiRowDPk58T5GWbNoGwhiO0Ae9ajpKHk+TjBXxfxJMkIxQn48WPieq0qvIxQeYBrP6fAgiTsCxMdXiIrWqTnfY9nOg5yMkDhzl+5wPsBLuwAK/6HqGNPA1yPW9knALdWuXaCJPRO4PJc5gcpgY8VRzr7uH0iVOcH/uTS7kcX4lSJsu530Z57tU32eno1gtohAcCWIQ5P0nmo1r1ygiR8WxWuVSsbORo8GZe+PATaNcsa0AWkX7rXbY8AQ5hO6ZBLkZMkO+QpliOEPnvSWnSCBl4POzcdCsXp1JabfnI/TLKzo4ukFeDWLl9HoF4i6a6DARRU5TMSXFvhJpgrQSP7BuCZ9tOLlyY0CrLRyFkcbRtp9KRUdtmDOPYVWtKFxgcKKqPHo62dnL6vUG2amURHoxVa/JxrbJ85EZ+Z6vOp4zJK6OMI5qS6Dw1BpAMUm70Ei988JGalDn9FUdqGq8ir9zyuf434HJi2cYwmRfPXTpmFvmO5tRgHce6erS4i+tBXkrPc3RLh9IhZ90m30Oa2DgjyUGsTZ8c1OKX8f/klbk99cIrympJMAiyQfqVWhrgd1sykrXB5PzfF7XoUlyr5YvfD2FuPdwtadb4mSLk248VLEoadNr3IhQLWnQ5roW8GE+w3dTGcQQZDI2A2DgCYvyp4cT+g1psZazb7cUiOzfehry+EXPNadnfPqkykvCT9x/WUqtjvZbHdu0DcT3mGSmcX/NpsViqTGLfg1pkbVRKXsIWOu3dIJbKZk6h1pq340dWBpzg7mUFYDVU4vaC7bDtuQF73CwWh+gvonq4OyT11Krycv6P81q0PJRrefbst/hey7NqW40f9Dk2P5ODLed47vV3tGj5KId8prdP6XcTlXHyEvETcrDDiDhnRzdzPq/Fy8dqbi/Gk2z7gtjbRtR4PxKJ915FPIbKhBB3pHNQ2evtU2pCpbia3NnWyYXJMM++3K+ylttYmKNLKpQcK2lXpHOwNvk5Pzqm1VWGK8kjyP3Rlg6267fAWq9KlyB+TFO6kIoBq89JuxJCEDjtu1Q9XQ8yp8+wZWwFsRePtE7N2FtVj89quqUIkW83GryMtCvSOUS3d3LuxxGtrjLMHh9Q7oYxal/R1TjovVo11XJMkv8R6ZGkXZHwt+oMnu1/jYvTM1rl6ihYUU4de4mths3KYiGFMekQmn5NsTImyP8wusM5aVfcNojQlXRwqu84Z7/5jgtR579iUsrluRC2OPvl1zxz9Bjb/jYVSLKn4l6QWuNk3KVVr41J8nXBPUPSrkjn4Eaq2zfbzUEk/L0q9zrb9yAjtWK8Vn13j0yApVMF6ee4VQS1yopQhRtBL1qiMfeWIIswVWmTFGsj4ctb0qCMy3dxLeSHY2Q8rnWsH8NEtVPkPwQPvI870k+4K4Ul0UuVQa5PojudwCVuCJ3qCeSC+/S0VUD0LxYtO+ZoXWLWAAAAAElFTkSuQmCC"

/***/ }),

/***/ "0366":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var aCallable = __webpack_require__("59ed");
var NATIVE_BIND = __webpack_require__("40d5");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "0414":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MAX_ZOOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return DEFAULT_TILE_SIZE; });
/**
 * @module ol/tilegrid/common
 */
/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;
/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = 256;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "045d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/extent/Relationship
 */
/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16,
});
//# sourceMappingURL=Relationship.js.map

/***/ }),

/***/ "06a0":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "06cf":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var call = __webpack_require__("c65b");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createPropertyDescriptor = __webpack_require__("5c6c");
var toIndexedObject = __webpack_require__("fc6a");
var toPropertyKey = __webpack_require__("a04b");
var hasOwn = __webpack_require__("1a2d");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "06db":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "06f8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return altKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return altShiftKeysOnly; });
/* unused harmony export focus */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return focusWithTabindex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return always; });
/* unused harmony export click */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return mouseActionButton; });
/* unused harmony export never */
/* unused harmony export pointerMove */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return singleClick; });
/* unused harmony export doubleClick */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return noModifierKeys; });
/* unused harmony export platformModifierKeyOnly */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return shiftKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return targetNotEditable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return mouseOnly; });
/* unused harmony export touchOnly */
/* unused harmony export penOnly */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return primaryAction; });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0b2d");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("57cb");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("617d");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("92fa");
/**
 * @module ol/events/condition
 */




/**
 * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */
/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */
function all(var_args) {
    var conditions = arguments;
    /**
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} All conditions passed.
     */
    return function (event) {
        var pass = true;
        for (var i = 0, ii = conditions.length; i < ii; ++i) {
            pass = pass && conditions[i](event);
            if (!pass) {
                break;
            }
        }
        return pass;
    };
}
/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
var altKeyOnly = function (mapBrowserEvent) {
    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
    return (originalEvent.altKey &&
        !(originalEvent.metaKey || originalEvent.ctrlKey) &&
        !originalEvent.shiftKey);
};
/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
var altShiftKeysOnly = function (mapBrowserEvent) {
    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
    return (originalEvent.altKey &&
        !(originalEvent.metaKey || originalEvent.ctrlKey) &&
        originalEvent.shiftKey);
};
/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */
var focus = function (event) {
    var targetElement = event.map.getTargetElement();
    var activeElement = event.map.getOwnerDocument().activeElement;
    return targetElement.contains(activeElement);
};
/**
 * Return `true` if the map has the focus or no 'tabindex' attribute set.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map container has the focus or no 'tabindex' attribute.
 */
var focusWithTabindex = function (event) {
    return event.map.getTargetElement().hasAttribute('tabindex')
        ? focus(event)
        : true;
};
/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */
var always = _functions_js__WEBPACK_IMPORTED_MODULE_1__[/* TRUE */ "b"];
/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
var click = function (mapBrowserEvent) {
    return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].CLICK;
};
/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
var mouseActionButton = function (mapBrowserEvent) {
    var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
    return originalEvent.button == 0 && !(_has_js__WEBPACK_IMPORTED_MODULE_2__[/* WEBKIT */ "f"] && _has_js__WEBPACK_IMPORTED_MODULE_2__[/* MAC */ "d"] && originalEvent.ctrlKey);
};
/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */
var never = _functions_js__WEBPACK_IMPORTED_MODULE_1__[/* FALSE */ "a"];
/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
var pointerMove = function (mapBrowserEvent) {
    return mapBrowserEvent.type == 'pointermove';
};
/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
var singleClick = function (mapBrowserEvent) {
    return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].SINGLECLICK;
};
/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
var doubleClick = function (mapBrowserEvent) {
    return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].DBLCLICK;
};
/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
var noModifierKeys = function (mapBrowserEvent) {
    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
    return (!originalEvent.altKey &&
        !(originalEvent.metaKey || originalEvent.ctrlKey) &&
        !originalEvent.shiftKey);
};
/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
var platformModifierKeyOnly = function (mapBrowserEvent) {
    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
    return (!originalEvent.altKey &&
        (_has_js__WEBPACK_IMPORTED_MODULE_2__[/* MAC */ "d"] ? originalEvent.metaKey : originalEvent.ctrlKey) &&
        !originalEvent.shiftKey);
};
/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
var shiftKeyOnly = function (mapBrowserEvent) {
    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
    return (!originalEvent.altKey &&
        !(originalEvent.metaKey || originalEvent.ctrlKey) &&
        originalEvent.shiftKey);
};
/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
var targetNotEditable = function (mapBrowserEvent) {
    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
    var tagName = /** @type {Element} */ (originalEvent.target).tagName;
    return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};
/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
var mouseOnly = function (mapBrowserEvent) {
    var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent).originalEvent;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__[/* assert */ "a"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvent.pointerType == 'mouse';
};
/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */
var touchOnly = function (mapBrowserEvent) {
    var pointerEvt = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent).originalEvent;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__[/* assert */ "a"])(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'touch';
};
/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */
var penOnly = function (mapBrowserEvent) {
    var pointerEvt = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent).originalEvent;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__[/* assert */ "a"])(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'pen';
};
/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See https://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
var primaryAction = function (mapBrowserEvent) {
    var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent).originalEvent;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__[/* assert */ "a"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    return pointerEvent.isPrimary && pointerEvent.button === 0;
};
//# sourceMappingURL=condition.js.map

/***/ }),

/***/ "070d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/render/EventType
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Triggered before a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#prerender
     * @api
     */
    PRERENDER: 'prerender',
    /**
     * Triggered after a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#postrender
     * @api
     */
    POSTRENDER: 'postrender',
    /**
     * Triggered before layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    PRECOMPOSE: 'precompose',
    /**
     * Triggered after layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#postcompose
     * @api
     */
    POSTCOMPOSE: 'postcompose',
    /**
     * Triggered when rendering is complete, i.e. all sources and tiles have
     * finished loading for the current viewport, and all tiles are faded in.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#rendercomplete
     * @api
     */
    RENDERCOMPLETE: 'rendercomplete',
});
/**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */
/**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */
//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "07ac":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var $values = __webpack_require__("6f53").values;

// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});


/***/ }),

/***/ "07fa":
/***/ (function(module, exports, __webpack_require__) {

var toLength = __webpack_require__("50c4");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "089b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return wrapX; });
/* unused harmony export createForExtent */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createXYZ; });
/* unused harmony export createForProjection */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return extentFromProjection; });
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("3820");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("78db");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("fced");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("0414");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("256f");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("0af5");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("345d");
/**
 * @module ol/tilegrid
 */







/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
    var tileGrid = projection.getDefaultTileGrid();
    if (!tileGrid) {
        tileGrid = createForProjection(projection);
        projection.setDefaultTileGrid(tileGrid);
    }
    return tileGrid;
}
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
    var z = tileCoord[0];
    var center = tileGrid.getTileCoordCenter(tileCoord);
    var projectionExtent = extentFromProjection(projection);
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__[/* containsCoordinate */ "f"])(projectionExtent, center)) {
        var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__[/* getWidth */ "D"])(projectionExtent);
        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
        center[0] += worldWidth * worldsAway;
        return tileGrid.getTileCoordForCoordAndZ(center, z);
    }
    else {
        return tileCoord;
    }
}
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default} [opt_corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
    var corner = opt_corner !== undefined ? opt_corner : _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].TOP_LEFT;
    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
    return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]({
        extent: extent,
        origin: Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__[/* getCorner */ "x"])(extent, corner),
        resolutions: resolutions,
        tileSize: opt_tileSize,
    });
}
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */
/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [opt_options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(opt_options) {
    var xyzOptions = opt_options || {};
    var extent = xyzOptions.extent || Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__[/* get */ "m"])('EPSG:3857').getExtent();
    var gridOptions = {
        extent: extent,
        minZoom: xyzOptions.minZoom,
        tileSize: xyzOptions.tileSize,
        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),
    };
    return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"](gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [opt_maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__[/* DEFAULT_MAX_ZOOM */ "a"];
    var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__[/* getHeight */ "z"])(extent);
    var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__[/* getWidth */ "D"])(extent);
    var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__[/* toSize */ "c"])(opt_tileSize !== undefined ? opt_tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__[/* DEFAULT_TILE_SIZE */ "b"]);
    var maxResolution = opt_maxResolution > 0
        ? opt_maxResolution
        : Math.max(width / tileSize[0], height / tileSize[1]);
    var length = maxZoom + 1;
    var resolutions = new Array(length);
    for (var z = 0; z < length; ++z) {
        resolutions[z] = maxResolution / Math.pow(2, z);
    }
    return resolutions;
}
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default} [opt_corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
    var extent = extentFromProjection(projection);
    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
    projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__[/* get */ "m"])(projection);
    var extent = projection.getExtent();
    if (!extent) {
        var half = (180 * _proj_js__WEBPACK_IMPORTED_MODULE_4__[/* METERS_PER_UNIT */ "a"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"].DEGREES]) / projection.getMetersPerUnit();
        extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__[/* createOrUpdate */ "k"])(-half, -half, half, half);
    }
    return extent;
}
//# sourceMappingURL=tilegrid.js.map

/***/ }),

/***/ "091f":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "0999":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createCanvasContext2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return outerWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return outerHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return replaceNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return removeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removeChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return replaceChildren; });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("617d");

/**
 * @module ol/dom
 */
//FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [opt_width] Canvas width.
 * @param {number} [opt_height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
    /** @type {HTMLCanvasElement|OffscreenCanvas} */
    var canvas;
    if (opt_canvasPool && opt_canvasPool.length) {
        canvas = opt_canvasPool.shift();
    }
    else if (_has_js__WEBPACK_IMPORTED_MODULE_0__[/* WORKER_OFFSCREEN_CANVAS */ "g"]) {
        canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);
    }
    else {
        canvas = document.createElement('canvas');
    }
    if (opt_width) {
        canvas.width = opt_width;
    }
    if (opt_height) {
        canvas.height = opt_height;
    }
    //FIXME Allow OffscreenCanvasRenderingContext2D as return type
    return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d', opt_Context2DSettings));
}
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
    var width = element.offsetWidth;
    var style = getComputedStyle(element);
    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
    return width;
}
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
    var height = element.offsetHeight;
    var style = getComputedStyle(element);
    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    return height;
}
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
    var parent = oldNode.parentNode;
    if (parent) {
        parent.replaceChild(newNode, oldNode);
    }
}
/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */
function removeNode(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
    while (node.lastChild) {
        node.removeChild(node.lastChild);
    }
}
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */
function replaceChildren(node, children) {
    var oldChildren = node.childNodes;
    for (var i = 0; true; ++i) {
        var oldChild = oldChildren[i];
        var newChild = children[i];
        // check if our work is done
        if (!oldChild && !newChild) {
            break;
        }
        // check if children match
        if (oldChild === newChild) {
            continue;
        }
        // check if a new child needs to be added
        if (!oldChild) {
            node.appendChild(newChild);
            continue;
        }
        // check if an old child needs to be removed
        if (!newChild) {
            node.removeChild(oldChild);
            --i;
            continue;
        }
        // reorder
        node.insertBefore(newChild, oldChild);
    }
}
//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "0a9d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getInteriorPointOfArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getInteriorPointsOfMultiArray; });
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("25f1");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9f5e");
/**
 * @module ol/geom/flat/interiorpoint
 */


/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
    var i, ii, x, x1, x2, y1, y2;
    var y = flatCenters[flatCentersOffset + 1];
    /** @type {Array<number>} */
    var intersections = [];
    // Calculate intersections with the horizontal line
    for (var r = 0, rr = ends.length; r < rr; ++r) {
        var end = ends[r];
        x1 = flatCoordinates[end - stride];
        y1 = flatCoordinates[end - stride + 1];
        for (i = offset; i < end; i += stride) {
            x2 = flatCoordinates[i];
            y2 = flatCoordinates[i + 1];
            if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
                x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
                intersections.push(x);
            }
            x1 = x2;
            y1 = y2;
        }
    }
    // Find the longest segment of the horizontal line that has its center point
    // inside the linear ring.
    var pointX = NaN;
    var maxSegmentLength = -Infinity;
    intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_1__[/* numberSafeCompareFunction */ "g"]);
    x1 = intersections[0];
    for (i = 1, ii = intersections.length; i < ii; ++i) {
        x2 = intersections[i];
        var segmentLength = Math.abs(x2 - x1);
        if (segmentLength > maxSegmentLength) {
            x = (x1 + x2) / 2;
            if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_0__[/* linearRingsContainsXY */ "c"])(flatCoordinates, offset, ends, stride, x, y)) {
                pointX = x;
                maxSegmentLength = segmentLength;
            }
        }
        x1 = x2;
    }
    if (isNaN(pointX)) {
        // There is no horizontal line that has its center point inside the linear
        // ring.  Use the center of the the linear ring's extent.
        pointX = flatCenters[flatCentersOffset];
    }
    if (opt_dest) {
        opt_dest.push(pointX, y, maxSegmentLength);
        return opt_dest;
    }
    else {
        return [pointX, y, maxSegmentLength];
    }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
    var interiorPoints = [];
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
        offset = ends[ends.length - 1];
    }
    return interiorPoints;
}
//# sourceMappingURL=interiorpoint.js.map

/***/ }),

/***/ "0aae":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0095.74f0f1f7.png";

/***/ }),

/***/ "0af5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return boundingExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return closestSquaredDistanceXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return containsCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return containsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return containsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return coordinateRelationship; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return createEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return createOrUpdateEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return createOrUpdateFromCoordinate; });
/* unused harmony export createOrUpdateFromCoordinates */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return createOrUpdateFromFlatCoordinates; });
/* unused harmony export createOrUpdateFromRings */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return equals; });
/* unused harmony export approximatelyEquals */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return extendCoordinate; });
/* unused harmony export extendCoordinates */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return extendFlatCoordinates; });
/* unused harmony export extendRings */
/* unused harmony export extendXY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return forEachCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return getBottomLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return getBottomRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return getCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return getCorner; });
/* unused harmony export getEnlargedArea */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return getForViewAndSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return getHeight; });
/* unused harmony export getIntersectionArea */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return getIntersection; });
/* unused harmony export getMargin */
/* unused harmony export getSize */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return getTopLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return getTopRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return getWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return intersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return returnOrUpdate; });
/* unused harmony export scaleFromCenter */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return intersectsSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return applyTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return wrapX; });
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("3820");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("045d");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("92fa");
/**
 * @module ol/extent
 */



/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */
/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
    var extent = createEmpty();
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        extendCoordinate(extent, coordinates[i]);
    }
    return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [opt_extent] Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
    var minX = Math.min.apply(null, xs);
    var minY = Math.min.apply(null, ys);
    var maxX = Math.max.apply(null, xs);
    var maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0] - value;
        opt_extent[1] = extent[1] - value;
        opt_extent[2] = extent[2] + value;
        opt_extent[3] = extent[3] + value;
        return opt_extent;
    }
    else {
        return [
            extent[0] - value,
            extent[1] - value,
            extent[2] + value,
            extent[3] + value,
        ];
    }
}
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} The clone.
 */
function clone(extent, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
    }
    else {
        return extent.slice();
    }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
    var dx, dy;
    if (x < extent[0]) {
        dx = extent[0] - x;
    }
    else if (extent[2] < x) {
        dx = x - extent[2];
    }
    else {
        dx = 0;
    }
    if (y < extent[1]) {
        dy = extent[1] - y;
    }
    else if (extent[3] < y) {
        dy = y - extent[3];
    }
    else {
        dy = 0;
    }
    return dx * dx + dy * dy;
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
}
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
    return (extent1[0] <= extent2[0] &&
        extent2[2] <= extent1[2] &&
        extent1[1] <= extent2[1] &&
        extent2[3] <= extent1[3]);
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var x = coordinate[0];
    var y = coordinate[1];
    var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].UNKNOWN;
    if (x < minX) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LEFT;
    }
    else if (x > maxX) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].RIGHT;
    }
    if (y < minY) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].BELOW;
    }
    else if (y > maxY) {
        relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ABOVE;
    }
    if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].UNKNOWN) {
        relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].INTERSECTING;
    }
    return relationship;
}
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
    return [Infinity, Infinity, -Infinity, -Infinity];
}
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = minX;
        opt_extent[1] = minY;
        opt_extent[2] = maxX;
        opt_extent[3] = maxY;
        return opt_extent;
    }
    else {
        return [minX, minY, maxX, maxY];
    }
}
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
    var x = coordinate[0];
    var y = coordinate[1];
    return createOrUpdate(x, y, x, y, opt_extent);
}
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendCoordinates(extent, coordinates);
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendRings(extent, rings);
}
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
    return (extent1[0] == extent2[0] &&
        extent1[2] == extent2[2] &&
        extent1[1] == extent2[1] &&
        extent1[3] == extent2[3]);
}
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */
function approximatelyEquals(extent1, extent2, tolerance) {
    return (Math.abs(extent1[0] - extent2[0]) < tolerance &&
        Math.abs(extent1[2] - extent2[2]) < tolerance &&
        Math.abs(extent1[1] - extent2[1]) < tolerance &&
        Math.abs(extent1[3] - extent2[3]) < tolerance);
}
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) {
        extent1[0] = extent2[0];
    }
    if (extent2[2] > extent1[2]) {
        extent1[2] = extent2[2];
    }
    if (extent2[1] < extent1[1]) {
        extent1[1] = extent2[1];
    }
    if (extent2[3] > extent1[3]) {
        extent1[3] = extent2[3];
    }
    return extent1;
}
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) {
        extent[0] = coordinate[0];
    }
    if (coordinate[0] > extent[2]) {
        extent[2] = coordinate[0];
    }
    if (coordinate[1] < extent[1]) {
        extent[1] = coordinate[1];
    }
    if (coordinate[1] > extent[3]) {
        extent[3] = coordinate[1];
    }
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        extendCoordinate(extent, coordinates[i]);
    }
    return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for (; offset < end; offset += stride) {
        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    }
    return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
    for (var i = 0, ii = rings.length; i < ii; ++i) {
        extendCoordinates(extent, rings[i]);
    }
    return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
}
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */
function forEachCorner(extent, callback) {
    var val;
    val = callback(getBottomLeft(extent));
    if (val) {
        return val;
    }
    val = callback(getBottomRight(extent));
    if (val) {
        return val;
    }
    val = callback(getTopRight(extent));
    if (val) {
        return val;
    }
    val = callback(getTopLeft(extent));
    if (val) {
        return val;
    }
    return false;
}
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
    var area = 0;
    if (!isEmpty(extent)) {
        area = getWidth(extent) * getHeight(extent);
    }
    return area;
}
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
    return [extent[0], extent[1]];
}
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
    return [extent[2], extent[1]];
}
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {import("./extent/Corner.js").default} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
    var coordinate;
    if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].BOTTOM_LEFT) {
        coordinate = getBottomLeft(extent);
    }
    else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].BOTTOM_RIGHT) {
        coordinate = getBottomRight(extent);
    }
    else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].TOP_LEFT) {
        coordinate = getTopLeft(extent);
    }
    else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].TOP_RIGHT) {
        coordinate = getTopRight(extent);
    }
    else {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__[/* assert */ "a"])(false, 13); // Invalid corner
    }
    return coordinate;
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
    var minX = Math.min(extent1[0], extent2[0]);
    var minY = Math.min(extent1[1], extent2[1]);
    var maxX = Math.max(extent1[2], extent2[2]);
    var maxY = Math.max(extent1[3], extent2[3]);
    return (maxX - minX) * (maxY - minY);
}
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
    var dx = (resolution * size[0]) / 2;
    var dy = (resolution * size[1]) / 2;
    var cosRotation = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    var xCos = dx * cosRotation;
    var xSin = dx * sinRotation;
    var yCos = dy * cosRotation;
    var ySin = dy * sinRotation;
    var x = center[0];
    var y = center[1];
    var x0 = x - xCos + ySin;
    var x1 = x - xCos - ySin;
    var x2 = x + xCos - ySin;
    var x3 = x + xCos + ySin;
    var y0 = y - xSin - yCos;
    var y1 = y - xSin + yCos;
    var y2 = y + xSin + yCos;
    var y3 = y + xSin - yCos;
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
    return extent[3] - extent[1];
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
    var intersection = getIntersection(extent1, extent2);
    return getArea(intersection);
}
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [opt_extent] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
    var intersection = opt_extent ? opt_extent : createEmpty();
    if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) {
            intersection[0] = extent1[0];
        }
        else {
            intersection[0] = extent2[0];
        }
        if (extent1[1] > extent2[1]) {
            intersection[1] = extent1[1];
        }
        else {
            intersection[1] = extent2[1];
        }
        if (extent1[2] < extent2[2]) {
            intersection[2] = extent1[2];
        }
        else {
            intersection[2] = extent2[2];
        }
        if (extent1[3] < extent2[3]) {
            intersection[3] = extent1[3];
        }
        else {
            intersection[3] = extent2[3];
        }
    }
    else {
        createOrUpdateEmpty(intersection);
    }
    return intersection;
}
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
}
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
    return [extent[2] - extent[0], extent[3] - extent[1]];
}
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
    return [extent[0], extent[3]];
}
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
    return [extent[2], extent[3]];
}
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
    return extent[2] - extent[0];
}
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
    return (extent1[0] <= extent2[2] &&
        extent1[2] >= extent2[0] &&
        extent1[1] <= extent2[3] &&
        extent1[3] >= extent2[1]);
}
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
}
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
    }
    else {
        return extent;
    }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
    var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
    var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= deltaY;
    extent[3] += deltaY;
}
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
    var intersects = false;
    var startRel = coordinateRelationship(extent, start);
    var endRel = coordinateRelationship(extent, end);
    if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].INTERSECTING ||
        endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].INTERSECTING) {
        intersects = true;
    }
    else {
        var minX = extent[0];
        var minY = extent[1];
        var maxX = extent[2];
        var maxY = extent[3];
        var startX = start[0];
        var startY = start[1];
        var endX = end[0];
        var endY = end[1];
        var slope = (endY - startY) / (endX - startX);
        var x = void 0, y = void 0;
        if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ABOVE)) {
            // potentially intersects top
            x = endX - (endY - maxY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects &&
            !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].RIGHT) &&
            !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].RIGHT)) {
            // potentially intersects right
            y = endY - (endX - maxX) * slope;
            intersects = y >= minY && y <= maxY;
        }
        if (!intersects &&
            !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].BELOW) &&
            !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].BELOW)) {
            // potentially intersects bottom
            x = endX - (endY - minY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects &&
            !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LEFT) &&
            !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LEFT)) {
            // potentially intersects left
            y = endY - (endX - minX) * slope;
            intersects = y >= minY && y <= maxY;
        }
    }
    return intersects;
}
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [opt_extent] Destination extent.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent, opt_stops) {
    var coordinates = [];
    if (opt_stops > 1) {
        var width = extent[2] - extent[0];
        var height = extent[3] - extent[1];
        for (var i = 0; i < opt_stops; ++i) {
            coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);
        }
    }
    else {
        coordinates = [
            extent[0],
            extent[1],
            extent[2],
            extent[1],
            extent[2],
            extent[3],
            extent[0],
            extent[3],
        ];
    }
    transformFn(coordinates, coordinates, 2);
    var xs = [];
    var ys = [];
    for (var i = 0, l = coordinates.length; i < l; i += 2) {
        xs.push(coordinates[i]);
        ys.push(coordinates[i + 1]);
    }
    return _boundingExtentXYs(xs, ys, opt_extent);
}
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */
function wrapX(extent, projection) {
    var projectionExtent = projection.getExtent();
    var center = getCenter(extent);
    if (projection.canWrapX() &&
        (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
        var worldWidth = getWidth(projectionExtent);
        var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
        var offset = worldsAway * worldWidth;
        extent[0] -= offset;
        extent[2] -= offset;
    }
    return extent;
}
//# sourceMappingURL=extent.js.map

/***/ }),

/***/ "0b0e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IMAGE_SMOOTHING_DISABLED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return IMAGE_SMOOTHING_ENABLED; });
/**
 * @module ol/renderer/canvas/common
 */
/**
 * Context options to disable image smoothing.
 * @type {Object}
 */
var IMAGE_SMOOTHING_DISABLED = {
    imageSmoothingEnabled: false,
    msImageSmoothingEnabled: false,
};
/**
 * Context options to enable image smoothing.
 * @type {Object}
 */
var IMAGE_SMOOTHING_ENABLED = {
    imageSmoothingEnabled: true,
    msImageSmoothingEnabled: true,
};
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "0b2d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("01d4");
/**
 * @module ol/MapBrowserEventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * A true single click with no dragging and no double click. Note that this
     * event is delayed by 250 ms to ensure that it is not a double click.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
     * @api
     */
    SINGLECLICK: 'singleclick',
    /**
     * A click with no dragging. A double click will fire two of this.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
     * @api
     */
    CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].CLICK,
    /**
     * A true double click, with no dragging.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
     * @api
     */
    DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].DBLCLICK,
    /**
     * Triggered when a pointer is dragged.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
     * @api
     */
    POINTERDRAG: 'pointerdrag',
    /**
     * Triggered when a pointer is moved. Note that on touch devices this is
     * triggered when the map is panned, so is not the same as mousemove.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
     * @api
     */
    POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel',
});
/***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */
//# sourceMappingURL=MapBrowserEventType.js.map

/***/ }),

/***/ "0b42":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isArray = __webpack_require__("e8b5");
var isConstructor = __webpack_require__("68ee");
var isObject = __webpack_require__("861d");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');
var Array = global.Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "0b9c":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGJUlEQVR4nIWVe1DU1xXHP+e3P3bX3eWxvB8CQUQRRKgPKhg01SRATTqZGMn4SM20aHxMY9MoTadpk2mr/QNtpzWJTkZiJpkmJtqYGSepVsVpLVMVElOUoCiBgrxWeS2w7MLu3v7xYzPaWHvufP+5957zPefcc8+RYDAIgIgwJaVAxcj4xLcvt99OrW91RXT1j9LaPYSmmxRT14KTAUlLiCA9Npz5GXHuvIzYTqfDegE4ApwAUEohSqmQ4UrglbdONU0/+JdGbvQOkxhlI2O6k2SnndwHYom2W0AElKJ/1Efzv2/TPejhxs0BegbGSI11UFmax5bH82+akFeBmhBBdX2ra0fpjsPER9r48dOFLMiMZ8QzQc/gGC1dg7S4RujrH0WZNCQQJDHWQVZcOLNSnCQ67UQ5LDRcd7H3gwvcdLk5tvspSgvS9opSamPvkOfNpKffoLpyKWsemUv1++c58s8bdHcPQzAImgYC6CbQBIIK/AFQGOcmjeSkSFYXzaRq7WLeO9XEzt+d5MsPtyJKqebNB85md9xy82HVd4mv2M94/wg47WDRYcwHXj9E2xER1IQfRr0GifF4YDODSYPBMaxOO8PHfsSjrxwjLS4cXSnluN4zpLaW5bHx9TOMD4xBYqSh7BqhsCiTdUtns/3QOdSoF91mZtv6YoqzkxCgpXuIvR81MDho6Hl7htmyv5bnSvM4eLoJHXBZdG16a++waukegnCLEbp7nJd+WMJvNzyIxzfJ9gNnsVt1Lv5hHTmp0fT0j6KCitXFM9laNpesTW/TP+QBu5nPvrrFkjnJmHVNNBG5lhYXjiXMJGbdJASVAIJZl8stvVLb2Ckj45PC2ISsKZ8nOanRkrXtXUl+cJeklOwSS8Xr4nRYZePKfGHMJwSVpMeFyy33uOSmxgR1pVR1YVbiU90DY/q3ZsRxvr7NSM+0MD756xUW5qVSlJ0EZhPn/tUJwNGd5ZxcNhsRYXFuCkopCtJjDL2AYmFmPJc7+lmWkzyoicilh3JTWptvDkharENQCEoZsFvEYdElGAwKNrNcu9IlZb88JioQlKqKQtm5epHYrbqIiHzRfluMKghKenyE9AyMySP5aY06wIzEyDMenz87JdoB08KMCjFpRoWIkTEAom2cPN/KyU8bwRoGKPbsLGf+jHgO/70FwkyYHBY0AU2EB+IjPtanfvG7BRmx2wZHvRTmpXDxUgc4rBBU2Mw6dmsYKAUBBdYwNm9ayjSETSvzyU5xUvnaadpv9IEmPLY4ky/abrNi3nSAI9oUwYXKh3Ob6q72sLZkFngmAAW6RpvLTUOry4jEH8BqDeNnTy7kF+uKcA2P8/DLf6bmaD1E2WAyQEXRTOqu9vDsd+YcB3r0UC9KiXHss1vNB5Ki7CopK4EelxtxOtjzwUX2vFMHTjtis+D1B0jfcNBwa8xnfMaYcPD4KFiUwfikn9zUaEl02quVUoQiAKh5fuW8vuMNbfLiEwvA7UUpIyVETOMuCTMZiLYjDuvXZD99Yj41p7+UF75XcAk4B6CJSKhV+wsy4naZdY3UGLtk5aYIo14RTQSTJoAoMC6bNAMyVQFDHlm+PEd6Bz2SER9BbmrM86ERoCmlCAHYt3tdcfuh2mZ+vb5I4fMrFQgqQN1rCSg1GVCaVVc/X7VAHaptZl/lstPAP0I2v44gNHASomzrl2Qn0dTRL9s3LBFujRheCoKoO4AopQSXWw7uKJc3TlyWLWVziQ63PhvyXkTueoOQ1L28elHNhet9PJSTTPmjudA3bDTOqQUCgSB0DfKrF0vpd4/j8frZXJq3Fei609idE+2u/b4hT/Nju47P/tNPSnlhfy2f1jaD3WLMBJ8f/AFe+kEJC7MSqHqnjmuvPXNYN2lrvmHofxAAZJ1p7Lzy/T+eMr+1bQUdLjcn6tsYGPGSmRBJxfI5XO/sZ/dHn/H579c2JETZioHJbxCEhv49wxAp+qpv+NSTr35sn5UaTdmiGYTbzbT3ujl6thlnuJVPfrPqc5MmS5RS3nvauB/BFMlM4M33/nat5GRDm+7xTaq4CJusKslyr8hPexvYfp8s3DdF/y3PAM8BVqAbqAKu/j+l/wCoCYZWZ7xV7gAAAABJRU5ErkJggg=="

/***/ }),

/***/ "0cb2":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toObject = __webpack_require__("7b0b");

var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice(str, 0, position);
      case "'": return stringSlice(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ "0cfb":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var createElement = __webpack_require__("cc12");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "0d51":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

var String = global.String;

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "0ec0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("da5c");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("cef7");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("57cb");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/events/Target
 */




/**
 * @typedef {EventTarget|Target} EventTargetLike
 */
/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var Target = /** @class */ (function (_super) {
    __extends(Target, _super);
    /**
     * @param {*} [opt_target] Default event target for dispatched events.
     */
    function Target(opt_target) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {*}
         */
        _this.eventTarget_ = opt_target;
        /**
         * @private
         * @type {Object<string, number>}
         */
        _this.pendingRemovals_ = null;
        /**
         * @private
         * @type {Object<string, number>}
         */
        _this.dispatching_ = null;
        /**
         * @private
         * @type {Object<string, Array<import("../events.js").Listener>>}
         */
        _this.listeners_ = null;
        return _this;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    Target.prototype.addEventListener = function (type, listener) {
        if (!type || !listener) {
            return;
        }
        var listeners = this.listeners_ || (this.listeners_ = {});
        var listenersForType = listeners[type] || (listeners[type] = []);
        if (listenersForType.indexOf(listener) === -1) {
            listenersForType.push(listener);
        }
    };
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */
    Target.prototype.dispatchEvent = function (event) {
        var isString = typeof event === 'string';
        var type = isString ? event : event.type;
        var listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
            return;
        }
        var evt = isString ? new _Event_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"](event) : /** @type {Event} */ (event);
        if (!evt.target) {
            evt.target = this.eventTarget_ || this;
        }
        var dispatching = this.dispatching_ || (this.dispatching_ = {});
        var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
            dispatching[type] = 0;
            pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        var propagate;
        for (var i = 0, ii = listeners.length; i < ii; ++i) {
            if ('handleEvent' in listeners[i]) {
                propagate = /** @type {import("../events.js").ListenerObject} */ (listeners[i]).handleEvent(evt);
            }
            else {
                propagate = /** @type {import("../events.js").ListenerFunction} */ (listeners[i]).call(this, evt);
            }
            if (propagate === false || evt.propagationStopped) {
                propagate = false;
                break;
            }
        }
        if (--dispatching[type] === 0) {
            var pr = pendingRemovals[type];
            delete pendingRemovals[type];
            while (pr--) {
                this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__[/* VOID */ "c"]);
            }
            delete dispatching[type];
        }
        return propagate;
    };
    /**
     * Clean up.
     */
    Target.prototype.disposeInternal = function () {
        this.listeners_ && Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[/* clear */ "b"])(this.listeners_);
    };
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */
    Target.prototype.getListeners = function (type) {
        return (this.listeners_ && this.listeners_[type]) || undefined;
    };
    /**
     * @param {string} [opt_type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */
    Target.prototype.hasListener = function (opt_type) {
        if (!this.listeners_) {
            return false;
        }
        return opt_type
            ? opt_type in this.listeners_
            : Object.keys(this.listeners_).length > 0;
    };
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    Target.prototype.removeEventListener = function (type, listener) {
        var listeners = this.listeners_ && this.listeners_[type];
        if (listeners) {
            var index = listeners.indexOf(listener);
            if (index !== -1) {
                if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                    // make listener a no-op, and remove later in #dispatchEvent()
                    listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__[/* VOID */ "c"];
                    ++this.pendingRemovals_[type];
                }
                else {
                    listeners.splice(index, 1);
                    if (listeners.length === 0) {
                        delete this.listeners_[type];
                    }
                }
            }
        }
    };
    return Target;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (Target);
//# sourceMappingURL=Target.js.map

/***/ }),

/***/ "0f01":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFYklEQVR4nIWVaWxUVRTHf+fNMJ12OtNO2+m0lBYKFMSxUhWQJSgWsGjwi0iNKK41CsYdiYkmGhe+VNSIgkEWo1FQjLhExVRKTCRKQFAQy1ZB6F66TduZtjPzjh/mTR0W8d7c3Jd7zj3n3v/9/88T0zQBEBGsVgFU9oaHrj106mzh3vo2T2NHH/VN3Rh2m2K5mZGYFPk9jM5xc3WxL1hanHPGm+7cA2wDdgCoKqKqicBVwAubag6P2vDdQU609JCXmUbxKC8jvS4CY3LIcqWACKjS0TdI3d9naeoKcaKhk+bOfgpz0qmqKGXZLZMbbMiLwMZEguq99W0rKlZsJTcjjSdun8Y143LpDQ3R3NXPscYujrX10trRh9oMJGaSl5NOic/NhAIveV4Xmekp7DvexupP9tDQFmT7qtuoKCtaLar6YEt3aH3+7WuprrqOO+ZfQfWWX9j28wmamnrANMFmxO9ot8VnVYiZFlYKhjAyP4PFM8azcsl0Pq45zDOvf8+fny5HVLXu4Xd3XXa6PcinK28mt3Id4Y5e8LpghA0RYRjEwSj0DYArBVIdiAWvqkIkBt0hnF4XPdsf5cYXtlPkc2Ooavrx5m59YF5AH3xnp4Y7+5W8DMVhV+JPpAhKd0gzMlN174b7tLJ8khIMqSpxO6I47Cp+jw509uuydbX6UEWpNnb2qwG0pdgNqW/p4VhTN7hTQOMwiBWbnjBLF06mdXMVU8b7yXY7IWr+a0fjsJkKLge//tVOeCiKw26IISJHi3xuUkbYxGG3CaYKIIiIWgMRiUZisuuPBgFkKBoTDM6xJ/wxVUb73NIeDEugMNs0VLV6WklepDcc0avG+pRILH6k5O5J1S1f7telb9aoqqrdMBQVPc9LBZSY6pRxuXrodIdOLMjsMkTkwJxAQX1dQ6cU5aRbt1ZBkoaaQmqK+DypIiKicK7dGkp87+hcjzR39sv8yUUHDYCxeRk7Q4NRCrLSIXVEHEtkuIOQmBiezrMjEI1hy0zFEDBEGJPr+cIiOB+WFefQ1TfAtNICCA9xYdNzv/QiLn2DLJw+jt9OnmXulaMAtiUS7KmaFzi8+0gzS2ZPgNDQhRHiegLAYTMuaicao3LGeHYfaebeGyZ9DTQbCTIXZKevcTkd5Ge6NL/ErwxG1dJQvIOa1hyJmcM2tdYID2rZ1GINR6IaKMwiz+uqVlUkqZrafzvZ3rD6qwP+suJcXfHad+BzIwmlWkUuURoQiSs5ofT2IFtW3cZb3/wu7y0vPxAozL5aVTESNAaiZcW+Vx12g8Jsl5QECoS+gWFNgKWroagQMwXiOgCE7pCUl18uLV0hKc71ECjMfsw6NMMQWVV1zao7Z57aXFvHy3fNUAajqhYcKIqI4nQoNtsw7zUSU8Np1+cWXaOba+tYU3X9D8BPiZhGkhAB8Gem3TXrsnwOn+6Qx++ZJbT3yr+cTOY9oqpCW1A2rLhJ1u44JMsWXEGW23lv4vQiQoJFyW3384unbtxzvJU5l4/kphsD0NoTf6dk3sdMaOzipacr6AiGCQ1EebiidDnQmBws+Y92znprd6hu4atfT/zoqQqeXFfLt7V18TJtt8XLdjTGs/fPZkqJn5Uf7Obo20u32m3GHRcE+o8EACU7D5754+63ahybHpnL6bYgO/aepLN3gHH+DCrLJ3H8TAerPv+V/W8s2efPTJsJRC5IkKDpRa8hMuOv1p6aW1/8wjWhMIsFU8fidjk41RLks111eN1Ovnll0X6bIbNUdeCiMS6VwEoyHlj/8Y9HZ3+/76Q9NBhRnydNFs0uCc6dXPQ+8PglULgkROe3pcBDgBNoAlYCR/5v0z8JIanJ2FYdOQAAAABJRU5ErkJggg=="

/***/ }),

/***/ "107c":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ "1159":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0090.ea0d8cd1.png";

/***/ }),

/***/ "1238":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "1276":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var apply = __webpack_require__("2ba4");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var isRegExp = __webpack_require__("44e7");
var anObject = __webpack_require__("825a");
var requireObjectCoercible = __webpack_require__("1d80");
var speciesConstructor = __webpack_require__("4840");
var advanceStringIndex = __webpack_require__("8aa5");
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var getMethod = __webpack_require__("dc4a");
var arraySlice = __webpack_require__("4daee");
var callRegExpExec = __webpack_require__("14c3");
var regexpExec = __webpack_require__("9263");
var stickyHelpers = __webpack_require__("9f7f");
var fails = __webpack_require__("d039");

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 0xFFFFFFFF;
var min = Math.min;
var $push = [].push;
var exec = uncurryThis(/./.exec);
var push = uncurryThis($push);
var stringSlice = uncurryThis(''.slice);

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

// @@split logic
fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = toString(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return call(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = call(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push(output, stringSlice(string, lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec(separatorCopy, '')) push(output, '');
      } else push(output, stringSlice(string, lastLastIndex));
      return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
      return splitter
        ? call(splitter, separator, O, limit)
        : call(internalSplit, toString(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (string, limit) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

      if (res.done) return res.value;

      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (UNSUPPORTED_Y ? 'g' : 'y');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          push(A, stringSlice(S, p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            push(A, z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      push(A, stringSlice(S, p));
      return A;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);


/***/ }),

/***/ "1287":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "1300":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return abstract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getUid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VERSION; });
/**
 * @module ol/util
 */
/**
 * @return {?} Any return.
 */
function abstract() {
    return /** @type {?} */ ((function () {
        throw new Error('Unimplemented abstract method.');
    })());
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */
function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
/**
 * OpenLayers version.
 * @type {string}
 */
var VERSION = '6.13.0';
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "137e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js
var EventType = __webpack_require__("01d4");

// EXTERNAL MODULE: ./node_modules/ol/ImageState.js
var ImageState = __webpack_require__("869f");

// EXTERNAL MODULE: ./node_modules/ol/Observable.js
var Observable = __webpack_require__("35a7");

// EXTERNAL MODULE: ./node_modules/ol/source/State.js
var State = __webpack_require__("6d83");

// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// CONCATENATED MODULE: ./node_modules/ol/renderer/Layer.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/renderer/Layer
 */





/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
var Layer_LayerRenderer = /** @class */ (function (_super) {
    __extends(LayerRenderer, _super);
    /**
     * @param {LayerType} layer Layer.
     */
    function LayerRenderer(layer) {
        var _this = _super.call(this) || this;
        /**
         * The renderer is initialized and ready to render.
         * @type {boolean}
         */
        _this.ready = true;
        /** @private */
        _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
        /**
         * @protected
         * @type {LayerType}
         */
        _this.layer_ = layer;
        /**
         * @type {import("../render/canvas/ExecutorGroup").default}
         */
        _this.declutterExecutorGroup = null;
        return _this;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
     * an array of features.
     */
    LayerRenderer.prototype.getFeatures = function (pixel) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    LayerRenderer.prototype.getData = function (pixel) {
        return null;
    };
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    LayerRenderer.prototype.prepareFrame = function (frameState) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Render the layer.
     * @abstract
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */
    LayerRenderer.prototype.renderFrame = function (frameState, target) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */
    LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
        if (!tiles[zoom]) {
            tiles[zoom] = {};
        }
        tiles[zoom][tile.tileCoord.toString()] = tile;
        return undefined;
    };
    /**
     * Create a function that adds loaded tiles to the tile lookup.
     * @param {import("../source/Tile.js").default} source Tile source.
     * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
     *     called with a zoom level and a tile range to add loaded tiles to the lookup.
     * @protected
     */
    LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
        return (
        /**
         * @param {number} zoom Zoom level.
         * @param {import("../TileRange.js").default} tileRange Tile range.
         * @return {boolean} The tile range is fully loaded.
         * @this {LayerRenderer}
         */
        function (zoom, tileRange) {
            var callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        }.bind(this));
    };
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
        return undefined;
    };
    /**
     * @abstract
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
     *    location, null will be returned.  If there is data, but pixel values cannot be
     *    returned, and empty array will be returned.
     */
    LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
        return null;
    };
    /**
     * @return {LayerType} Layer.
     */
    LayerRenderer.prototype.getLayer = function () {
        return this.layer_;
    };
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */
    LayerRenderer.prototype.handleFontsChanged = function () { };
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */
    LayerRenderer.prototype.handleImageChange_ = function (event) {
        var image = /** @type {import("../Image.js").default} */ (event.target);
        if (image.getState() === ImageState["a" /* default */].LOADED) {
            this.renderIfReadyAndVisible();
        }
    };
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../ImageBase.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */
    LayerRenderer.prototype.loadImage = function (image) {
        var imageState = image.getState();
        if (imageState != ImageState["a" /* default */].LOADED && imageState != ImageState["a" /* default */].ERROR) {
            image.addEventListener(EventType["a" /* default */].CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == ImageState["a" /* default */].IDLE) {
            image.load();
            imageState = image.getState();
        }
        return imageState == ImageState["a" /* default */].LOADED;
    };
    /**
     * @protected
     */
    LayerRenderer.prototype.renderIfReadyAndVisible = function () {
        var layer = this.getLayer();
        if (layer.getVisible() && layer.getSourceState() == State["a" /* default */].READY) {
            layer.changed();
        }
    };
    /**
     * Clean up.
     */
    LayerRenderer.prototype.disposeInternal = function () {
        delete this.layer_;
        _super.prototype.disposeInternal.call(this);
    };
    return LayerRenderer;
}(Observable["a" /* default */]));
/* harmony default export */ var Layer = (Layer_LayerRenderer);
//# sourceMappingURL=Layer.js.map
// EXTERNAL MODULE: ./node_modules/ol/render/Event.js
var Event = __webpack_require__("3333");

// EXTERNAL MODULE: ./node_modules/ol/render/EventType.js
var render_EventType = __webpack_require__("070d");

// EXTERNAL MODULE: ./node_modules/ol/transform.js
var ol_transform = __webpack_require__("a896");

// EXTERNAL MODULE: ./node_modules/ol/color.js
var color = __webpack_require__("5c38");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__("0999");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/Layer.js
var Layer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/renderer/canvas/Layer
 */








/**
 * @type {CanvasRenderingContext2D}
 */
var Layer_pixelContext = null;
function createPixelContext() {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    Layer_pixelContext = canvas.getContext('2d');
}
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
var Layer_CanvasLayerRenderer = /** @class */ (function (_super) {
    Layer_extends(CanvasLayerRenderer, _super);
    /**
     * @param {LayerType} layer Layer.
     */
    function CanvasLayerRenderer(layer) {
        var _this = _super.call(this, layer) || this;
        /**
         * @protected
         * @type {HTMLElement}
         */
        _this.container = null;
        /**
         * @protected
         * @type {number}
         */
        _this.renderedResolution;
        /**
         * A temporary transform.  The values in this transform should only be used in a
         * function that sets the values.
         * @protected
         * @type {import("../../transform.js").Transform}
         */
        _this.tempTransform = Object(ol_transform["c" /* create */])();
        /**
         * The transform for rendered pixels to viewport CSS pixels.  This transform must
         * be set when rendering a frame and may be used by other functions after rendering.
         * @protected
         * @type {import("../../transform.js").Transform}
         */
        _this.pixelTransform = Object(ol_transform["c" /* create */])();
        /**
         * The transform for viewport CSS pixels to rendered pixels.  This transform must
         * be set when rendering a frame and may be used by other functions after rendering.
         * @protected
         * @type {import("../../transform.js").Transform}
         */
        _this.inversePixelTransform = Object(ol_transform["c" /* create */])();
        /**
         * @type {CanvasRenderingContext2D}
         */
        _this.context = null;
        /**
         * @type {boolean}
         */
        _this.containerReused = false;
        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */
        _this.pixelContext_ = null;
        /**
         * @protected
         * @type {import("../../PluggableMap.js").FrameState|null}
         */
        _this.frameState = null;
        return _this;
    }
    /**
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
     * @param {number} col The column index.
     * @param {number} row The row index.
     * @return {Uint8ClampedArray|null} The image data.
     */
    CanvasLayerRenderer.prototype.getImageData = function (image, col, row) {
        if (!Layer_pixelContext) {
            createPixelContext();
        }
        Layer_pixelContext.clearRect(0, 0, 1, 1);
        var data;
        try {
            Layer_pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
            data = Layer_pixelContext.getImageData(0, 0, 1, 1).data;
        }
        catch (err) {
            return null;
        }
        return data;
    };
    /**
     * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */
    CanvasLayerRenderer.prototype.getBackground = function (frameState) {
        var layer = this.getLayer();
        var background = layer.getBackground();
        if (typeof background === 'function') {
            background = background(frameState.viewState.resolution);
        }
        return background || undefined;
    };
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {number} opacity Opacity.
     * @param {string} [opt_backgroundColor] Background color.
     */
    CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity, opt_backgroundColor) {
        var layerClassName = this.getLayer().getClassName();
        var container, context;
        if (target &&
            target.className === layerClassName &&
            target.style.opacity === '' &&
            opacity === 1 &&
            (!opt_backgroundColor ||
                (target.style.backgroundColor &&
                    Object(array["b" /* equals */])(Object(color["a" /* asArray */])(target.style.backgroundColor), Object(color["a" /* asArray */])(opt_backgroundColor))))) {
            var canvas = target.firstElementChild;
            if (canvas instanceof HTMLCanvasElement) {
                context = canvas.getContext('2d');
            }
        }
        if (context && context.canvas.style.transform === transform) {
            // Container of the previous layer renderer can be used.
            this.container = target;
            this.context = context;
            this.containerReused = true;
        }
        else if (this.containerReused) {
            // Previously reused container cannot be used any more.
            this.container = null;
            this.context = null;
            this.containerReused = false;
        }
        if (!this.container) {
            container = document.createElement('div');
            container.className = layerClassName;
            var style = container.style;
            style.position = 'absolute';
            style.width = '100%';
            style.height = '100%';
            if (opt_backgroundColor) {
                style.backgroundColor = opt_backgroundColor;
            }
            context = Object(dom["a" /* createCanvasContext2D */])();
            var canvas = context.canvas;
            container.appendChild(canvas);
            style = canvas.style;
            style.position = 'absolute';
            style.left = '0';
            style.transformOrigin = 'top left';
            this.container = container;
            this.context = context;
        }
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */
    CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
        var topLeft = Object(ol_extent["B" /* getTopLeft */])(extent);
        var topRight = Object(ol_extent["C" /* getTopRight */])(extent);
        var bottomRight = Object(ol_extent["v" /* getBottomRight */])(extent);
        var bottomLeft = Object(ol_extent["u" /* getBottomLeft */])(extent);
        Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, topLeft);
        Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, topRight);
        Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, bottomRight);
        Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, bottomLeft);
        var inverted = this.inversePixelTransform;
        Object(ol_transform["a" /* apply */])(inverted, topLeft);
        Object(ol_transform["a" /* apply */])(inverted, topRight);
        Object(ol_transform["a" /* apply */])(inverted, bottomRight);
        Object(ol_transform["a" /* apply */])(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
    };
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @private
     */
    CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
        var layer = this.getLayer();
        if (layer.hasListener(type)) {
            var event_1 = new Event["a" /* default */](type, this.inversePixelTransform, frameState, context);
            layer.dispatchEvent(event_1);
        }
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */
    CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
        this.frameState = frameState;
        this.dispatchRenderEvent_(render_EventType["a" /* default */].PRERENDER, context, frameState);
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */
    CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
        this.dispatchRenderEvent_(render_EventType["a" /* default */].POSTRENDER, context, frameState);
    };
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */
    CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
        var dx1 = width / 2;
        var dy1 = height / 2;
        var sx = pixelRatio / resolution;
        var sy = -sx;
        var dx2 = -center[0] + offsetX;
        var dy2 = -center[1];
        return Object(ol_transform["b" /* compose */])(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    };
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
     *    location, null will be returned.  If there is data, but pixel values cannot be
     *    returned, and empty array will be returned.
     */
    CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
        var renderPixel = Object(ol_transform["a" /* apply */])(this.inversePixelTransform, pixel.slice());
        var context = this.context;
        var layer = this.getLayer();
        var layerExtent = layer.getExtent();
        if (layerExtent) {
            var renderCoordinate = Object(ol_transform["a" /* apply */])(frameState.pixelToCoordinateTransform, pixel.slice());
            /** get only data inside of the layer extent */
            if (!Object(ol_extent["f" /* containsCoordinate */])(layerExtent, renderCoordinate)) {
                return null;
            }
        }
        var x = Math.round(renderPixel[0]);
        var y = Math.round(renderPixel[1]);
        var pixelContext = this.pixelContext_;
        if (!pixelContext) {
            var pixelCanvas = document.createElement('canvas');
            pixelCanvas.width = 1;
            pixelCanvas.height = 1;
            pixelContext = pixelCanvas.getContext('2d');
            this.pixelContext_ = pixelContext;
        }
        pixelContext.clearRect(0, 0, 1, 1);
        var data;
        try {
            pixelContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
            data = pixelContext.getImageData(0, 0, 1, 1).data;
        }
        catch (err) {
            if (err.name === 'SecurityError') {
                // tainted canvas, we assume there is data at the given pixel (although there might not be)
                this.pixelContext_ = null;
                return new Uint8Array();
            }
            return data;
        }
        if (data[3] === 0) {
            return null;
        }
        return data;
    };
    /**
     * Clean up.
     */
    CanvasLayerRenderer.prototype.disposeInternal = function () {
        delete this.frameState;
        _super.prototype.disposeInternal.call(this);
    };
    return CanvasLayerRenderer;
}(Layer));
/* harmony default export */ var canvas_Layer = __webpack_exports__["a"] = (Layer_CanvasLayerRenderer);
//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "13b4":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "13ca":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "14c3":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var isCallable = __webpack_require__("1626");
var classof = __webpack_require__("c6b6");
var regexpExec = __webpack_require__("9263");

var TypeError = global.TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ "159b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var DOMTokenListPrototype = __webpack_require__("785a");
var forEach = __webpack_require__("17c2");
var createNonEnumerableProperty = __webpack_require__("9112");

var handlePrototype = function (CollectionPrototype) {
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);
  }
}

handlePrototype(DOMTokenListPrototype);


/***/ }),

/***/ "1626":
/***/ (function(module, exports) {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "17c2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__("b727").forEach;
var arrayMethodIsStrict = __webpack_require__("a640");

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ "17f2":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "182f":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "183a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/CollectionEventType
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Triggered when an item is added to the collection.
     * @event module:ol/Collection.CollectionEvent#add
     * @api
     */
    ADD: 'add',
    /**
     * Triggered when an item is removed from the collection.
     * @event module:ol/Collection.CollectionEvent#remove
     * @api
     */
    REMOVE: 'remove',
});
//# sourceMappingURL=CollectionEventType.js.map

/***/ }),

/***/ "183c":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "19aa":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isPrototypeOf = __webpack_require__("3a9b");

var TypeError = global.TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw TypeError('Incorrect invocation');
};


/***/ }),

/***/ "1a2d":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toObject = __webpack_require__("7b0b");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "1af9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return inView; });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5564");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("df4c");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("070d");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("6d83");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("92fa");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("38f3");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("1e8d");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/Layer
 */








/**
 * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:source'|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */
/**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {import("../source/Source.js").default|undefined} source Source being rendered (only for multi-source layers).
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */
/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link import("../PluggableMap.js").default#addLayer map.addLayer()}. Components
 * like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * Please note that for performance reasons several layers might get rendered to
 * the same HTML element, which will cause {@link import("../PluggableMap.js").default#forEachLayerAtPixel map.forEachLayerAtPixel()} to
 * give false positives. To avoid this, apply different `className` properties to the
 * layers at creation time.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */
var Layer = /** @class */ (function (_super) {
    __extends(Layer, _super);
    /**
     * @param {Options<SourceType>} options Layer options.
     */
    function Layer(options) {
        var _this = this;
        var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__[/* assign */ "a"])({}, options);
        delete baseOptions.source;
        _this = _super.call(this, baseOptions) || this;
        /***
         * @type {LayerOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {LayerOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {LayerOnSignature<void>}
         */
        _this.un;
        /**
         * @private
         * @type {?import("../events.js").EventsKey}
         */
        _this.mapPrecomposeKey_ = null;
        /**
         * @private
         * @type {?import("../events.js").EventsKey}
         */
        _this.mapRenderKey_ = null;
        /**
         * @private
         * @type {?import("../events.js").EventsKey}
         */
        _this.sourceChangeKey_ = null;
        /**
         * @private
         * @type {RendererType}
         */
        _this.renderer_ = null;
        /**
         * @protected
         * @type {boolean}
         */
        _this.rendered = false;
        // Overwrite default render method with a custom one
        if (options.render) {
            _this.render = options.render;
        }
        if (options.map) {
            _this.setMap(options.map);
        }
        _this.addChangeListener(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].SOURCE, _this.handleSourcePropertyChange_);
        var source = options.source
            ? /** @type {SourceType} */ (options.source)
            : null;
        _this.setSource(source);
        return _this;
    }
    /**
     * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    Layer.prototype.getLayersArray = function (opt_array) {
        var array = opt_array ? opt_array : [];
        array.push(this);
        return array;
    };
    /**
     * @param {Array<import("./Layer.js").State>} [opt_states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    Layer.prototype.getLayerStatesArray = function (opt_states) {
        var states = opt_states ? opt_states : [];
        states.push(this.getLayerState());
        return states;
    };
    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */
    Layer.prototype.getSource = function () {
        return /** @type {SourceType} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].SOURCE)) || null;
    };
    /**
     * @return {SourceType|null} The source being rendered.
     */
    Layer.prototype.getRenderSource = function () {
        return this.getSource();
    };
    /**
     * @return {import("../source/State.js").default} Source state.
     */
    Layer.prototype.getSourceState = function () {
        var source = this.getSource();
        return !source ? _source_State_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].UNDEFINED : source.getState();
    };
    /**
     * @private
     */
    Layer.prototype.handleSourceChange_ = function () {
        this.changed();
    };
    /**
     * @private
     */
    Layer.prototype.handleSourcePropertyChange_ = function () {
        if (this.sourceChangeKey_) {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_7__[/* unlistenByKey */ "c"])(this.sourceChangeKey_);
            this.sourceChangeKey_ = null;
        }
        var source = this.getSource();
        if (source) {
            this.sourceChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_7__[/* listen */ "a"])(source, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE, this.handleSourceChange_, this);
        }
        this.changed();
    };
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
     * an array of features.
     */
    Layer.prototype.getFeatures = function (pixel) {
        if (!this.renderer_) {
            return new Promise(function (resolve) { return resolve([]); });
        }
        return this.renderer_.getFeatures(pixel);
    };
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    Layer.prototype.getData = function (pixel) {
        if (!this.renderer_ || !this.rendered) {
            return null;
        }
        return this.renderer_.getData(pixel);
    };
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement} The rendered element.
     */
    Layer.prototype.render = function (frameState, target) {
        var layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
            this.rendered = true;
            return layerRenderer.renderFrame(frameState, target);
        }
    };
    /**
     * Called when a layer is not visible during a map render.
     */
    Layer.prototype.unrender = function () {
        this.rendered = false;
    };
    /**
     * For use inside the library only.
     * @param {import("../PluggableMap.js").default|null} map Map.
     */
    Layer.prototype.setMapInternal = function (map) {
        if (!map) {
            this.unrender();
        }
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MAP, map);
    };
    /**
     * For use inside the library only.
     * @return {import("../PluggableMap.js").default|null} Map.
     */
    Layer.prototype.getMapInternal = function () {
        return this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MAP);
    };
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection, and the callback in
     * {@link module:ol/Map~Map#forEachLayerAtPixel} will receive `null` as layer. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../PluggableMap.js").default|null} map Map.
     * @api
     */
    Layer.prototype.setMap = function (map) {
        if (this.mapPrecomposeKey_) {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_7__[/* unlistenByKey */ "c"])(this.mapPrecomposeKey_);
            this.mapPrecomposeKey_ = null;
        }
        if (!map) {
            this.changed();
        }
        if (this.mapRenderKey_) {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_7__[/* unlistenByKey */ "c"])(this.mapRenderKey_);
            this.mapRenderKey_ = null;
        }
        if (map) {
            this.mapPrecomposeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_7__[/* listen */ "a"])(map, _render_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].PRECOMPOSE, function (evt) {
                var renderEvent = 
                /** @type {import("../render/Event.js").default} */ (evt);
                var layerStatesArray = renderEvent.frameState.layerStatesArray;
                var layerState = this.getLayerState(false);
                // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.
                Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__[/* assert */ "a"])(!layerStatesArray.some(function (arrayLayerState) {
                    return arrayLayerState.layer === layerState.layer;
                }), 67);
                layerStatesArray.push(layerState);
            }, this);
            this.mapRenderKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_7__[/* listen */ "a"])(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE, map.render, map);
            this.changed();
        }
    };
    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */
    Layer.prototype.setSource = function (source) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].SOURCE, source);
    };
    /**
     * Get the renderer for this layer.
     * @return {RendererType} The layer renderer.
     */
    Layer.prototype.getRenderer = function () {
        if (!this.renderer_) {
            this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
    };
    /**
     * @return {boolean} The layer has a renderer.
     */
    Layer.prototype.hasRenderer = function () {
        return !!this.renderer_;
    };
    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */
    Layer.prototype.createRenderer = function () {
        return null;
    };
    /**
     * Clean up.
     */
    Layer.prototype.disposeInternal = function () {
        if (this.renderer_) {
            this.renderer_.dispose();
            delete this.renderer_;
        }
        this.setSource(null);
        _super.prototype.disposeInternal.call(this);
    };
    return Layer;
}(_Base_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */
function inView(layerState, viewState) {
    if (!layerState.visible) {
        return false;
    }
    var resolution = viewState.resolution;
    if (resolution < layerState.minResolution ||
        resolution >= layerState.maxResolution) {
        return false;
    }
    var zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
/* harmony default export */ __webpack_exports__["a"] = (Layer);
//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "1b14":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "1b84":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAL1SURBVEhL7VbJS9tREPZY6P/QHgSJR1Fs40EQRYJe01JKwZNQPfUgCEJFcYlUo8QdFyIuQSk5WIKgoBGtoqiooYlbLLggajBtULOafJ0Zfr30UArJgx78YHgvzLz3ZWbezPzSHvFfIpFIPB0fH3/e0tLy7E9xOBzPATzRTFOLmZkZ49zcXHhlZSW4s7MT3NzcDG5sbASXl5eDRBxeWlp6oZmmFsPDw8a7uztyDDg6OoLf70c4HJbfx8fHsFgsLzXT1GJ0dPTN5eVl4ODgwJmVlRUpKyuLlpeXu+Lx+FciTvT396vxmPL79vT01D87O/uRiH8ajcYfGRkZXrfb/Y6Io0NDQ3rNNLUYGxt7fX5+nqDcfi4uLv5OxL6CggLPycnJzNnZGZR5bLPZDD6fD/S644FAIHZ9ff1AeQ5xjr1eL6xWq04zTQ3oJb8fHBy0Uiida2trIK9BucbV1ZUIhR9OpxMDAwMOeoDWxcXFV9rR5NDZ2fklFAqBxeVygcPKZPwHfq8ejwexWAw3Nzdoa2uzaEeTQ1dXl+3h4UHKhjEyMiLS29srK0UC0WhUdJQCtLa2mrSjyYGJI5GIXMyhzc7ORm1tLXQ6nay5ubnY29sTPde2MuK8vDwOp6xmsxn5+fkSaoYy4vv7e9TU1PDlQmwymVBdXQ164aJXRswts6enRzzV6/Vobm4G6SUSDGXENBRQX1+Puro65OTkiPe8pxISvTLii4sLbG1tgaYT9vf3sbu7K3vqXqJXmmMmo1EoL3lhYQHcVLiGGcqIefwZDAY0NTWhpKQEfX19KCwsxPz8vOiVEW9vbwthZWUlKioqQF0NpaWlWF1dFb3SUGdmZqKoqAjd3d2gCYWqqiocHh6KXhkxDQykp6dLGXG4aS7Lnr9IGMqIb29vhWhiYoLHoJRUQ0ODDA+GMmLG+vo67HY7Ojo60NjYKO1TSY7b29vtcus/gDsbtVGzdjQ5kHefpqam3JOTk9/+JmTD4p6env6gHX2EhrS0X67xiKX6F/i4AAAAAElFTkSuQmCC"

/***/ }),

/***/ "1be4":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "1c32":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "1c48":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export simplifyLineString */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return douglasPeucker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return douglasPeuckerArray; });
/* unused harmony export douglasPeuckerMultiArray */
/* unused harmony export radialDistance */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return snap; });
/* unused harmony export quantize */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return quantizeArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return quantizeMultiArray; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7fc9");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [opt_simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
    var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined
        ? opt_simplifiedFlatCoordinates
        : [];
    if (!highQuality) {
        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        flatCoordinates = simplifiedFlatCoordinates;
        offset = 0;
        stride = 2;
    }
    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return simplifiedFlatCoordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    var n = (end - offset) / stride;
    if (n < 3) {
        for (; offset < end; offset += stride) {
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] =
                flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    /** @type {Array<number>} */
    var markers = new Array(n);
    markers[0] = 1;
    markers[n - 1] = 1;
    /** @type {Array<number>} */
    var stack = [offset, end - stride];
    var index = 0;
    while (stack.length > 0) {
        var last = stack.pop();
        var first = stack.pop();
        var maxSquaredDistance = 0;
        var x1 = flatCoordinates[first];
        var y1 = flatCoordinates[first + 1];
        var x2 = flatCoordinates[last];
        var y2 = flatCoordinates[last + 1];
        for (var i = first + stride; i < last; i += stride) {
            var x = flatCoordinates[i];
            var y = flatCoordinates[i + 1];
            var squaredDistance_1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredSegmentDistance */ "j"])(x, y, x1, y1, x2, y2);
            if (squaredDistance_1 > maxSquaredDistance) {
                index = i;
                maxSquaredDistance = squaredDistance_1;
            }
        }
        if (maxSquaredDistance > squaredTolerance) {
            markers[(index - offset) / stride] = 1;
            if (first + stride < index) {
                stack.push(first, index);
            }
            if (index + stride < last) {
                stack.push(index, last);
            }
        }
    }
    for (var i = 0; i < n; ++i) {
        if (markers[i]) {
            simplifiedFlatCoordinates[simplifiedOffset++] =
                flatCoordinates[offset + i * stride];
            simplifiedFlatCoordinates[simplifiedOffset++] =
                flatCoordinates[offset + i * stride + 1];
        }
    }
    return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        var simplifiedEnds = [];
        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (end <= offset + stride) {
        // zero or one point, no simplification possible, so copy and return
        for (; offset < end; offset += stride) {
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] =
                flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    // copy first point
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    var x2 = x1;
    var y2 = y1;
    for (offset += stride; offset < end; offset += stride) {
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        if (Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "i"])(x1, y1, x2, y2) > squaredTolerance) {
            // copy point at offset
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            x1 = x2;
            y1 = y2;
        }
    }
    if (x2 != x1 || y2 != y1) {
        // copy last point
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    }
    return simplifiedOffset;
}
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
}
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    // do nothing if the line is empty
    if (offset == end) {
        return simplifiedOffset;
    }
    // snap the first coordinate (P1)
    var x1 = snap(flatCoordinates[offset], tolerance);
    var y1 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // add the first coordinate to the output
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    // find the next coordinate that does not snap to the same value as the first
    // coordinate (P2)
    var x2, y2;
    do {
        x2 = snap(flatCoordinates[offset], tolerance);
        y2 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        if (offset == end) {
            // all coordinates snap to the same value, the line collapses to a point
            // push the last snapped value anyway to ensure that the output contains
            // at least two points
            // FIXME should we really return at least two points anyway?
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            return simplifiedOffset;
        }
    } while (x2 == x1 && y2 == y1);
    while (offset < end) {
        // snap the next coordinate (P3)
        var x3 = snap(flatCoordinates[offset], tolerance);
        var y3 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        // skip P3 if it is equal to P2
        if (x3 == x2 && y3 == y2) {
            continue;
        }
        // calculate the delta between P1 and P2
        var dx1 = x2 - x1;
        var dy1 = y2 - y1;
        // calculate the delta between P3 and P1
        var dx2 = x3 - x1;
        var dy2 = y3 - y1;
        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
        // P1 in the same direction then P2 is on the straight line between P1 and
        // P3
        if (dx1 * dy2 == dy1 * dx2 &&
            ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
            ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
            // discard P2 and set P2 = P3
            x2 = x3;
            y2 = y3;
            continue;
        }
        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
        // between P3 and P1 or on the opposite half of the line to P2.  add P2,
        // and continue with P1 = P2 and P2 = P3
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        x1 = x2;
        y1 = y2;
        x2 = x3;
        y2 = y3;
    }
    // add the last point (P2)
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        var simplifiedEnds = [];
        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}
//# sourceMappingURL=simplify.js.map

/***/ }),

/***/ "1c7e":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "1cdc":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "1d61":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "1d80":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

var TypeError = global.TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "1dde":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "1e8d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return listenOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return unlistenByKey; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("38f3");
/**
 * @module ol/events
 */

/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */
/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */
/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */
/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */
/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [opt_once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
    if (opt_this && opt_this !== target) {
        listener = listener.bind(opt_this);
    }
    if (opt_once) {
        var originalListener_1 = listener;
        listener = function () {
            target.removeEventListener(type, listener);
            originalListener_1.apply(this, arguments);
        };
    }
    var eventsKey = {
        target: target,
        type: type,
        listener: listener,
    };
    target.addEventListener(type, listener);
    return eventsKey;
}
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
    return listen(target, type, listener, opt_this, true);
}
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
    if (key && key.target) {
        key.target.removeEventListener(key.type, key.listener);
        Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__[/* clear */ "b"])(key);
    }
}
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "1ecb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/format/FormatType
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    ARRAY_BUFFER: 'arraybuffer',
    JSON: 'json',
    TEXT: 'text',
    XML: 'xml',
});
//# sourceMappingURL=FormatType.js.map

/***/ }),

/***/ "2144":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "21bc":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ defaults; });

// UNUSED EXPORTS: Attribution, Control, FullScreen, MousePosition, OverviewMap, Rotate, ScaleLine, Zoom, ZoomSlider, ZoomToExtent

// EXTERNAL MODULE: ./node_modules/ol/control/Control.js
var Control = __webpack_require__("3900");

// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js
var EventType = __webpack_require__("01d4");

// EXTERNAL MODULE: ./node_modules/ol/css.js
var css = __webpack_require__("cd7e");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js
var Layer = __webpack_require__("1af9");

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__("0999");

// CONCATENATED MODULE: ./node_modules/ol/control/Attribution.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/control/Attribution
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */
/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
var Attribution_Attribution = /** @class */ (function (_super) {
    __extends(Attribution, _super);
    /**
     * @param {Options} [opt_options] Attribution options.
     */
    function Attribution(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this, {
            element: document.createElement('div'),
            render: options.render,
            target: options.target,
        }) || this;
        /**
         * @private
         * @type {HTMLElement}
         */
        _this.ulElement_ = document.createElement('ul');
        /**
         * @private
         * @type {boolean}
         */
        _this.collapsed_ =
            options.collapsed !== undefined ? options.collapsed : true;
        /**
         * @private
         * @type {boolean}
         */
        _this.userCollapsed_ = _this.collapsed_;
        /**
         * @private
         * @type {boolean}
         */
        _this.overrideCollapsible_ = options.collapsible !== undefined;
        /**
         * @private
         * @type {boolean}
         */
        _this.collapsible_ =
            options.collapsible !== undefined ? options.collapsible : true;
        if (!_this.collapsible_) {
            _this.collapsed_ = false;
        }
        var className = options.className !== undefined ? options.className : 'ol-attribution';
        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
        var expandClassName = options.expandClassName !== undefined
            ? options.expandClassName
            : className + '-expand';
        var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u203A';
        var collapseClassName = options.collapseClassName !== undefined
            ? options.collapseClassName
            : className + '-collapse';
        if (typeof collapseLabel === 'string') {
            /**
             * @private
             * @type {HTMLElement}
             */
            _this.collapseLabel_ = document.createElement('span');
            _this.collapseLabel_.textContent = collapseLabel;
            _this.collapseLabel_.className = collapseClassName;
        }
        else {
            _this.collapseLabel_ = collapseLabel;
        }
        var label = options.label !== undefined ? options.label : 'i';
        if (typeof label === 'string') {
            /**
             * @private
             * @type {HTMLElement}
             */
            _this.label_ = document.createElement('span');
            _this.label_.textContent = label;
            _this.label_.className = expandClassName;
        }
        else {
            _this.label_ = label;
        }
        var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
        /**
         * @private
         * @type {HTMLElement}
         */
        _this.toggleButton_ = document.createElement('button');
        _this.toggleButton_.setAttribute('type', 'button');
        _this.toggleButton_.setAttribute('aria-expanded', String(!_this.collapsed_));
        _this.toggleButton_.title = tipLabel;
        _this.toggleButton_.appendChild(activeLabel);
        _this.toggleButton_.addEventListener(EventType["a" /* default */].CLICK, _this.handleClick_.bind(_this), false);
        var cssClasses = className +
            ' ' +
            css["e" /* CLASS_UNSELECTABLE */] +
            ' ' +
            css["b" /* CLASS_CONTROL */] +
            (_this.collapsed_ && _this.collapsible_ ? ' ' + css["a" /* CLASS_COLLAPSED */] : '') +
            (_this.collapsible_ ? '' : ' ol-uncollapsible');
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(_this.toggleButton_);
        element.appendChild(_this.ulElement_);
        /**
         * A list of currently rendered resolutions.
         * @type {Array<string>}
         * @private
         */
        _this.renderedAttributions_ = [];
        /**
         * @private
         * @type {boolean}
         */
        _this.renderedVisible_ = true;
        return _this;
    }
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */
    Attribution.prototype.collectSourceAttributions_ = function (frameState) {
        /**
         * Used to determine if an attribution already exists.
         * @type {!Object<string, boolean>}
         */
        var lookup = {};
        /**
         * A list of visible attributions.
         * @type {Array<string>}
         */
        var visibleAttributions = [];
        var collapsible = true;
        var layerStatesArray = frameState.layerStatesArray;
        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
            var layerState = layerStatesArray[i];
            if (!Object(Layer["b" /* inView */])(layerState, frameState.viewState)) {
                continue;
            }
            var source = /** @type {import("../layer/Layer.js").default} */ (layerState.layer).getSource();
            if (!source) {
                continue;
            }
            var attributionGetter = source.getAttributions();
            if (!attributionGetter) {
                continue;
            }
            var attributions = attributionGetter(frameState);
            if (!attributions) {
                continue;
            }
            collapsible =
                collapsible && source.getAttributionsCollapsible() !== false;
            if (Array.isArray(attributions)) {
                for (var j = 0, jj = attributions.length; j < jj; ++j) {
                    if (!(attributions[j] in lookup)) {
                        visibleAttributions.push(attributions[j]);
                        lookup[attributions[j]] = true;
                    }
                }
            }
            else {
                if (!(attributions in lookup)) {
                    visibleAttributions.push(attributions);
                    lookup[attributions] = true;
                }
            }
        }
        if (!this.overrideCollapsible_) {
            this.setCollapsible(collapsible);
        }
        return visibleAttributions;
    };
    /**
     * @private
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     */
    Attribution.prototype.updateElement_ = function (frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        var attributions = this.collectSourceAttributions_(frameState);
        var visible = attributions.length > 0;
        if (this.renderedVisible_ != visible) {
            this.element.style.display = visible ? '' : 'none';
            this.renderedVisible_ = visible;
        }
        if (Object(array["b" /* equals */])(attributions, this.renderedAttributions_)) {
            return;
        }
        Object(dom["d" /* removeChildren */])(this.ulElement_);
        // append the attributions
        for (var i = 0, ii = attributions.length; i < ii; ++i) {
            var element = document.createElement('li');
            element.innerHTML = attributions[i];
            this.ulElement_.appendChild(element);
        }
        this.renderedAttributions_ = attributions;
    };
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    Attribution.prototype.handleClick_ = function (event) {
        event.preventDefault();
        this.handleToggle_();
        this.userCollapsed_ = this.collapsed_;
    };
    /**
     * @private
     */
    Attribution.prototype.handleToggle_ = function () {
        this.element.classList.toggle(css["a" /* CLASS_COLLAPSED */]);
        if (this.collapsed_) {
            Object(dom["g" /* replaceNode */])(this.collapseLabel_, this.label_);
        }
        else {
            Object(dom["g" /* replaceNode */])(this.label_, this.collapseLabel_);
        }
        this.collapsed_ = !this.collapsed_;
        this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    };
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
    Attribution.prototype.getCollapsible = function () {
        return this.collapsible_;
    };
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
    Attribution.prototype.setCollapsible = function (collapsible) {
        if (this.collapsible_ === collapsible) {
            return;
        }
        this.collapsible_ = collapsible;
        this.element.classList.toggle('ol-uncollapsible');
        if (this.userCollapsed_) {
            this.handleToggle_();
        }
    };
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
    Attribution.prototype.setCollapsed = function (collapsed) {
        this.userCollapsed_ = collapsed;
        if (!this.collapsible_ || this.collapsed_ === collapsed) {
            return;
        }
        this.handleToggle_();
    };
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */
    Attribution.prototype.getCollapsed = function () {
        return this.collapsed_;
    };
    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    Attribution.prototype.render = function (mapEvent) {
        this.updateElement_(mapEvent.frameState);
    };
    return Attribution;
}(Control["a" /* default */]));
/* harmony default export */ var control_Attribution = (Attribution_Attribution);
//# sourceMappingURL=Attribution.js.map
// EXTERNAL MODULE: ./node_modules/ol/Collection.js
var Collection = __webpack_require__("e300");

// EXTERNAL MODULE: ./node_modules/ol/easing.js
var easing = __webpack_require__("ca42");

// CONCATENATED MODULE: ./node_modules/ol/control/Rotate.js
var Rotate_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/control/Rotate
 */




/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
var Rotate_Rotate = /** @class */ (function (_super) {
    Rotate_extends(Rotate, _super);
    /**
     * @param {Options} [opt_options] Rotate options.
     */
    function Rotate(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this, {
            element: document.createElement('div'),
            render: options.render,
            target: options.target,
        }) || this;
        var className = options.className !== undefined ? options.className : 'ol-rotate';
        var label = options.label !== undefined ? options.label : '\u21E7';
        var compassClassName = options.compassClassName !== undefined
            ? options.compassClassName
            : 'ol-compass';
        /**
         * @type {HTMLElement}
         * @private
         */
        _this.label_ = null;
        if (typeof label === 'string') {
            _this.label_ = document.createElement('span');
            _this.label_.className = compassClassName;
            _this.label_.textContent = label;
        }
        else {
            _this.label_ = label;
            _this.label_.classList.add(compassClassName);
        }
        var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
        var button = document.createElement('button');
        button.className = className + '-reset';
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(_this.label_);
        button.addEventListener(EventType["a" /* default */].CLICK, _this.handleClick_.bind(_this), false);
        var cssClasses = className + ' ' + css["e" /* CLASS_UNSELECTABLE */] + ' ' + css["b" /* CLASS_CONTROL */];
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(button);
        _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
        /**
         * @type {number}
         * @private
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
         * @type {boolean}
         * @private
         */
        _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.rotation_ = undefined;
        if (_this.autoHide_) {
            _this.element.classList.add(css["c" /* CLASS_HIDDEN */]);
        }
        return _this;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    Rotate.prototype.handleClick_ = function (event) {
        event.preventDefault();
        if (this.callResetNorth_ !== undefined) {
            this.callResetNorth_();
        }
        else {
            this.resetNorth_();
        }
    };
    /**
     * @private
     */
    Rotate.prototype.resetNorth_ = function () {
        var map = this.getMap();
        var view = map.getView();
        if (!view) {
            // the map does not have a view, so we can't act
            // upon it
            return;
        }
        var rotation = view.getRotation();
        if (rotation !== undefined) {
            if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                view.animate({
                    rotation: 0,
                    duration: this.duration_,
                    easing: easing["b" /* easeOut */],
                });
            }
            else {
                view.setRotation(0);
            }
        }
    };
    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    Rotate.prototype.render = function (mapEvent) {
        var frameState = mapEvent.frameState;
        if (!frameState) {
            return;
        }
        var rotation = frameState.viewState.rotation;
        if (rotation != this.rotation_) {
            var transform = 'rotate(' + rotation + 'rad)';
            if (this.autoHide_) {
                var contains = this.element.classList.contains(css["c" /* CLASS_HIDDEN */]);
                if (!contains && rotation === 0) {
                    this.element.classList.add(css["c" /* CLASS_HIDDEN */]);
                }
                else if (contains && rotation !== 0) {
                    this.element.classList.remove(css["c" /* CLASS_HIDDEN */]);
                }
            }
            this.label_.style.transform = transform;
        }
        this.rotation_ = rotation;
    };
    return Rotate;
}(Control["a" /* default */]));
/* harmony default export */ var control_Rotate = (Rotate_Rotate);
//# sourceMappingURL=Rotate.js.map
// CONCATENATED MODULE: ./node_modules/ol/control/Zoom.js
var Zoom_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/control/Zoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
var Zoom_Zoom = /** @class */ (function (_super) {
    Zoom_extends(Zoom, _super);
    /**
     * @param {Options} [opt_options] Zoom options.
     */
    function Zoom(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this, {
            element: document.createElement('div'),
            target: options.target,
        }) || this;
        var className = options.className !== undefined ? options.className : 'ol-zoom';
        var delta = options.delta !== undefined ? options.delta : 1;
        var zoomInClassName = options.zoomInClassName !== undefined
            ? options.zoomInClassName
            : className + '-in';
        var zoomOutClassName = options.zoomOutClassName !== undefined
            ? options.zoomOutClassName
            : className + '-out';
        var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
        var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2013';
        var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
        var zoomOutTipLabel = options.zoomOutTipLabel !== undefined
            ? options.zoomOutTipLabel
            : 'Zoom out';
        var inElement = document.createElement('button');
        inElement.className = zoomInClassName;
        inElement.setAttribute('type', 'button');
        inElement.title = zoomInTipLabel;
        inElement.appendChild(typeof zoomInLabel === 'string'
            ? document.createTextNode(zoomInLabel)
            : zoomInLabel);
        inElement.addEventListener(EventType["a" /* default */].CLICK, _this.handleClick_.bind(_this, delta), false);
        var outElement = document.createElement('button');
        outElement.className = zoomOutClassName;
        outElement.setAttribute('type', 'button');
        outElement.title = zoomOutTipLabel;
        outElement.appendChild(typeof zoomOutLabel === 'string'
            ? document.createTextNode(zoomOutLabel)
            : zoomOutLabel);
        outElement.addEventListener(EventType["a" /* default */].CLICK, _this.handleClick_.bind(_this, -delta), false);
        var cssClasses = className + ' ' + css["e" /* CLASS_UNSELECTABLE */] + ' ' + css["b" /* CLASS_CONTROL */];
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(inElement);
        element.appendChild(outElement);
        /**
         * @type {number}
         * @private
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */
    Zoom.prototype.handleClick_ = function (delta, event) {
        event.preventDefault();
        this.zoomByDelta_(delta);
    };
    /**
     * @param {number} delta Zoom delta.
     * @private
     */
    Zoom.prototype.zoomByDelta_ = function (delta) {
        var map = this.getMap();
        var view = map.getView();
        if (!view) {
            // the map does not have a view, so we can't act
            // upon it
            return;
        }
        var currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            var newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (this.duration_ > 0) {
                if (view.getAnimating()) {
                    view.cancelAnimations();
                }
                view.animate({
                    zoom: newZoom,
                    duration: this.duration_,
                    easing: easing["b" /* easeOut */],
                });
            }
            else {
                view.setZoom(newZoom);
            }
        }
    };
    return Zoom;
}(Control["a" /* default */]));
/* harmony default export */ var control_Zoom = (Zoom_Zoom);
//# sourceMappingURL=Zoom.js.map
// CONCATENATED MODULE: ./node_modules/ol/control.js
/**
 * @module ol/control
 */














/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./control/Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 * @api
 */
/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [opt_options]
 * Defaults options.
 * @return {Collection<import("./control/Control.js").default>}
 * Controls.
 * @api
 */
function defaults(opt_options) {
    var options = opt_options ? opt_options : {};
    var controls = new Collection["a" /* default */]();
    var zoomControl = options.zoom !== undefined ? options.zoom : true;
    if (zoomControl) {
        controls.push(new control_Zoom(options.zoomOptions));
    }
    var rotateControl = options.rotate !== undefined ? options.rotate : true;
    if (rotateControl) {
        controls.push(new control_Rotate(options.rotateOptions));
    }
    var attributionControl = options.attribution !== undefined ? options.attribution : true;
    if (attributionControl) {
        controls.push(new control_Attribution(options.attributionOptions));
    }
    return controls;
}
//# sourceMappingURL=control.js.map

/***/ }),

/***/ "2240":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "2266":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var bind = __webpack_require__("0366");
var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var tryToString = __webpack_require__("0d51");
var isArrayIteratorMethod = __webpack_require__("e95a");
var lengthOfArrayLike = __webpack_require__("07fa");
var isPrototypeOf = __webpack_require__("3a9b");
var getIterator = __webpack_require__("9a1f");
var getIteratorMethod = __webpack_require__("35a1");
var iteratorClose = __webpack_require__("2a62");

var TypeError = global.TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ "238b":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4tJREFUeNqsl01ME0EUxx/IhwUpTUNIFIzLgRjAkHrx4sHWs0bwwsUE8OLFRLh5kFCuXMB48CZw8MDBgIbEm0uiBzACDSAIMbaaVgNCuyyFAi2s84aZ7ex2W/rhP5nszuzs/ua9Nx9viyBHrUK7i1wcpmalCSZ8uXynKEuYm1w6SWmzgOpwUiZJGSODmC4IzKwbIsUttle4rxn6Hfr8cKzsiU0I7s3khaIM0C5yGeH16i4PVHfeJtAWy/4I3xmTYWdUFgfRTeCjWYMJFIFd3LqLI4+hVKrNKnYnBPqn+wXsTn7mTaME3n0mmEB7mHuhxtsBNf0d+rNwOAwrK6ugqiqt22w2aGxshPr6upQBoOU4ACZ0+3BaMJtEsgiNx+MQi8UgkUjAzMyspZWtra1gt1fRPjgYLBZwjzjpzOAFcnFVtd2Auomn1MK5uXkKz0WSJEFzcxO93+x9BeHhKbz1EfB13qfYNJlc5xyVUDv0kLb5/YGcoahAIADBYIjeo9fY/HAxhhHM1ilcINZiRwTyWOajUCh4CiCGOJ/cMTB0MBmJg69V3mlxcYnGNl+p6i5sbGzoS5HJzVi6xbhRALq53NVAG/hL+Qo9hoPnVp9n3+UsDqbWlicf6jOzUHhyt9M3Hrc5xgbh+ixUdrtdv0erRZWkewk3hYoKG2xvh/MGS9KVtM9KMr3odDppSafBhQjca6iEq46ynAfFXR2gMQlspgXsxk9S2t/5o9Dz8a9eX1OOaJuV9qe/gsjiYB8HW8Ffr6kGAFdVabFhQHIwBn2z2yCH9i3AyyCyKJidm3QkeLSlAMqKqTVmvb9bB5/uXxb6ne7Av/cSKQcGtzbljCYL20uK9l16pB1Hopoo9eiYFq5nM1uGuqhQNJ7S9tPdp+G3kWG1ZeKxpaCrw8+nUlyKBfVl84DGcXA+kgzFuqrH9lKlcb5GyAHB3KwwhhFMXIAPBvB+yzsO0eRBbhD/sBjbDyy25nBgVrI1MM6rA4yRNuWR0S3rjgfanrysZaOXS4p2880v7VvkUG87WPhBv8FcLGeTgThYMuCyykKyEboXLWW5l48lAUo2OZcBjsckwoVTxlIYHpwfpqXjsXLxWektzsJ+XuenlznTxFjiBmFKcTGm3rwTegKXGDxTMm9O6hEaKPhPQhhEG3P/LSHJR3e+ZTnV5H/9hUk3+5kHPBmXST6n0xlqR3A+UNQ/AQYApvMD4/KV44sAAAAASUVORK5CYII="

/***/ }),

/***/ "23cb":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "23e7":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var setGlobal = __webpack_require__("ce4e");
var copyConstructorProperties = __webpack_require__("e893");
var isForced = __webpack_require__("94ca");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "241c":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "256f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ Units["a" /* METERS_PER_UNIT */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ Projection["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ disableCoordinateWarning; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ addProjection; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* binding */ proj_get; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* binding */ getPointResolution; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ addEquivalentProjections; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ createProjection; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ addCoordinateTransforms; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ equivalent; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* binding */ getTransformFromProjections; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* binding */ getTransform; });
__webpack_require__.d(__webpack_exports__, "u", function() { return /* binding */ proj_transform; });
__webpack_require__.d(__webpack_exports__, "v", function() { return /* binding */ transformExtent; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* binding */ getUserProjection; });
__webpack_require__.d(__webpack_exports__, "r", function() { return /* binding */ toUserCoordinate; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ fromUserCoordinate; });
__webpack_require__.d(__webpack_exports__, "s", function() { return /* binding */ toUserExtent; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ fromUserExtent; });
__webpack_require__.d(__webpack_exports__, "t", function() { return /* binding */ toUserResolution; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ fromUserResolution; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ createSafeCoordinateTransform; });

// UNUSED EXPORTS: cloneTransform, identityTransform, addProjections, addEquivalentTransforms, clearAllProjections, createTransformFromCoordinateTransform, fromLonLat, toLonLat, transformWithProjections, setUserProjection, clearUserProjection, useGeographic, addCommon

// EXTERNAL MODULE: ./node_modules/ol/proj/Projection.js
var Projection = __webpack_require__("f5dd");

// EXTERNAL MODULE: ./node_modules/ol/proj/Units.js
var Units = __webpack_require__("fced");

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__("7fc9");

// CONCATENATED MODULE: ./node_modules/ol/proj/epsg3857.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/proj/epsg3857
 */



/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */
var HALF_SIZE = Math.PI * RADIUS;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
var epsg3857_EPSG3857Projection = /** @class */ (function (_super) {
    __extends(EPSG3857Projection, _super);
    /**
     * @param {string} code Code.
     */
    function EPSG3857Projection(code) {
        return _super.call(this, {
            code: code,
            units: Units["b" /* default */].METERS,
            extent: EXTENT,
            global: true,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function (resolution, point) {
                return resolution / Object(math["c" /* cosh */])(point[1] / RADIUS);
            },
        }) || this;
    }
    return EPSG3857Projection;
}(Projection["a" /* default */]));
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
    new epsg3857_EPSG3857Projection('EPSG:3857'),
    new epsg3857_EPSG3857Projection('EPSG:102100'),
    new epsg3857_EPSG3857Projection('EPSG:102113'),
    new epsg3857_EPSG3857Projection('EPSG:900913'),
    new epsg3857_EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
    new epsg3857_EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var output = opt_output;
    if (output === undefined) {
        if (dimension > 2) {
            // preserve values beyond second dimension
            output = input.slice();
        }
        else {
            output = new Array(length);
        }
    }
    for (var i = 0; i < length; i += dimension) {
        output[i] = (HALF_SIZE * input[i]) / 180;
        var y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
        if (y > MAX_SAFE_Y) {
            y = MAX_SAFE_Y;
        }
        else if (y < -MAX_SAFE_Y) {
            y = -MAX_SAFE_Y;
        }
        output[i + 1] = y;
    }
    return output;
}
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var output = opt_output;
    if (output === undefined) {
        if (dimension > 2) {
            // preserve values beyond second dimension
            output = input.slice();
        }
        else {
            output = new Array(length);
        }
    }
    for (var i = 0; i < length; i += dimension) {
        output[i] = (180 * input[i]) / HALF_SIZE;
        output[i + 1] =
            (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
    }
    return output;
}
//# sourceMappingURL=epsg3857.js.map
// CONCATENATED MODULE: ./node_modules/ol/proj/epsg4326.js
var epsg4326_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/proj/epsg4326
 */


/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var epsg4326_RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
var epsg4326_EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = (Math.PI * epsg4326_RADIUS) / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
var epsg4326_EPSG4326Projection = /** @class */ (function (_super) {
    epsg4326_extends(EPSG4326Projection, _super);
    /**
     * @param {string} code Code.
     * @param {string} [opt_axisOrientation] Axis orientation.
     */
    function EPSG4326Projection(code, opt_axisOrientation) {
        return _super.call(this, {
            code: code,
            units: Units["b" /* default */].DEGREES,
            extent: epsg4326_EXTENT,
            axisOrientation: opt_axisOrientation,
            global: true,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: epsg4326_EXTENT,
        }) || this;
    }
    return EPSG4326Projection;
}(Projection["a" /* default */]));
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var epsg4326_PROJECTIONS = [
    new epsg4326_EPSG4326Projection('CRS:84'),
    new epsg4326_EPSG4326Projection('EPSG:4326', 'neu'),
    new epsg4326_EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
    new epsg4326_EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
    new epsg4326_EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
    new epsg4326_EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
    new epsg4326_EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),
];
//# sourceMappingURL=epsg4326.js.map
// CONCATENATED MODULE: ./node_modules/ol/proj/projections.js
/**
 * @module ol/proj/projections
 */
/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};
/**
 * Clear the projections cache.
 */
function clear() {
    cache = {};
}
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
    return (cache[code] ||
        cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] ||
        null);
}
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
    cache[code] = projection;
}
//# sourceMappingURL=projections.js.map
// EXTERNAL MODULE: ./node_modules/ol/proj/transforms.js
var transforms = __webpack_require__("c15b");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/coordinate.js
var ol_coordinate = __webpack_require__("a568");

// EXTERNAL MODULE: ./node_modules/ol/sphere.js
var sphere = __webpack_require__("790a");

// CONCATENATED MODULE: ./node_modules/ol/proj.js
/**
 * @module ol/proj
 */
/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */










/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */
/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */


var showCoordinateWarning = true;
/**
 * @param {boolean} [opt_disable = true] Disable console info about `useGeographic()`
 */
function disableCoordinateWarning(opt_disable) {
    var hide = opt_disable === undefined ? true : opt_disable;
    showCoordinateWarning = !hide;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
    var output;
    if (opt_output !== undefined) {
        for (var i = 0, ii = input.length; i < ii; ++i) {
            opt_output[i] = input[i];
        }
        output = opt_output;
    }
    else {
        output = input.slice();
    }
    return output;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
    if (opt_output !== undefined && input !== opt_output) {
        for (var i = 0, ii = input.length; i < ii; ++i) {
            opt_output[i] = input[i];
        }
        input = opt_output;
    }
    return input;
}
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
    add(projection.getCode(), projection);
    Object(transforms["a" /* add */])(projection, projection, cloneTransform);
}
/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
    projections.forEach(addProjection);
}
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */
function proj_get(projectionLike) {
    return typeof projectionLike === 'string'
        ? get(/** @type {string} */ (projectionLike))
        : /** @type {Projection} */ (projectionLike) || null;
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").default} [opt_units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
    projection = proj_get(projection);
    var pointResolution;
    var getter = projection.getPointResolutionFunc();
    if (getter) {
        pointResolution = getter(resolution, point);
        if (opt_units && opt_units !== projection.getUnits()) {
            var metersPerUnit = projection.getMetersPerUnit();
            if (metersPerUnit) {
                pointResolution =
                    (pointResolution * metersPerUnit) / Units["a" /* METERS_PER_UNIT */][opt_units];
            }
        }
    }
    else {
        var units = projection.getUnits();
        if ((units == Units["b" /* default */].DEGREES && !opt_units) || opt_units == Units["b" /* default */].DEGREES) {
            pointResolution = resolution;
        }
        else {
            // Estimate point resolution by transforming the center pixel to EPSG:4326,
            // measuring its width and height on the normal sphere, and taking the
            // average of the width and height.
            var toEPSG4326_1 = getTransformFromProjections(projection, proj_get('EPSG:4326'));
            if (toEPSG4326_1 === identityTransform && units !== Units["b" /* default */].DEGREES) {
                // no transform is available
                pointResolution = resolution * projection.getMetersPerUnit();
            }
            else {
                var vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2,
                ];
                vertices = toEPSG4326_1(vertices, vertices, 2);
                var width = Object(sphere["a" /* getDistance */])(vertices.slice(0, 2), vertices.slice(2, 4));
                var height = Object(sphere["a" /* getDistance */])(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
            }
            var metersPerUnit = opt_units
                ? Units["a" /* METERS_PER_UNIT */][opt_units]
                : projection.getMetersPerUnit();
            if (metersPerUnit !== undefined) {
                pointResolution /= metersPerUnit;
            }
        }
    }
    return pointResolution;
}
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function (source) {
        projections.forEach(function (destination) {
            if (source !== destination) {
                Object(transforms["a" /* add */])(source, destination, cloneTransform);
            }
        });
    });
}
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function (projection1) {
        projections2.forEach(function (projection2) {
            Object(transforms["a" /* add */])(projection1, projection2, forwardTransform);
            Object(transforms["a" /* add */])(projection2, projection1, inverseTransform);
        });
    });
}
/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
    clear();
    Object(transforms["b" /* clear */])();
}
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
    if (!projection) {
        return proj_get(defaultCode);
    }
    else if (typeof projection === 'string') {
        return proj_get(projection);
    }
    else {
        return /** @type {Projection} */ (projection);
    }
}
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
    return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [opt_output] Output.
     * @param {number} [opt_dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
        var length = input.length;
        var dimension = opt_dimension !== undefined ? opt_dimension : 2;
        var output = opt_output !== undefined ? opt_output : new Array(length);
        for (var i = 0; i < length; i += dimension) {
            var point = coordTransform([input[i], input[i + 1]]);
            output[i] = point[0];
            output[i + 1] = point[1];
            for (var j = dimension - 1; j >= 2; --j) {
                output[i + j] = input[i + j];
            }
        }
        return output;
    });
}
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
    var sourceProj = proj_get(source);
    var destProj = proj_get(destination);
    Object(transforms["a" /* add */])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
    Object(transforms["a" /* add */])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [opt_projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
    disableCoordinateWarning();
    return proj_transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [opt_projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
    var lonLat = proj_transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
    var lon = lonLat[0];
    if (lon < -180 || lon > 180) {
        lonLat[0] = Object(math["g" /* modulo */])(lon + 180, 360) - 180;
    }
    return lonLat;
}
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
    if (projection1 === projection2) {
        return true;
    }
    var equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) {
        return equalUnits;
    }
    else {
        var transformFunc = getTransformFromProjections(projection1, projection2);
        return transformFunc === cloneTransform && equalUnits;
    }
}
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
    var sourceCode = sourceProjection.getCode();
    var destinationCode = destinationProjection.getCode();
    var transformFunc = Object(transforms["c" /* get */])(sourceCode, destinationCode);
    if (!transformFunc) {
        transformFunc = identityTransform;
    }
    return transformFunc;
}
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
    var sourceProjection = proj_get(source);
    var destinationProjection = proj_get(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
}
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function proj_transform(coordinate, source, destination) {
    var transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, undefined, coordinate.length);
}
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination, opt_stops) {
    var transformFunc = getTransform(source, destination);
    return Object(ol_extent["a" /* applyTransform */])(extent, transformFunc, undefined, opt_stops);
}
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
    var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
    return transformFunc(point);
}
/**
 * @type {Projection|null}
 */
var userProjection = null;
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */
function setUserProjection(projection) {
    userProjection = proj_get(projection);
}
/**
 * Clear the user projection if set.
 * @api
 */
function clearUserProjection() {
    userProjection = null;
}
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */
function getUserProjection() {
    return userProjection;
}
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API
 * methods except for those interacting with tile grids.
 * @api
 */
function useGeographic() {
    setUserProjection('EPSG:4326');
}
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */
function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) {
        return coordinate;
    }
    return proj_transform(coordinate, sourceProjection, userProjection);
}
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */
function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) {
        if (showCoordinateWarning &&
            !Object(ol_coordinate["d" /* equals */])(coordinate, [0, 0]) &&
            coordinate[0] >= -180 &&
            coordinate[0] <= 180 &&
            coordinate[1] >= -90 &&
            coordinate[1] <= 90) {
            showCoordinateWarning = false;
            // eslint-disable-next-line no-console
            console.warn('Call useGeographic() ol/proj once to work with [longitude, latitude] coordinates.');
        }
        return coordinate;
    }
    return proj_transform(coordinate, userProjection, destProjection);
}
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */
function toUserExtent(extent, sourceProjection) {
    if (!userProjection) {
        return extent;
    }
    return transformExtent(extent, sourceProjection, userProjection);
}
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */
function fromUserExtent(extent, destProjection) {
    if (!userProjection) {
        return extent;
    }
    return transformExtent(extent, userProjection, destProjection);
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */
function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) {
        return resolution;
    }
    var sourceUnits = proj_get(sourceProjection).getUnits();
    var userUnits = userProjection.getUnits();
    return sourceUnits && userUnits
        ? (resolution * Units["a" /* METERS_PER_UNIT */][sourceUnits]) / Units["a" /* METERS_PER_UNIT */][userUnits]
        : resolution;
}
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */
function fromUserResolution(resolution, destProjection) {
    if (!userProjection) {
        return resolution;
    }
    var sourceUnits = proj_get(destProjection).getUnits();
    var userUnits = userProjection.getUnits();
    return sourceUnits && userUnits
        ? (resolution * Units["a" /* METERS_PER_UNIT */][userUnits]) / Units["a" /* METERS_PER_UNIT */][sourceUnits]
        : resolution;
}
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
 */
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
    return function (coord) {
        var sourceX = coord[0];
        var sourceY = coord[1];
        var transformed, worldsAway;
        if (sourceProj.canWrapX()) {
            var sourceExtent = sourceProj.getExtent();
            var sourceExtentWidth = Object(ol_extent["D" /* getWidth */])(sourceExtent);
            worldsAway = Object(ol_coordinate["e" /* getWorldsAway */])(coord, sourceProj, sourceExtentWidth);
            if (worldsAway) {
                // Move x to the real world
                sourceX = sourceX - worldsAway * sourceExtentWidth;
            }
            sourceX = Object(math["b" /* clamp */])(sourceX, sourceExtent[0], sourceExtent[2]);
            sourceY = Object(math["b" /* clamp */])(sourceY, sourceExtent[1], sourceExtent[3]);
            transformed = transform([sourceX, sourceY]);
        }
        else {
            transformed = transform(coord);
        }
        if (worldsAway && destProj.canWrapX()) {
            // Move transformed coordinate back to the offset world
            transformed[0] += worldsAway * Object(ol_extent["D" /* getWidth */])(destProj.getExtent());
        }
        return transformed;
    };
}
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections(PROJECTIONS);
    addEquivalentProjections(epsg4326_PROJECTIONS);
    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.
    addEquivalentTransforms(epsg4326_PROJECTIONS, PROJECTIONS, fromEPSG4326, toEPSG4326);
}
addCommon();
//# sourceMappingURL=proj.js.map

/***/ }),

/***/ "25a5":
/***/ (function(module, exports, __webpack_require__) {

!function(t,i){ true?module.exports=i():undefined}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "25f0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__("e330");
var PROPER_FUNCTION_NAME = __webpack_require__("5e77").PROPER;
var redefine = __webpack_require__("6eeb");
var anObject = __webpack_require__("825a");
var isPrototypeOf = __webpack_require__("3a9b");
var $toString = __webpack_require__("577e");
var fails = __webpack_require__("d039");
var regExpFlags = __webpack_require__("ad6d");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var n$ToString = RegExpPrototype[TO_STRING];
var getFlags = uncurryThis(regExpFlags);

var NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = $toString(R.source);
    var rf = R.flags;
    var f = $toString(rf === undefined && isPrototypeOf(RegExpPrototype, R) && !('flags' in RegExpPrototype) ? getFlags(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ "25f1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return linearRingContainsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return linearRingContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return linearRingsContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return linearRingssContainsXY; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0af5");
/**
 * @module ol/geom/flat/contains
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
    var outside = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* forEachCorner */ "s"])(extent, 
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function (coordinate) {
        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
    return !outside;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
    // https://geomalgorithms.com/a03-_inclusion.html
    // Copyright 2000 softSurfer, 2012 Dan Sunday
    // This code may be freely used and modified for any purpose
    // providing that this copyright notice is included with it.
    // SoftSurfer makes no warranty for this code, and cannot be held
    // liable for any real or imagined damage resulting from its use.
    // Users of this code must verify correctness for their application.
    var wn = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];
    for (; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        if (y1 <= y) {
            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                wn++;
            }
        }
        else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
            wn--;
        }
        x1 = x2;
        y1 = y2;
    }
    return wn !== 0;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
    if (ends.length === 0) {
        return false;
    }
    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
        return false;
    }
    for (var i = 1, ii = ends.length; i < ii; ++i) {
        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
            return false;
        }
    }
    return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
    if (endss.length === 0) {
        return false;
    }
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
            return true;
        }
        offset = ends[ends.length - 1];
    }
    return false;
}
//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "2626":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__("d066");
var definePropertyModule = __webpack_require__("9bf2");
var wellKnownSymbol = __webpack_require__("b622");
var DESCRIPTORS = __webpack_require__("83ab");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "271d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2FJREFUeNq0l89PE0EUx1+XllCQpvRCIhjXAzGS2NSzB+sfYGz8B8C/QLhrKFcvePOIJhpPBvDizZroAWKwDSQoF7sxrUmjdNfyY6X7Y5yZziyzv0q31W8y2Z3Z2X5m3rx97zUGEdVuQg5f0p5hbTgDlSi/E+sRlseXOdwKAVAHjts6bs/xIt4PBGa7W8Et73op7uoCsvBmkSYOEfBiVCtw6DxuiDfzaB7ZRgmFyTbLyDxeQG01jYT35qNCV/nLRiuPbKuKepatIvOwIMJXezI1nrjAzAtDySJII0vOs2azCXt7X6DVatF+MpmEmZkZmJ6e8v2w3X4G1vF93iVmfxIKZk5UEqGGYYCu62CaJmxubgVaKJvNQio1TueQxZAWAL8tOp0XXMaXnJQowNCFNbrD7e3PFB5FsizD7Ow1em+dLIJ9SjdbweAbfI4kOhOBQiwN0ii1NFSrSmQokaIoUKvVoWO5JYhJMrnNic4mCfPn6ADeLZlIgPws+1G9XmM2xRsZeeBiOKbGKyFBQSX38VQZYkM5auJGo9E3OJFI4LO/DpOTk/QbN7QJ/mgCm1zjO87x1REo0SBQImKxnZ1d8P4uZ3EwDUXCQ8czB4UHRLu894xdIt/noEqlUmdgyR3i42EvkaAwOpqEg4Nm32BZvhz6LN7txUwmQ1uYHpdVuHtlDK6mhyMvipta6YQaJRRwaNi+8TfVI1j48NPp72ttOhYk23CCliKCafpCGIwC4C/3Wy4A13hCci2oVNPh0dYBlOonvrnIdMAVB8zyJiWi9nM/YFiiu/Hq7Z0p+HjvkjCvE4F/HJu+hMF368vROIgUaRrUZJraRLXaFm1cDzd/ufqi6keGb4ykVpYii0E5OI2bSiZYejE03X5q6Cj7SqFwrhf7v9HGt8PA+dafFQ5VWYR0x2oSxvBlmWYUvYidYT3QSS6OdT4E8WzfsbP1HgcpiSx9mXeXGSO0+ijRFeISplupI+rproZuvv6OvqqnrlJIKINKvZQ9xORlXrp0M3uYqHnPoGXRxJHgxOGs09Xzge010ZG6Qs8rb4kXnhVdLMtICU95a1bAJt+pu8QlZ1rsu6DHcJnBuxXz3qKeQJWB/0kIiyiwfHpLKPJJQNhgNdU6/G8x7+/dcf4hOM2OoS/9FWAAm5MmRi8BDuIAAAAASUVORK5CYII="

/***/ }),

/***/ "2815":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0650.ec9af15e.png";

/***/ }),

/***/ "2846":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "2909":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "29e8":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "29f6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/style/TextPlacement
 */
/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    POINT: 'point',
    LINE: 'line',
});
//# sourceMappingURL=TextPlacement.js.map

/***/ }),

/***/ "2a62":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var getMethod = __webpack_require__("dc4a");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "2b41":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "2ba4":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__("40d5");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "2c30":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getKeyZXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getKey; });
/* unused harmony export getCacheKeyForTileKey */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fromKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return withinExtentAndZ; });
/**
 * @module ol/tilecoord
 */
/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [opt_tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
    if (opt_tileCoord !== undefined) {
        opt_tileCoord[0] = z;
        opt_tileCoord[1] = x;
        opt_tileCoord[2] = y;
        return opt_tileCoord;
    }
    else {
        return [z, x, y];
    }
}
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
    return z + '/' + x + '/' + y;
}
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */
function getCacheKeyForTileKey(tileKey) {
    var _a = tileKey
        .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)
        .split(',')
        .map(Number), z = _a[0], x = _a[1], y = _a[2];
    return getKeyZXY(z, x, y);
}
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
    return key.split('/').map(Number);
}
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
    var z = tileCoord[0];
    var x = tileCoord[1];
    var y = tileCoord[2];
    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
        return false;
    }
    var tileRange = tileGrid.getFullTileRange(z);
    if (!tileRange) {
        return true;
    }
    else {
        return tileRange.containsXY(x, y);
    }
}
//# sourceMappingURL=tilecoord.js.map

/***/ }),

/***/ "2cf4":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var apply = __webpack_require__("2ba4");
var bind = __webpack_require__("0366");
var isCallable = __webpack_require__("1626");
var hasOwn = __webpack_require__("1a2d");
var fails = __webpack_require__("d039");
var html = __webpack_require__("1be4");
var arraySlice = __webpack_require__("f36a");
var createElement = __webpack_require__("cc12");
var validateArgumentsLength = __webpack_require__("d6d6");
var IS_IOS = __webpack_require__("1cdc");
var IS_NODE = __webpack_require__("605d");

var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var location, defer, channel, port;

try {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  location = global.location;
} catch (error) { /* empty */ }

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(String(id), location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    isCallable(global.postMessage) &&
    !global.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "2d00":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var userAgent = __webpack_require__("342f");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "2ea2":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "2ede":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "2efc":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a504");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("5e31");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("acc1");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("b739");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("3c81");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("7fc9");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("0af5");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("1e8d");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/reproj/Tile
 */









/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */
/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile = /** @class */ (function (_super) {
    __extends(ReprojTile, _super);
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
     * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} gutter Gutter of the source tiles.
     * @param {FunctionType} getTileFunction
     *     Function returning source tiles (z, x, y, pixelRatio).
     * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).
     * @param {boolean} [opt_renderEdges] Render reprojection edges.
     * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.
     */
    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {
        var _this = _super.call(this, tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].IDLE, { interpolate: !!opt_interpolate }) || this;
        /**
         * @private
         * @type {boolean}
         */
        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
        /**
         * @private
         * @type {number}
         */
        _this.pixelRatio_ = pixelRatio;
        /**
         * @private
         * @type {number}
         */
        _this.gutter_ = gutter;
        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        _this.canvas_ = null;
        /**
         * @private
         * @type {import("../tilegrid/TileGrid.js").default}
         */
        _this.sourceTileGrid_ = sourceTileGrid;
        /**
         * @private
         * @type {import("../tilegrid/TileGrid.js").default}
         */
        _this.targetTileGrid_ = targetTileGrid;
        /**
         * @private
         * @type {import("../tilecoord.js").TileCoord}
         */
        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
        /**
         * @private
         * @type {!Array<import("../Tile.js").default>}
         */
        _this.sourceTiles_ = [];
        /**
         * @private
         * @type {?Array<import("../events.js").EventsKey>}
         */
        _this.sourcesListenerKeys_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.sourceZ_ = 0;
        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
        var maxTargetExtent = _this.targetTileGrid_.getExtent();
        var maxSourceExtent = _this.sourceTileGrid_.getExtent();
        var limitedTargetExtent = maxTargetExtent
            ? Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__[/* getIntersection */ "A"])(targetExtent, maxTargetExtent)
            : targetExtent;
        if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__[/* getArea */ "t"])(limitedTargetExtent) === 0) {
            // Tile is completely outside range -> EMPTY
            // TODO: is it actually correct that the source even creates the tile ?
            _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].EMPTY;
            return _this;
        }
        var sourceProjExtent = sourceProj.getExtent();
        if (sourceProjExtent) {
            if (!maxSourceExtent) {
                maxSourceExtent = sourceProjExtent;
            }
            else {
                maxSourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__[/* getIntersection */ "A"])(maxSourceExtent, sourceProjExtent);
            }
        }
        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
        var sourceResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_5__[/* calculateSourceExtentResolution */ "a"])(sourceProj, targetProj, limitedTargetExtent, targetResolution);
        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
            // invalid sourceResolution -> EMPTY
            // probably edges of the projections when no extent is defined
            _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].EMPTY;
            return _this;
        }
        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_0__[/* ERROR_THRESHOLD */ "b"];
        /**
         * @private
         * @type {!import("./Triangulation.js").default}
         */
        _this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
        if (_this.triangulation_.getTriangles().length === 0) {
            // no valid triangles -> EMPTY
            _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].EMPTY;
            return _this;
        }
        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
        var sourceExtent = _this.triangulation_.calculateSourceExtent();
        if (maxSourceExtent) {
            if (sourceProj.canWrapX()) {
                sourceExtent[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__[/* clamp */ "b"])(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                sourceExtent[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__[/* clamp */ "b"])(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
            }
            else {
                sourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__[/* getIntersection */ "A"])(sourceExtent, maxSourceExtent);
            }
        }
        if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__[/* getArea */ "t"])(sourceExtent)) {
            _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].EMPTY;
        }
        else {
            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
                    if (tile) {
                        _this.sourceTiles_.push(tile);
                    }
                }
            }
            if (_this.sourceTiles_.length === 0) {
                _this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].EMPTY;
            }
        }
        return _this;
    }
    /**
     * Get the HTML Canvas element for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */
    ReprojTile.prototype.getImage = function () {
        return this.canvas_;
    };
    /**
     * @private
     */
    ReprojTile.prototype.reproject_ = function () {
        var sources = [];
        this.sourceTiles_.forEach(function (tile, i, arr) {
            if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOADED) {
                sources.push({
                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                    image: tile.getImage(),
                });
            }
        }.bind(this));
        this.sourceTiles_.length = 0;
        if (sources.length === 0) {
            this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].ERROR;
        }
        else {
            var z = this.wrappedTileCoord_[0];
            var size = this.targetTileGrid_.getTileSize(z);
            var width = typeof size === 'number' ? size : size[0];
            var height = typeof size === 'number' ? size : size[1];
            var targetResolution = this.targetTileGrid_.getResolution(z);
            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            this.canvas_ = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_5__[/* render */ "c"])(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
            this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOADED;
        }
        this.changed();
    };
    /**
     * Load not yet loaded URI.
     */
    ReprojTile.prototype.load = function () {
        if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].IDLE) {
            this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOADING;
            this.changed();
            var leftToLoad_1 = 0;
            this.sourcesListenerKeys_ = [];
            this.sourceTiles_.forEach(function (tile, i, arr) {
                var state = tile.getState();
                if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOADING) {
                    leftToLoad_1++;
                    var sourceListenKey_1 = Object(_events_js__WEBPACK_IMPORTED_MODULE_8__[/* listen */ "a"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE, function (e) {
                        var state = tile.getState();
                        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOADED ||
                            state == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].ERROR ||
                            state == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].EMPTY) {
                            Object(_events_js__WEBPACK_IMPORTED_MODULE_8__[/* unlistenByKey */ "c"])(sourceListenKey_1);
                            leftToLoad_1--;
                            if (leftToLoad_1 === 0) {
                                this.unlistenSources_();
                                this.reproject_();
                            }
                        }
                    }, this);
                    this.sourcesListenerKeys_.push(sourceListenKey_1);
                }
            }.bind(this));
            if (leftToLoad_1 === 0) {
                setTimeout(this.reproject_.bind(this), 0);
            }
            else {
                this.sourceTiles_.forEach(function (tile, i, arr) {
                    var state = tile.getState();
                    if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].IDLE) {
                        tile.load();
                    }
                });
            }
        }
    };
    /**
     * @private
     */
    ReprojTile.prototype.unlistenSources_ = function () {
        this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_8__[/* unlistenByKey */ "c"]);
        this.sourcesListenerKeys_ = null;
    };
    return ReprojTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (ReprojTile);
//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "2efd":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAA7AAAAOwBeShxvQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASLSURBVFiFpZd7iFRVHMc/5955re5uybYPzV0Lc3qsf4ivXRMjwYIelGjbtisGRdAfsQTRf0oEhZQiRFSSLCqUZg8l/4igApPW3TVd0iAKzbSaXfe9M7uzO3fm3nt+/THO2Ow4r/UHw3DO+Z7v93POvZw5oyihZPvau7VWT4vwuECDgsVa63nacROWkxixYvFjE5Gp9+7vHbxarKcqKvj5VQ2u49kBvAQY+bSWFWNibOJby453LOsevnzLAE5b0wso2QfKXwwsgNaawaGhhBWLvRzsHTmUT5t3NXb72ndQHMgZ7i9DKm7PNjUM6upqfYFA4OCldbW78mXk3AG3rblDlLyfNWHlBtRDT6CWr4Gy+UlQV2NdvYRxvJPA+Z9uLMB2GBjoR4t+ZVn38EdFAySea24yDOkCPOnOBXdgdLyNundFztXENEz+dp4F+3ZiRkYBiExGGB8btw1lrF/aPXh29pybPgLDkL0Z4dULMd86mDccoMyA+Q+sYPiNAzhVdQBUlldiGqZXRO+9adbsDntb06PA+nSHx4vx2h5YUJ03PFXlJniqahjr2I14vChDUVFZgcCGi821mwoCKE1rRnvTVlTDPUWFp6rSBLshyPTDmwEoKytLeiHP5gUQUCiezBA8srWkcEg+CgVENyXX4vcHUIYCxVMy673L3IHtD1YDNen2wiVQV18ygAJ8Bjg1i7Fr61EKvKYXoPbiqkVVOQFscRZmGNUsKjk8Vak32K2+MxlkJqM8PjcjIwNAOeb8DBd/YM4A6vpGS+D681fJKK2kPCeAR9zRDJfI+JwBXEl+m+Gkpaud1NBwTgB8Vj9gp5ry90WwE3MCsAVUIo733z8B0I4GSATEN5ATQH3y6zRwLt1hxZBfTpcc7kjyE7jQhYrHcBwXx3UA1VPfE4rlBABQqBP/b8uxTtC6JICoC7gulSc6AYhZM9fNODFbmwVg4NkPTKcBQpfRRz8sOtwRmHLhti8/wDtwJQk0NQ0wadiJAwUB1JGuCVFknNvyzWH0sU4QyRsuwKgtlH+9n4rvPgMgkYhjWTFQsmtp30QkK++mRi2NPu2p6BMlyzPEjWtQ7R2ou4JZcxyBcOgf5h16F/8ffen+a4PXsGLxcyH/0LqNP+LMnpfzPiCta4Ouqc4ClVmTlgShcRWqqpb4shW4oSuY33+B98rvGbpoNMrIyEgYxepc17O8VzJnW3MrIkfzaXKV62r6QyFxXPeZYO/w8Vy6vFcyz+HezwWybkXF1Pj4KFrcPfnCCwIAeMqd14GuUsJjMzNEo9Pd4fjwzkLaggBqf59tKtpARooJ11oYGx8bdQ3dsrrvxqk6ZwAAdfhMSFCtgFtIGw5P6ETCbbvv9OhAIW3RAADeI2dOKtSb+TTxeJxIZHJHsHfoh2J9i/pnlCoB5bY3HQc2Z40JXBvsP1V/MrRRJc+koqroHQBQICbeF4G/Zo9FJsORKYstpYSXDADJo1obsgVI/6olErZY0ehjjT2hki8QJQMA+D79+QJKvQqAIFNT0d2LT/X3zMXrlsppb/p4pmXlV7fi8R9j281OvNHQ2gAAAABJRU5ErkJggg=="

/***/ }),

/***/ "30e6":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "31ac":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "3333":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cef7");
/**
 * @module ol/render/Event
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var RenderEvent = /** @class */ (function (_super) {
    __extends(RenderEvent, _super);
    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [opt_inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../PluggableMap.js").FrameState} [opt_frameState] Frame state.
     * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [opt_context] Context.
     */
    function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
        var _this = _super.call(this, type) || this;
        /**
         * Transform from CSS pixels (relative to the top-left corner of the map viewport)
         * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
         * @type {import("../transform.js").Transform|undefined}
         * @api
         */
        _this.inversePixelTransform = opt_inversePixelTransform;
        /**
         * An object representing the current render frame state.
         * @type {import("../PluggableMap.js").FrameState|undefined}
         * @api
         */
        _this.frameState = opt_frameState;
        /**
         * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
         * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
         * context.
         * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
         * @api
         */
        _this.context = opt_context;
        return _this;
    }
    return RenderEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (RenderEvent);
//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "33a7":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "33de":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0092.d913046a.png";

/***/ }),

/***/ "3419":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "342f":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "345d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export buffer */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return hasArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return toSize; });
/**
 * @module ol/size
 */
/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */
/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, opt_size) {
    if (opt_size === undefined) {
        opt_size = [0, 0];
    }
    opt_size[0] = size[0] + 2 * num;
    opt_size[1] = size[1] + 2 * num;
    return opt_size;
}
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
}
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} The scaled size.
 */
function scale(size, ratio, opt_size) {
    if (opt_size === undefined) {
        opt_size = [0, 0];
    }
    opt_size[0] = (size[0] * ratio + 0.5) | 0;
    opt_size[1] = (size[1] * ratio + 0.5) | 0;
    return opt_size;
}
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
function toSize(size, opt_size) {
    if (Array.isArray(size)) {
        return size;
    }
    else {
        if (opt_size === undefined) {
            opt_size = [size, size];
        }
        else {
            opt_size[0] = size;
            opt_size[1] = size;
        }
        return opt_size;
    }
}
//# sourceMappingURL=size.js.map

/***/ }),

/***/ "35a1":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");
var getMethod = __webpack_require__("dc4a");
var Iterators = __webpack_require__("3f8c");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "35a7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export unByKey */
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0ec0");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1e8d");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Observable
 */



/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */
/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */
/**
 * @typedef {'change'|'error'} EventTypes
 */
/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
var Observable = /** @class */ (function (_super) {
    __extends(Observable, _super);
    function Observable() {
        var _this = _super.call(this) || this;
        _this.on =
            /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (_this.onInternal);
        _this.once =
            /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (_this.onceInternal);
        _this.un = /** @type {ObservableOnSignature<void>} */ (_this.unInternal);
        /**
         * @private
         * @type {number}
         */
        _this.revision_ = 0;
        return _this;
    }
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */
    Observable.prototype.changed = function () {
        ++this.revision_;
        this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE);
    };
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */
    Observable.prototype.getRevision = function () {
        return this.revision_;
    };
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    Observable.prototype.onInternal = function (type, listener) {
        if (Array.isArray(type)) {
            var len = type.length;
            var keys = new Array(len);
            for (var i = 0; i < len; ++i) {
                keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[/* listen */ "a"])(this, type[i], listener);
            }
            return keys;
        }
        else {
            return Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[/* listen */ "a"])(this, /** @type {string} */ (type), listener);
        }
    };
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    Observable.prototype.onceInternal = function (type, listener) {
        var key;
        if (Array.isArray(type)) {
            var len = type.length;
            key = new Array(len);
            for (var i = 0; i < len; ++i) {
                key[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[/* listenOnce */ "b"])(this, type[i], listener);
            }
        }
        else {
            key = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[/* listenOnce */ "b"])(this, /** @type {string} */ (type), listener);
        }
        /** @type {Object} */ (listener).ol_key = key;
        return key;
    };
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */
    Observable.prototype.unInternal = function (type, listener) {
        var key = /** @type {Object} */ (listener).ol_key;
        if (key) {
            unByKey(key);
        }
        else if (Array.isArray(type)) {
            for (var i = 0, ii = type.length; i < ii; ++i) {
                this.removeEventListener(type[i], listener);
            }
        }
        else {
            this.removeEventListener(type, listener);
        }
    };
    return Observable;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */
Observable.prototype.un;
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
    if (Array.isArray(key)) {
        for (var i = 0, ii = key.length; i < ii; ++i) {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[/* unlistenByKey */ "c"])(key[i]);
        }
    }
    else {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_2__[/* unlistenByKey */ "c"])(/** @type {import("./events.js").EventsKey} */ (key));
    }
}
/* harmony default export */ __webpack_exports__["a"] = (Observable);
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "3771":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track06.8a28d016.png";

/***/ }),

/***/ "37e8":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__("aed9");
var definePropertyModule = __webpack_require__("9bf2");
var anObject = __webpack_require__("825a");
var toIndexedObject = __webpack_require__("fc6a");
var objectKeys = __webpack_require__("df75");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "3820":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/extent/Corner
 */
/**
 * Extent corner.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_RIGHT: 'bottom-right',
    TOP_LEFT: 'top-left',
    TOP_RIGHT: 'top-right',
});
//# sourceMappingURL=Corner.js.map

/***/ }),

/***/ "38f3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isEmpty; });
/**
 * @module ol/obj
 */
/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = typeof Object.assign === 'function'
    ? Object.assign
    : function (target, var_sources) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        for (var i = 1, ii = arguments.length; i < ii; ++i) {
            var source = arguments[i];
            if (source !== undefined && source !== null) {
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        output[key] = source[key];
                    }
                }
            }
        }
        return output;
    };
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
    for (var property in object) {
        delete object[property];
    }
}
/**
 * Polyfill for Object.values().  Get an array of property values from an object.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
 *
 * @param {!Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
var getValues = typeof Object.values === 'function'
    ? Object.values
    : function (object) {
        var values = [];
        for (var property in object) {
            values.push(object[property]);
        }
        return values;
    };
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
    var property;
    for (property in object) {
        return false;
    }
    return !property;
}
//# sourceMappingURL=obj.js.map

/***/ }),

/***/ "3900":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("592d");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("57cb");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1e8d");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0999");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/control/Control
 */





/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */
/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
var Control = /** @class */ (function (_super) {
    __extends(Control, _super);
    /**
     * @param {Options} options Control options.
     */
    function Control(options) {
        var _this = _super.call(this) || this;
        var element = options.element;
        if (element && !options.target && !element.style.pointerEvents) {
            element.style.pointerEvents = 'auto';
        }
        /**
         * @protected
         * @type {HTMLElement}
         */
        _this.element = element ? element : null;
        /**
         * @private
         * @type {HTMLElement}
         */
        _this.target_ = null;
        /**
         * @private
         * @type {import("../PluggableMap.js").default|null}
         */
        _this.map_ = null;
        /**
         * @protected
         * @type {!Array<import("../events.js").EventsKey>}
         */
        _this.listenerKeys = [];
        if (options.render) {
            _this.render = options.render;
        }
        if (options.target) {
            _this.setTarget(options.target);
        }
        return _this;
    }
    /**
     * Clean up.
     */
    Control.prototype.disposeInternal = function () {
        Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[/* removeNode */ "e"])(this.element);
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * Get the map associated with this control.
     * @return {import("../PluggableMap.js").default|null} Map.
     * @api
     */
    Control.prototype.getMap = function () {
        return this.map_;
    };
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default|null} map Map.
     * @api
     */
    Control.prototype.setMap = function (map) {
        if (this.map_) {
            Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[/* removeNode */ "e"])(this.element);
        }
        for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_3__[/* unlistenByKey */ "c"])(this.listenerKeys[i]);
        }
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
            var target = this.target_
                ? this.target_
                : map.getOverlayContainerStopEvent();
            target.appendChild(this.element);
            if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_2__[/* VOID */ "c"]) {
                this.listenerKeys.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_3__[/* listen */ "a"])(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POSTRENDER, this.render, this));
            }
            map.render();
        }
    };
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */
    Control.prototype.render = function (mapEvent) { };
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */
    Control.prototype.setTarget = function (target) {
        this.target_ =
            typeof target === 'string' ? document.getElementById(target) : target;
    };
    return Control;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (Control);
//# sourceMappingURL=Control.js.map

/***/ }),

/***/ "392c":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGYUlEQVR4nIWVeWzUxxXHP++3612v9/B9gPEJjhFrF8IRIIgmIgYTKgICCoEQVBUsClKhaQFXRRFpQqhUClKwAhRxSW3D1caghDQJAVpIGwzmkKkxh+3gAxsMvtb2rte73tc/llVpk9A3Gs0fM/P9znfmfedJKBQCQER4HMXAwh7fwMTrdx9lXKprc91r76WupQvDbFIeLwsFBiUz1UVWkpOxOcmewpykpnhHdAVwDPgUQFURVY0ArwA27T9VPWzvX6uovd9NWlwMOcPiGRpvx52dRILdCiKgSnuvn5qGR7R0eqlt7qC1o4+MJAcrigtZNXt0swl5C9gXIdh6qa5tXfG6w6TExvCzRc8xbngKPb4A1Y3t1LZ00uYL8OBhD2oykJCSHB9DQnQUhdlJ5A9LIM5uofJOG9uOVNDc5qF8ywKKx2RuE1Utud/l3TNk0U62rvg+i6cXsPXwBY79s5aWqmYKXszHGmXm8sV6iLGAyQRePwRDvDzDTUObhxvXGhmancQPJ49gw5JJfHCqmvXbP+PG0dWIqtb8ZPfZkY0PPRzdMIuUhbvwPfKA08bG1yax+fUpfH6tgeI3DkGCHbwD0B/k8OZ5LJqSR3lFHfPWHwGXDbp9RMfb6S7/KTM2lZOZ7MRQVced1i5dXuTWkvdPq6+jT0mJVWxRmp8er4OhkLb39CsmQ+n2qSPGotcOLte5k4drTXOH9g8MKoYoFpNKqkv7O/p01a4zurK4UO919KkBtFnNhtTd7+Z2Sxc4rWAIhJRlGz+ko8dPnN0KnV6Skhxc3bmMgsxERizdQ2VtGy6bBRRAwqPdwuX6h/gGgljMhhgicisz2Yk1yiQWs0kIqQCCiBBnExGks9cv7rFZUn+wRFrae8U843fSfKFO4u1W8QcGBd+AIIT3hVSykp3y0OMTd0ZiyFDVrc/lpQV6fAF9NjdZCQwqoJEWHAypyTC0/N0F6oyO0swkp97e/2O9V7lJi8Zk6KxxWfrOuplKt09VVRlUHT88Ra83tmt+elynWUSuvuhOr3vz0IWRhVmJYZka5gBw2iwkOKzs/rCS3KxEXDYLFosZ+gMUT8xFValr6gCzKewmVbJSXPyt+h7TR2dWmQFy02JPe/3BkekJDrBFQUjDhhKh4WEPrZ19bN93LpymEcd3edm/7VWCg8rBIxchIwGCIUxxNgwBQ4TsFNfxiNEm/vpIxYV4u5U/fXmbi1cbwRGNACpAjx80FBYl4QRAFRxWiDJFxEKXlzkz3IxIjSXJFc0v540fan48VbGiyF398wPn3UumPsPFf9SCw4qGFDw+frtmOjkpLhCh1zeAPzBIblosa/ae42ZNS9gDAMFBFk4eQdknVZSXzvoIaDVH/qL0REeZPdqye0icXYfkpdLa5gGLGezRlFfUE2ONorO9l8KMBA6uf5lD527R3NwBNksY3OtnzIQcfIEg7owESYu3b1VVDP4T+9b84HsPPqr8Wn4xdxx4+kEEsZj46koDp09cIS3WRumSScx5+wRLfvUXeoMhxPL4cfv8lM4dy74vbsgbr4y5CpwHMD/xTQfH5CS/azEbOzIS7ZLnTudOfRtqt4J3gG2b5lA8Ppvi0qM0NXVAqgt6+lFDoLefadNGcb/TS06KC3dG4ppICTBUlUgHyra89vzdA2dqeGfpZMUfVLq8+l7pLB2dm6wFS36vTQ88Srxd6Q/orBfy1RljUcwm3Th/nB44U0PZihe+AL6MYBoiYdNGlKTGxSydMnII1Y3tUrJ4ohAKycriAinadDy8yGoWev0SG2eTkxtnS0+3V8rWTpedn16XVTMLSHBG/yhyehH5r4LzZOwtfvvE8pKiUez4uIoFE7J5duQQogwhpGAoBFGOnbuNmA3SEx2cvd7MJ2++shrY9STQdxHIgy5vzewtH+f/Ye10St77nPOXG8J5bzaBPwgDQVbPH8e0wmGU/vErbpYtPWw2GYu/AfQdBAB5p6ua/rVsxynL3lXTqGvp4uSlejp7+hmeGsurL42iobWL3xy/wpXtiytT42KeBwLfIIgU/W+VITK5/kH3qXlvHbc/k5HAzAm5OO0W7t738OezNcQ7ozm5ef4VkyFTVLX/WzGeRvCYZASw54O/35r6WeXXZq8/oMmuGJk/Nc/z0ujMg8Dap9zCU6/of+N1YCUQDbQAG4Cb/2/TvwEMldW4EAuh+wAAAABJRU5ErkJggg=="

/***/ }),

/***/ "399a":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "3a39":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ defaults; });

// UNUSED EXPORTS: DoubleClickZoom, DragAndDrop, DragBox, DragPan, DragRotate, DragRotateAndZoom, DragZoom, Draw, Extent, Interaction, KeyboardPan, KeyboardZoom, Modify, MouseWheelZoom, PinchRotate, PinchZoom, Pointer, Select, Snap, Translate

// EXTERNAL MODULE: ./node_modules/ol/Collection.js
var Collection = __webpack_require__("e300");

// EXTERNAL MODULE: ./node_modules/ol/interaction/Interaction.js
var Interaction = __webpack_require__("4334");

// EXTERNAL MODULE: ./node_modules/ol/MapBrowserEventType.js
var MapBrowserEventType = __webpack_require__("0b2d");

// CONCATENATED MODULE: ./node_modules/ol/interaction/DoubleClickZoom.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/DoubleClickZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */
/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
var DoubleClickZoom_DoubleClickZoom = /** @class */ (function (_super) {
    __extends(DoubleClickZoom, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function DoubleClickZoom(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options ? opt_options : {};
        /**
         * @private
         * @type {number}
         */
        _this.delta_ = options.delta ? options.delta : 1;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
    DoubleClickZoom.prototype.handleEvent = function (mapBrowserEvent) {
        var stopEvent = false;
        if (mapBrowserEvent.type == MapBrowserEventType["a" /* default */].DBLCLICK) {
            var browserEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
            var map = mapBrowserEvent.map;
            var anchor = mapBrowserEvent.coordinate;
            var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
            var view = map.getView();
            Object(Interaction["c" /* zoomByDelta */])(view, delta, anchor, this.duration_);
            browserEvent.preventDefault();
            stopEvent = true;
        }
        return !stopEvent;
    };
    return DoubleClickZoom;
}(Interaction["a" /* default */]));
/* harmony default export */ var interaction_DoubleClickZoom = (DoubleClickZoom_DoubleClickZoom);
//# sourceMappingURL=DoubleClickZoom.js.map
// EXTERNAL MODULE: ./node_modules/ol/interaction/Pointer.js
var Pointer = __webpack_require__("4105");

// EXTERNAL MODULE: ./node_modules/ol/functions.js
var functions = __webpack_require__("57cb");

// EXTERNAL MODULE: ./node_modules/ol/events/condition.js
var events_condition = __webpack_require__("06f8");

// EXTERNAL MODULE: ./node_modules/ol/easing.js
var easing = __webpack_require__("ca42");

// EXTERNAL MODULE: ./node_modules/ol/coordinate.js
var coordinate = __webpack_require__("a568");

// CONCATENATED MODULE: ./node_modules/ol/interaction/DragPan.js
var DragPan_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/DragPan
 */





/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */
/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
var DragPan_DragPan = /** @class */ (function (_super) {
    DragPan_extends(DragPan, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function DragPan(opt_options) {
        var _this = _super.call(this, {
            stopDown: functions["a" /* FALSE */],
        }) || this;
        var options = opt_options ? opt_options : {};
        /**
         * @private
         * @type {import("../Kinetic.js").default|undefined}
         */
        _this.kinetic_ = options.kinetic;
        /**
         * @type {import("../pixel.js").Pixel}
         */
        _this.lastCentroid = null;
        /**
         * @type {number}
         */
        _this.lastPointersCount_;
        /**
         * @type {boolean}
         */
        _this.panning_ = false;
        var condition = options.condition
            ? options.condition
            : Object(events_condition["a" /* all */])(events_condition["h" /* noModifierKeys */], events_condition["i" /* primaryAction */]);
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ = options.onFocusOnly
            ? Object(events_condition["a" /* all */])(events_condition["e" /* focusWithTabindex */], condition)
            : condition;
        /**
         * @private
         * @type {boolean}
         */
        _this.noKinetic_ = false;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
        if (!this.panning_) {
            this.panning_ = true;
            this.getMap().getView().beginInteraction();
        }
        var targetPointers = this.targetPointers;
        var centroid = Object(Pointer["a" /* centroid */])(targetPointers);
        if (targetPointers.length == this.lastPointersCount_) {
            if (this.kinetic_) {
                this.kinetic_.update(centroid[0], centroid[1]);
            }
            if (this.lastCentroid) {
                var delta = [
                    this.lastCentroid[0] - centroid[0],
                    centroid[1] - this.lastCentroid[1],
                ];
                var map = mapBrowserEvent.map;
                var view = map.getView();
                Object(coordinate["g" /* scale */])(delta, view.getResolution());
                Object(coordinate["f" /* rotate */])(delta, view.getRotation());
                view.adjustCenterInternal(delta);
            }
        }
        else if (this.kinetic_) {
            // reset so we don't overestimate the kinetic energy after
            // after one finger down, tiny drag, second finger down
            this.kinetic_.begin();
        }
        this.lastCentroid = centroid;
        this.lastPointersCount_ = targetPointers.length;
        mapBrowserEvent.originalEvent.preventDefault();
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                var distance = this.kinetic_.getDistance();
                var angle = this.kinetic_.getAngle();
                var center = view.getCenterInternal();
                var centerpx = map.getPixelFromCoordinateInternal(center);
                var dest = map.getCoordinateFromPixelInternal([
                    centerpx[0] - distance * Math.cos(angle),
                    centerpx[1] - distance * Math.sin(angle),
                ]);
                view.animateInternal({
                    center: view.getConstrainedCenter(dest),
                    duration: 500,
                    easing: easing["b" /* easeOut */],
                });
            }
            if (this.panning_) {
                this.panning_ = false;
                view.endInteraction();
            }
            return false;
        }
        else {
            if (this.kinetic_) {
                // reset so we don't overestimate the kinetic energy after
                // after one finger up, tiny drag, second finger up
                this.kinetic_.begin();
            }
            this.lastCentroid = null;
            return true;
        }
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            this.lastCentroid = null;
            // stop any current animation
            if (view.getAnimating()) {
                view.cancelAnimations();
            }
            if (this.kinetic_) {
                this.kinetic_.begin();
            }
            // No kinetic as soon as more than one pointer on the screen is
            // detected. This is to prevent nasty pans after pinch.
            this.noKinetic_ = this.targetPointers.length > 1;
            return true;
        }
        else {
            return false;
        }
    };
    return DragPan;
}(Pointer["b" /* default */]));
/* harmony default export */ var interaction_DragPan = (DragPan_DragPan);
//# sourceMappingURL=DragPan.js.map
// EXTERNAL MODULE: ./node_modules/ol/rotationconstraint.js
var rotationconstraint = __webpack_require__("8cc5");

// CONCATENATED MODULE: ./node_modules/ol/interaction/DragRotate.js
var DragRotate_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/DragRotate
 */




/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */
/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
var DragRotate_DragRotate = /** @class */ (function (_super) {
    DragRotate_extends(DragRotate, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function DragRotate(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this, {
            stopDown: functions["a" /* FALSE */],
        }) || this;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ = options.condition ? options.condition : events_condition["c" /* altShiftKeysOnly */];
        /**
         * @private
         * @type {number|undefined}
         */
        _this.lastAngle_ = undefined;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
        if (!Object(events_condition["g" /* mouseOnly */])(mapBrowserEvent)) {
            return;
        }
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (view.getConstraints().rotation === rotationconstraint["c" /* disable */]) {
            return;
        }
        var size = map.getSize();
        var offset = mapBrowserEvent.pixel;
        var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
        if (this.lastAngle_ !== undefined) {
            var delta = theta - this.lastAngle_;
            view.adjustRotationInternal(-delta);
        }
        this.lastAngle_ = theta;
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
        if (!Object(events_condition["g" /* mouseOnly */])(mapBrowserEvent)) {
            return true;
        }
        var map = mapBrowserEvent.map;
        var view = map.getView();
        view.endInteraction(this.duration_);
        return false;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
        if (!Object(events_condition["g" /* mouseOnly */])(mapBrowserEvent)) {
            return false;
        }
        if (Object(events_condition["f" /* mouseActionButton */])(mapBrowserEvent) &&
            this.condition_(mapBrowserEvent)) {
            var map = mapBrowserEvent.map;
            map.getView().beginInteraction();
            this.lastAngle_ = undefined;
            return true;
        }
        else {
            return false;
        }
    };
    return DragRotate;
}(Pointer["b" /* default */]));
/* harmony default export */ var interaction_DragRotate = (DragRotate_DragRotate);
//# sourceMappingURL=DragRotate.js.map
// EXTERNAL MODULE: ./node_modules/ol/events/Event.js
var Event = __webpack_require__("cef7");

// EXTERNAL MODULE: ./node_modules/ol/Disposable.js
var Disposable = __webpack_require__("da5c");

// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules
var Polygon = __webpack_require__("5bc3");

// CONCATENATED MODULE: ./node_modules/ol/render/Box.js
/**
 * @module ol/render/Box
 */
var Box_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Box_RenderBox = /** @class */ (function (_super) {
    Box_extends(RenderBox, _super);
    /**
     * @param {string} className CSS class name.
     */
    function RenderBox(className) {
        var _this = _super.call(this) || this;
        /**
         * @type {import("../geom/Polygon.js").default}
         * @private
         */
        _this.geometry_ = null;
        /**
         * @type {HTMLDivElement}
         * @private
         */
        _this.element_ = document.createElement('div');
        _this.element_.style.position = 'absolute';
        _this.element_.style.pointerEvents = 'auto';
        _this.element_.className = 'ol-box ' + className;
        /**
         * @private
         * @type {import("../PluggableMap.js").default|null}
         */
        _this.map_ = null;
        /**
         * @private
         * @type {import("../pixel.js").Pixel}
         */
        _this.startPixel_ = null;
        /**
         * @private
         * @type {import("../pixel.js").Pixel}
         */
        _this.endPixel_ = null;
        return _this;
    }
    /**
     * Clean up.
     */
    RenderBox.prototype.disposeInternal = function () {
        this.setMap(null);
    };
    /**
     * @private
     */
    RenderBox.prototype.render_ = function () {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var px = 'px';
        var style = this.element_.style;
        style.left = Math.min(startPixel[0], endPixel[0]) + px;
        style.top = Math.min(startPixel[1], endPixel[1]) + px;
        style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
        style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
    };
    /**
     * @param {import("../PluggableMap.js").default|null} map Map.
     */
    RenderBox.prototype.setMap = function (map) {
        if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            var style = this.element_.style;
            style.left = 'inherit';
            style.top = 'inherit';
            style.width = 'inherit';
            style.height = 'inherit';
        }
        this.map_ = map;
        if (this.map_) {
            this.map_.getOverlayContainer().appendChild(this.element_);
        }
    };
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */
    RenderBox.prototype.setPixels = function (startPixel, endPixel) {
        this.startPixel_ = startPixel;
        this.endPixel_ = endPixel;
        this.createOrUpdateGeometry();
        this.render_();
    };
    /**
     * Creates or updates the cached geometry.
     */
    RenderBox.prototype.createOrUpdateGeometry = function () {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var pixels = [
            startPixel,
            [startPixel[0], endPixel[1]],
            endPixel,
            [endPixel[0], startPixel[1]],
        ];
        var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
        // close the polygon
        coordinates[4] = coordinates[0].slice();
        if (!this.geometry_) {
            this.geometry_ = new Polygon["a" /* default */]([coordinates]);
        }
        else {
            this.geometry_.setCoordinates([coordinates]);
        }
    };
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */
    RenderBox.prototype.getGeometry = function () {
        return this.geometry_;
    };
    return RenderBox;
}(Disposable["a" /* default */]));
/* harmony default export */ var Box = (Box_RenderBox);
//# sourceMappingURL=Box.js.map
// CONCATENATED MODULE: ./node_modules/ol/interaction/DragBox.js
var DragBox_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box




/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */
/**
 * @enum {string}
 */
var DragBoxEventType = {
    /**
     * Triggered upon drag box start.
     * @event DragBoxEvent#boxstart
     * @api
     */
    BOXSTART: 'boxstart',
    /**
     * Triggered on drag when box is active.
     * @event DragBoxEvent#boxdrag
     * @api
     */
    BOXDRAG: 'boxdrag',
    /**
     * Triggered upon drag box end.
     * @event DragBoxEvent#boxend
     * @api
     */
    BOXEND: 'boxend',
    /**
     * Triggered upon drag box canceled.
     * @event DragBoxEvent#boxcancel
     * @api
     */
    BOXCANCEL: 'boxcancel',
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
var DragBoxEvent = /** @class */ (function (_super) {
    DragBox_extends(DragBoxEvent, _super);
    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */
    function DragBoxEvent(type, coordinate, mapBrowserEvent) {
        var _this = _super.call(this, type) || this;
        /**
         * The coordinate of the drag event.
         * @const
         * @type {import("../coordinate.js").Coordinate}
         * @api
         */
        _this.coordinate = coordinate;
        /**
         * @const
         * @type {import("../MapBrowserEvent.js").default}
         * @api
         */
        _this.mapBrowserEvent = mapBrowserEvent;
        return _this;
    }
    return DragBoxEvent;
}(Event["a" /* default */]));

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */
/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */
var DragBox_DragBox = /** @class */ (function (_super) {
    DragBox_extends(DragBox, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function DragBox(opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {DragBoxOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {DragBoxOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {DragBoxOnSignature<void>}
         */
        _this.un;
        var options = opt_options ? opt_options : {};
        /**
         * @type {import("../render/Box.js").default}
         * @private
         */
        _this.box_ = new Box(options.className || 'ol-dragbox');
        /**
         * @type {number}
         * @private
         */
        _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
        if (options.onBoxEnd) {
            _this.onBoxEnd = options.onBoxEnd;
        }
        /**
         * @type {import("../pixel.js").Pixel}
         * @private
         */
        _this.startPixel_ = null;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ = options.condition ? options.condition : events_condition["f" /* mouseActionButton */];
        /**
         * @private
         * @type {EndCondition}
         */
        _this.boxEndCondition_ = options.boxEndCondition
            ? options.boxEndCondition
            : _this.defaultBoxEndCondition;
        return _this;
    }
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */
    DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
        var width = endPixel[0] - startPixel[0];
        var height = endPixel[1] - startPixel[1];
        return width * width + height * height >= this.minArea_;
    };
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */
    DragBox.prototype.getGeometry = function () {
        return this.box_.getGeometry();
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
        this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
        this.box_.setMap(null);
        var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
        if (completeBox) {
            this.onBoxEnd(mapBrowserEvent);
        }
        this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
        return false;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
        if (this.condition_(mapBrowserEvent)) {
            this.startPixel_ = mapBrowserEvent.pixel;
            this.box_.setMap(mapBrowserEvent.map);
            this.box_.setPixels(this.startPixel_, this.startPixel_);
            this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    DragBox.prototype.onBoxEnd = function (event) { };
    return DragBox;
}(Pointer["b" /* default */]));
/* harmony default export */ var interaction_DragBox = (DragBox_DragBox);
//# sourceMappingURL=DragBox.js.map
// CONCATENATED MODULE: ./node_modules/ol/interaction/DragZoom.js
var DragZoom_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/DragZoom
 */



/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
var DragZoom_DragZoom = /** @class */ (function (_super) {
    DragZoom_extends(DragZoom, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function DragZoom(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        var condition = options.condition ? options.condition : events_condition["j" /* shiftKeyOnly */];
        _this = _super.call(this, {
            condition: condition,
            className: options.className || 'ol-dragzoom',
            minArea: options.minArea,
        }) || this;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 200;
        /**
         * @private
         * @type {boolean}
         */
        _this.out_ = options.out !== undefined ? options.out : false;
        return _this;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    DragZoom.prototype.onBoxEnd = function (event) {
        var map = this.getMap();
        var view = /** @type {!import("../View.js").default} */ (map.getView());
        var geometry = this.getGeometry();
        if (this.out_) {
            var rotatedExtent = view.rotatedExtentForGeometry(geometry);
            var resolution = view.getResolutionForExtentInternal(rotatedExtent);
            var factor = view.getResolution() / resolution;
            geometry = geometry.clone();
            geometry.scale(factor * factor);
        }
        view.fitInternal(geometry, {
            duration: this.duration_,
            easing: easing["b" /* easeOut */],
        });
    };
    return DragZoom;
}(interaction_DragBox));
/* harmony default export */ var interaction_DragZoom = (DragZoom_DragZoom);
//# sourceMappingURL=DragZoom.js.map
// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js
var EventType = __webpack_require__("01d4");

// CONCATENATED MODULE: ./node_modules/ol/events/KeyCode.js
/**
 * @module ol/events/KeyCode
 */
/**
 * @enum {number}
 * @const
 */
/* harmony default export */ var KeyCode = ({
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
});
//# sourceMappingURL=KeyCode.js.map
// CONCATENATED MODULE: ./node_modules/ol/interaction/KeyboardPan.js
var KeyboardPan_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/KeyboardPan
 */





/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */
/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
var KeyboardPan_KeyboardPan = /** @class */ (function (_super) {
    KeyboardPan_extends(KeyboardPan, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function KeyboardPan(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options || {};
        /**
         * @private
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
         * @return {boolean} Combined condition result.
         */
        _this.defaultCondition_ = function (mapBrowserEvent) {
            return (Object(events_condition["h" /* noModifierKeys */])(mapBrowserEvent) && Object(events_condition["l" /* targetNotEditable */])(mapBrowserEvent));
        };
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ =
            options.condition !== undefined
                ? options.condition
                : _this.defaultCondition_;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 100;
        /**
         * @private
         * @type {number}
         */
        _this.pixelDelta_ =
            options.pixelDelta !== undefined ? options.pixelDelta : 128;
        return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {KeyboardPan}
     */
    KeyboardPan.prototype.handleEvent = function (mapBrowserEvent) {
        var stopEvent = false;
        if (mapBrowserEvent.type == EventType["a" /* default */].KEYDOWN) {
            var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
            var keyCode = keyEvent.keyCode;
            if (this.condition_(mapBrowserEvent) &&
                (keyCode == KeyCode.DOWN ||
                    keyCode == KeyCode.LEFT ||
                    keyCode == KeyCode.RIGHT ||
                    keyCode == KeyCode.UP)) {
                var map = mapBrowserEvent.map;
                var view = map.getView();
                var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                var deltaX = 0, deltaY = 0;
                if (keyCode == KeyCode.DOWN) {
                    deltaY = -mapUnitsDelta;
                }
                else if (keyCode == KeyCode.LEFT) {
                    deltaX = -mapUnitsDelta;
                }
                else if (keyCode == KeyCode.RIGHT) {
                    deltaX = mapUnitsDelta;
                }
                else {
                    deltaY = mapUnitsDelta;
                }
                var delta = [deltaX, deltaY];
                Object(coordinate["f" /* rotate */])(delta, view.getRotation());
                Object(Interaction["b" /* pan */])(view, delta, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    };
    return KeyboardPan;
}(Interaction["a" /* default */]));
/* harmony default export */ var interaction_KeyboardPan = (KeyboardPan_KeyboardPan);
//# sourceMappingURL=KeyboardPan.js.map
// CONCATENATED MODULE: ./node_modules/ol/interaction/KeyboardZoom.js
var KeyboardZoom_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/KeyboardZoom
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */
/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
var KeyboardZoom_KeyboardZoom = /** @class */ (function (_super) {
    KeyboardZoom_extends(KeyboardZoom, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function KeyboardZoom(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options ? opt_options : {};
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ = options.condition ? options.condition : events_condition["l" /* targetNotEditable */];
        /**
         * @private
         * @type {number}
         */
        _this.delta_ = options.delta ? options.delta : 1;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 100;
        return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {KeyboardZoom}
     */
    KeyboardZoom.prototype.handleEvent = function (mapBrowserEvent) {
        var stopEvent = false;
        if (mapBrowserEvent.type == EventType["a" /* default */].KEYDOWN ||
            mapBrowserEvent.type == EventType["a" /* default */].KEYPRESS) {
            var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
            var charCode = keyEvent.charCode;
            if (this.condition_(mapBrowserEvent) &&
                (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
                var map = mapBrowserEvent.map;
                var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
                var view = map.getView();
                Object(Interaction["c" /* zoomByDelta */])(view, delta, undefined, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    };
    return KeyboardZoom;
}(Interaction["a" /* default */]));
/* harmony default export */ var interaction_KeyboardZoom = (KeyboardZoom_KeyboardZoom);
//# sourceMappingURL=KeyboardZoom.js.map
// CONCATENATED MODULE: ./node_modules/ol/Kinetic.js
/**
 * @module ol/Kinetic
 */
/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic = /** @class */ (function () {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */
    function Kinetic(decay, minVelocity, delay) {
        /**
         * @private
         * @type {number}
         */
        this.decay_ = decay;
        /**
         * @private
         * @type {number}
         */
        this.minVelocity_ = minVelocity;
        /**
         * @private
         * @type {number}
         */
        this.delay_ = delay;
        /**
         * @private
         * @type {Array<number>}
         */
        this.points_ = [];
        /**
         * @private
         * @type {number}
         */
        this.angle_ = 0;
        /**
         * @private
         * @type {number}
         */
        this.initialVelocity_ = 0;
    }
    /**
     * FIXME empty description for jsdoc
     */
    Kinetic.prototype.begin = function () {
        this.points_.length = 0;
        this.angle_ = 0;
        this.initialVelocity_ = 0;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
    Kinetic.prototype.update = function (x, y) {
        this.points_.push(x, y, Date.now());
    };
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
    Kinetic.prototype.end = function () {
        if (this.points_.length < 6) {
            // at least 2 points are required (i.e. there must be at least 6 elements
            // in the array)
            return false;
        }
        var delay = Date.now() - this.delay_;
        var lastIndex = this.points_.length - 3;
        if (this.points_[lastIndex + 2] < delay) {
            // the last tracked point is too old, which means that the user stopped
            // panning before releasing the map
            return false;
        }
        // get the first point which still falls into the delay time
        var firstIndex = lastIndex - 3;
        while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
            firstIndex -= 3;
        }
        var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
        // we don't want a duration of 0 (divide by zero)
        // we also make sure the user panned for a duration of at least one frame
        // (1/60s) to compute sane displacement values
        if (duration < 1000 / 60) {
            return false;
        }
        var dx = this.points_[lastIndex] - this.points_[firstIndex];
        var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
        this.angle_ = Math.atan2(dy, dx);
        this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
        return this.initialVelocity_ > this.minVelocity_;
    };
    /**
     * @return {number} Total distance travelled (pixels).
     */
    Kinetic.prototype.getDistance = function () {
        return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    };
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
    Kinetic.prototype.getAngle = function () {
        return this.angle_;
    };
    return Kinetic;
}());
/* harmony default export */ var ol_Kinetic = (Kinetic);
//# sourceMappingURL=Kinetic.js.map
// EXTERNAL MODULE: ./node_modules/ol/has.js
var has = __webpack_require__("617d");

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__("7fc9");

// CONCATENATED MODULE: ./node_modules/ol/interaction/MouseWheelZoom.js
var MouseWheelZoom_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/MouseWheelZoom
 */





/**
 * @enum {string}
 */
var Mode = {
    TRACKPAD: 'trackpad',
    WHEEL: 'wheel',
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
var MouseWheelZoom_MouseWheelZoom = /** @class */ (function (_super) {
    MouseWheelZoom_extends(MouseWheelZoom, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function MouseWheelZoom(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this, 
        /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
        /**
         * @private
         * @type {number}
         */
        _this.totalDelta_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.lastDelta_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
         * @private
         * @type {number}
         */
        _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
        /**
         * @private
         * @type {boolean}
         */
        _this.useAnchor_ =
            options.useAnchor !== undefined ? options.useAnchor : true;
        /**
         * @private
         * @type {boolean}
         */
        _this.constrainResolution_ =
            options.constrainResolution !== undefined
                ? options.constrainResolution
                : false;
        var condition = options.condition ? options.condition : events_condition["d" /* always */];
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ = options.onFocusOnly
            ? Object(events_condition["a" /* all */])(events_condition["e" /* focusWithTabindex */], condition)
            : condition;
        /**
         * @private
         * @type {?import("../coordinate.js").Coordinate}
         */
        _this.lastAnchor_ = null;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.startTime_ = undefined;
        /**
         * @private
         * @type {?}
         */
        _this.timeoutId_;
        /**
         * @private
         * @type {Mode|undefined}
         */
        _this.mode_ = undefined;
        /**
         * Trackpad events separated by this delay will be considered separate
         * interactions.
         * @type {number}
         */
        _this.trackpadEventGap_ = 400;
        /**
         * @type {?}
         */
        _this.trackpadTimeoutId_;
        /**
         * The number of delta values per zoom level
         * @private
         * @type {number}
         */
        _this.deltaPerZoom_ = 300;
        return _this;
    }
    /**
     * @private
     */
    MouseWheelZoom.prototype.endInteraction_ = function () {
        this.trackpadTimeoutId_ = undefined;
        var view = this.getMap().getView();
        view.endInteraction(undefined, this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0, this.lastAnchor_);
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
    MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) {
            return true;
        }
        var type = mapBrowserEvent.type;
        if (type !== EventType["a" /* default */].WHEEL) {
            return true;
        }
        var map = mapBrowserEvent.map;
        var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);
        wheelEvent.preventDefault();
        if (this.useAnchor_) {
            this.lastAnchor_ = mapBrowserEvent.coordinate;
        }
        // Delta normalisation inspired by
        // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
        var delta;
        if (mapBrowserEvent.type == EventType["a" /* default */].WHEEL) {
            delta = wheelEvent.deltaY;
            if (has["b" /* FIREFOX */] && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                delta /= has["a" /* DEVICE_PIXEL_RATIO */];
            }
            if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                delta *= 40;
            }
        }
        if (delta === 0) {
            return false;
        }
        else {
            this.lastDelta_ = delta;
        }
        var now = Date.now();
        if (this.startTime_ === undefined) {
            this.startTime_ = now;
        }
        if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
            this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
        }
        var view = map.getView();
        if (this.mode_ === Mode.TRACKPAD &&
            !(view.getConstrainResolution() || this.constrainResolution_)) {
            if (this.trackpadTimeoutId_) {
                clearTimeout(this.trackpadTimeoutId_);
            }
            else {
                if (view.getAnimating()) {
                    view.cancelAnimations();
                }
                view.beginInteraction();
            }
            this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
            view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
            this.startTime_ = now;
            return false;
        }
        this.totalDelta_ += delta;
        var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
        clearTimeout(this.timeoutId_);
        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
        return false;
    };
    /**
     * @private
     * @param {import("../PluggableMap.js").default} map Map.
     */
    MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
        var view = map.getView();
        if (view.getAnimating()) {
            view.cancelAnimations();
        }
        var delta = -Object(math["b" /* clamp */])(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
        if (view.getConstrainResolution() || this.constrainResolution_) {
            // view has a zoom constraint, zoom by 1
            delta = delta ? (delta > 0 ? 1 : -1) : 0;
        }
        Object(Interaction["c" /* zoomByDelta */])(view, delta, this.lastAnchor_, this.duration_);
        this.mode_ = undefined;
        this.totalDelta_ = 0;
        this.lastAnchor_ = null;
        this.startTime_ = undefined;
        this.timeoutId_ = undefined;
    };
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */
    MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
        this.useAnchor_ = useAnchor;
        if (!useAnchor) {
            this.lastAnchor_ = null;
        }
    };
    return MouseWheelZoom;
}(Interaction["a" /* default */]));
/* harmony default export */ var interaction_MouseWheelZoom = (MouseWheelZoom_MouseWheelZoom);
//# sourceMappingURL=MouseWheelZoom.js.map
// CONCATENATED MODULE: ./node_modules/ol/interaction/PinchRotate.js
var PinchRotate_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/PinchRotate
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */
/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
var PinchRotate_PinchRotate = /** @class */ (function (_super) {
    PinchRotate_extends(PinchRotate, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function PinchRotate(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
        if (!pointerOptions.stopDown) {
            pointerOptions.stopDown = functions["a" /* FALSE */];
        }
        _this = _super.call(this, pointerOptions) || this;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */
        _this.anchor_ = null;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.lastAngle_ = undefined;
        /**
         * @private
         * @type {boolean}
         */
        _this.rotating_ = false;
        /**
         * @private
         * @type {number}
         */
        _this.rotationDelta_ = 0.0;
        /**
         * @private
         * @type {number}
         */
        _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
        var rotationDelta = 0.0;
        var touch0 = this.targetPointers[0];
        var touch1 = this.targetPointers[1];
        // angle between touches
        var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
        if (this.lastAngle_ !== undefined) {
            var delta = angle - this.lastAngle_;
            this.rotationDelta_ += delta;
            if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                this.rotating_ = true;
            }
            rotationDelta = delta;
        }
        this.lastAngle_ = angle;
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (view.getConstraints().rotation === rotationconstraint["c" /* disable */]) {
            return;
        }
        // rotate anchor point.
        // FIXME: should be the intersection point between the lines:
        //     touch0,touch1 and previousTouch0,previousTouch1
        var viewportPosition = map.getViewport().getBoundingClientRect();
        var centroid = Object(Pointer["a" /* centroid */])(this.targetPointers);
        centroid[0] -= viewportPosition.left;
        centroid[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
        // rotate
        if (this.rotating_) {
            map.render();
            view.adjustRotationInternal(rotationDelta, this.anchor_);
        }
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            view.endInteraction(this.duration_);
            return false;
        }
        else {
            return true;
        }
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            var map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastAngle_ = undefined;
            this.rotating_ = false;
            this.rotationDelta_ = 0.0;
            if (!this.handlingDownUpSequence) {
                map.getView().beginInteraction();
            }
            return true;
        }
        else {
            return false;
        }
    };
    return PinchRotate;
}(Pointer["b" /* default */]));
/* harmony default export */ var interaction_PinchRotate = (PinchRotate_PinchRotate);
//# sourceMappingURL=PinchRotate.js.map
// CONCATENATED MODULE: ./node_modules/ol/interaction/PinchZoom.js
var PinchZoom_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/PinchZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */
/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
var PinchZoom_PinchZoom = /** @class */ (function (_super) {
    PinchZoom_extends(PinchZoom, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function PinchZoom(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
        if (!pointerOptions.stopDown) {
            pointerOptions.stopDown = functions["a" /* FALSE */];
        }
        _this = _super.call(this, pointerOptions) || this;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */
        _this.anchor_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.duration_ = options.duration !== undefined ? options.duration : 400;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.lastDistance_ = undefined;
        /**
         * @private
         * @type {number}
         */
        _this.lastScaleDelta_ = 1;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
        var scaleDelta = 1.0;
        var touch0 = this.targetPointers[0];
        var touch1 = this.targetPointers[1];
        var dx = touch0.clientX - touch1.clientX;
        var dy = touch0.clientY - touch1.clientY;
        // distance between touches
        var distance = Math.sqrt(dx * dx + dy * dy);
        if (this.lastDistance_ !== undefined) {
            scaleDelta = this.lastDistance_ / distance;
        }
        this.lastDistance_ = distance;
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (scaleDelta != 1.0) {
            this.lastScaleDelta_ = scaleDelta;
        }
        // scale anchor point.
        var viewportPosition = map.getViewport().getBoundingClientRect();
        var centroid = Object(Pointer["a" /* centroid */])(this.targetPointers);
        centroid[0] -= viewportPosition.left;
        centroid[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
        // scale, bypass the resolution constraint
        map.render();
        view.adjustResolutionInternal(scaleDelta, this.anchor_);
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
            view.endInteraction(this.duration_, direction);
            return false;
        }
        else {
            return true;
        }
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            var map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastDistance_ = undefined;
            this.lastScaleDelta_ = 1;
            if (!this.handlingDownUpSequence) {
                map.getView().beginInteraction();
            }
            return true;
        }
        else {
            return false;
        }
    };
    return PinchZoom;
}(Pointer["b" /* default */]));
/* harmony default export */ var interaction_PinchZoom = (PinchZoom_PinchZoom);
//# sourceMappingURL=PinchZoom.js.map
// CONCATENATED MODULE: ./node_modules/ol/interaction.js
/**
 * @module ol/interaction
 */































/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */
/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [opt_options] Defaults options.
 * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(opt_options) {
    var options = opt_options ? opt_options : {};
    var interactions = new Collection["a" /* default */]();
    var kinetic = new ol_Kinetic(-0.005, 0.05, 100);
    var altShiftDragRotate = options.altShiftDragRotate !== undefined
        ? options.altShiftDragRotate
        : true;
    if (altShiftDragRotate) {
        interactions.push(new interaction_DragRotate());
    }
    var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
    if (doubleClickZoom) {
        interactions.push(new interaction_DoubleClickZoom({
            delta: options.zoomDelta,
            duration: options.zoomDuration,
        }));
    }
    var dragPan = options.dragPan !== undefined ? options.dragPan : true;
    if (dragPan) {
        interactions.push(new interaction_DragPan({
            onFocusOnly: options.onFocusOnly,
            kinetic: kinetic,
        }));
    }
    var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
    if (pinchRotate) {
        interactions.push(new interaction_PinchRotate());
    }
    var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
    if (pinchZoom) {
        interactions.push(new interaction_PinchZoom({
            duration: options.zoomDuration,
        }));
    }
    var keyboard = options.keyboard !== undefined ? options.keyboard : true;
    if (keyboard) {
        interactions.push(new interaction_KeyboardPan());
        interactions.push(new interaction_KeyboardZoom({
            delta: options.zoomDelta,
            duration: options.zoomDuration,
        }));
    }
    var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
    if (mouseWheelZoom) {
        interactions.push(new interaction_MouseWheelZoom({
            onFocusOnly: options.onFocusOnly,
            duration: options.zoomDuration,
        }));
    }
    var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
    if (shiftDragZoom) {
        interactions.push(new interaction_DragZoom({
            duration: options.zoomDuration,
        }));
    }
    return interactions;
}
//# sourceMappingURL=interaction.js.map

/***/ }),

/***/ "3a9b":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "3b0c":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAV9SURBVEhLzVddbJNVGD5GTYzR+JeokYAmGqKJhqAJl1x4440XJkpEvTLERKMiISoaol4oiV4YBY0G2Pp9XVvWlW1d98M22RjI2IROBhkjoxvrutH2+/r1Z23X9b+vzzk9ZT+UZRM1Psmb0/Odc97nfd/znvecsv8/HHQ7s0a3MtvsF8wScTDVOM0U3c3MxilIPbPG9mBsi5z9D+CrvruYJbYLSkeZbY5YfZ6YNUPMkkKLvpW36PPvljgxW8wNeVuu/pswzbzIbPFL7GiJmJqgh+0GvX5yln4cTVHrdIZ6Allqm8nQ/ssp2o7vj9jDxOpgjKNA7MjsAKvxbpaa1gAl+D6rT0JRitbVh+gAyCKZIq2EKMZ/hhHrYaCIgi0+z2oDr0mNq0CtfydrROhqIrTtRIxC6QXCXDZLXu8UjY6O0uTkJKXTaTmyAAMGvNEXI2aaxRYgArUzqyA36S+xhrQg/ehsQqoqIxKJUHf3b9Tc7CSns0W0nZ1dpOu6nLEUu7FekNviWVarb5IMVXAweh8yNMDUJG3rmxWLk/E4Xbx4kTyecerp6aWWFhd1dBy7Li5XqzBmfHyc3O4hOn9+mMLhiFjL8eYpeG6BI6p2AYl6h2RaBiW4jzWWaJ09RIl8iUqFPB0/3kONjU3Cw7a29iWkFWlv7xDj3CgeBd76/X5BPAc9GxzYc56gZu0dybQIivd+pupRVhujw555sSiRSFBra5tQXI3wZsKj0Nt7gkqlktBjnoDHZiSqErxyo9eK9hZryNNjsC5dKFGxUKCBgUGhpJrylYQbyqMTxzZxZIslWn8UR43XATWwVTJKqFods+Vox5ny5GAgIMJWTfFqhEeKe13J+ncHkWhHcFLU4DeSUUINDfNwKOPliT6f75aIufDcmJryCX2Wqwi3FaJoHZIROOi/Gx/8zByjk8GsmJhKpejYsU6RNNz6tQrfoqamZgqFQkJfv54DMfbZpA1LVuCnaw/hQ5TVxcht5MREDn5u+/v7xTHiYVsuJ/v66HdItTG+xuPxSE1EQ2FOzM+1dkWyAjXGvfigc49PawvE11FC5YIUi0sllS1QOldYMoaOaCsZXcFASHqs6COSFSC6DUfpMr8IbNiL5bhZie6enqdtXUFK5BZIUrCjGhxe7K9lnu9xr2SVUHUnL+wf/rG0THLYPQna0atRBsdsMRonELr9Y9TlmxP9Arzc3h2gbl9K9Bdj9zl4a+NZre+XjBJKcCe/zp5sCkOBnC3xywjK3oExcutLo5HIFqlpIkmxTNnNdL5IGy1eern9muhXwKO+0YlzXI8bS9FekYwSZv8G1OkcqwlT01RGLilDny9QPbyey5VjXmmroWcmRWcC5cpXAb+7mQLjFc1gDv0eybgIqm5jDQV6ptkglNib4mt3mL48GyYUJIE8fvgSVZIS4HOebYG3Dl6r9X2SaRkOTz+Ft1OW1URp57IrcTHe69PpgcMTZCASHNfm8vS83Uen/Dfu7cdu5IECMRsG9D8omapA0XaxZiJ2SKPvL92oiGMsmiXn1SQVpMuc+FHTBO0dNES/gh/wasFRxc2EpFL0VyXDClA1hTnL5J+cS6wY9gpGwhmKpMsR4PZ85kYW14RIOGHyL6vPK6HOUAU5XiIvYI/akCCrQQcef1tc2FP+8mjEo0/VvpMa14A641N2JJ5hdoSq1qBNMODzoSS5YMRwJE9js3m6gJZn7d4/k7TZFQEhSBuKuIkSUSTrLTxzTdpzeDPZmSWa5xkvqo8KbxSEUdHKrRnvaf684ePW2BzmH2K/ep+QGm4RNuNp8W/BGu3Ev4hJZgV5HTzkrdkYx5gLj/4PMP64XPEvYIjuZObQXtaFHDCHvhV/b/5TKKEd4oJZMxj7C/VUsbobtBdvAAAAAElFTkSuQmCC"

/***/ }),

/***/ "3bbe":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");

var String = global.String;
var TypeError = global.TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw TypeError("Can't set " + String(argument) + ' as a prototype');
};


/***/ }),

/***/ "3c16":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "3c22":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shared; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5c38");
/**
 * @module ol/style/IconImageCache
 */

/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */
var IconImageCache = /** @class */ (function () {
    function IconImageCache() {
        /**
         * @type {!Object<string, import("./IconImage.js").default>}
         * @private
         */
        this.cache_ = {};
        /**
         * @type {number}
         * @private
         */
        this.cacheSize_ = 0;
        /**
         * @type {number}
         * @private
         */
        this.maxCacheSize_ = 32;
    }
    /**
     * FIXME empty description for jsdoc
     */
    IconImageCache.prototype.clear = function () {
        this.cache_ = {};
        this.cacheSize_ = 0;
    };
    /**
     * @return {boolean} Can expire cache.
     */
    IconImageCache.prototype.canExpireCache = function () {
        return this.cacheSize_ > this.maxCacheSize_;
    };
    /**
     * FIXME empty description for jsdoc
     */
    IconImageCache.prototype.expire = function () {
        if (this.canExpireCache()) {
            var i = 0;
            for (var key in this.cache_) {
                var iconImage = this.cache_[key];
                if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                    delete this.cache_[key];
                    --this.cacheSize_;
                }
            }
        }
    };
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */
    IconImageCache.prototype.get = function (src, crossOrigin, color) {
        var key = getKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
    };
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @param {import("./IconImage.js").default} iconImage Icon image.
     */
    IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
        var key = getKey(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
    };
    /**
     * Set the cache size of the icon cache. Default is `32`. Change this value when
     * your map uses more than 32 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */
    IconImageCache.prototype.setSize = function (maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
    };
    return IconImageCache;
}());
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */
function getKey(src, crossOrigin, color) {
    var colorString = color ? Object(_color_js__WEBPACK_IMPORTED_MODULE_0__[/* asString */ "b"])(color) : 'null';
    return crossOrigin + ':' + src + ':' + colorString;
}
/* unused harmony default export */ var _unused_webpack_default_export = (IconImageCache);
/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
var shared = new IconImageCache();
//# sourceMappingURL=IconImageCache.js.map

/***/ }),

/***/ "3c81":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return calculateSourceResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return calculateSourceExtentResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return render; });
/* harmony import */ var _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0b0e");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("38f3");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0af5");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("0999");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("256f");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("7fc9");
/**
 * @module ol/reproj
 */






var brokenDiagonalRendering_;
/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */
function drawTestTriangle(ctx, u1, v1, u2, v2) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(u1, v1);
    ctx.lineTo(u2, v2);
    ctx.closePath();
    ctx.save();
    ctx.clip();
    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
    ctx.restore();
}
/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */
function verifyBrokenDiagonalRendering(data, offset) {
    // the values ought to be close to the rgba(210, 0, 0, 0.75)
    return (Math.abs(data[offset * 4] - 210) > 2 ||
        Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2);
}
/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */
function isBrokenDiagonalRendering() {
    if (brokenDiagonalRendering_ === undefined) {
        var ctx = document.createElement('canvas').getContext('2d');
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
        drawTestTriangle(ctx, 4, 5, 4, 0);
        drawTestTriangle(ctx, 4, 5, 0, 5);
        var data = ctx.getImageData(0, 0, 3, 3).data;
        brokenDiagonalRendering_ =
            verifyBrokenDiagonalRendering(data, 0) ||
                verifyBrokenDiagonalRendering(data, 4) ||
                verifyBrokenDiagonalRendering(data, 8);
    }
    return brokenDiagonalRendering_;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
    var sourceCenter = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__[/* transform */ "u"])(targetCenter, targetProj, sourceProj);
    // calculate the ideal resolution of the source data
    var sourceResolution = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__[/* getPointResolution */ "n"])(targetProj, targetResolution, targetCenter);
    var targetMetersPerUnit = targetProj.getMetersPerUnit();
    if (targetMetersPerUnit !== undefined) {
        sourceResolution *= targetMetersPerUnit;
    }
    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
    if (sourceMetersPerUnit !== undefined) {
        sourceResolution /= sourceMetersPerUnit;
    }
    // Based on the projection properties, the point resolution at the specified
    // coordinates may be slightly different. We need to reverse-compensate this
    // in order to achieve optimal results.
    var sourceExtent = sourceProj.getExtent();
    if (!sourceExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* containsCoordinate */ "f"])(sourceExtent, sourceCenter)) {
        var compensationFactor = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__[/* getPointResolution */ "n"])(sourceProj, sourceResolution, sourceCenter) /
            sourceResolution;
        if (isFinite(compensationFactor) && compensationFactor > 0) {
            sourceResolution /= compensationFactor;
        }
    }
    return sourceResolution;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
    var targetCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* getCenter */ "w"])(targetExtent);
    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* forEachCorner */ "s"])(targetExtent, function (corner) {
            sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
            return isFinite(sourceResolution) && sourceResolution > 0;
        });
    }
    return sourceResolution;
}
/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 */
/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [opt_renderEdges] Render reprojection edges.
 * @param {object} [opt_interpolate] Use linear interpolation when resampling.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_interpolate) {
    var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__[/* createCanvasContext2D */ "a"])(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
    if (!opt_interpolate) {
        Object(_obj_js__WEBPACK_IMPORTED_MODULE_1__[/* assign */ "a"])(context, _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_0__[/* IMAGE_SMOOTHING_DISABLED */ "a"]);
    }
    if (sources.length === 0) {
        return context.canvas;
    }
    context.scale(pixelRatio, pixelRatio);
    function pixelRound(value) {
        return Math.round(value * pixelRatio) / pixelRatio;
    }
    context.globalCompositeOperation = 'lighter';
    var sourceDataExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* createEmpty */ "j"])();
    sources.forEach(function (src, i, arr) {
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* extend */ "p"])(sourceDataExtent, src.extent);
    });
    var canvasWidthInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* getWidth */ "D"])(sourceDataExtent);
    var canvasHeightInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* getHeight */ "z"])(sourceDataExtent);
    var stitchContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__[/* createCanvasContext2D */ "a"])(Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution), Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution));
    if (!opt_interpolate) {
        Object(_obj_js__WEBPACK_IMPORTED_MODULE_1__[/* assign */ "a"])(stitchContext, _renderer_canvas_common_js__WEBPACK_IMPORTED_MODULE_0__[/* IMAGE_SMOOTHING_DISABLED */ "a"]);
    }
    var stitchScale = pixelRatio / sourceResolution;
    sources.forEach(function (src, i, arr) {
        var xPos = src.extent[0] - sourceDataExtent[0];
        var yPos = -(src.extent[3] - sourceDataExtent[3]);
        var srcWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* getWidth */ "D"])(src.extent);
        var srcHeight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* getHeight */ "z"])(src.extent);
        // This test should never fail -- but it does. Need to find a fix the upstream condition
        if (src.image.width > 0 && src.image.height > 0) {
            stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
        }
    });
    var targetTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* getTopLeft */ "B"])(targetExtent);
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
        /* Calculate affine transform (src -> dst)
         * Resulting matrix can be used to transform coordinate
         * from `sourceProjection` to destination pixels.
         *
         * To optimize number of context calls and increase numerical stability,
         * we also do the following operations:
         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
         * here before solving the linear system so [ui, vi] are pixel coordinates.
         *
         * Src points: xi, yi
         * Dst points: ui, vi
         * Affine coefficients: aij
         *
         * | x0 y0 1  0  0 0 |   |a00|   |u0|
         * | x1 y1 1  0  0 0 |   |a01|   |u1|
         * | x2 y2 1  0  0 0 | x |a02| = |u2|
         * |  0  0 0 x0 y0 1 |   |a10|   |v0|
         * |  0  0 0 x1 y1 1 |   |a11|   |v1|
         * |  0  0 0 x2 y2 1 |   |a12|   |v2|
         */
        var source = triangle.source;
        var target = triangle.target;
        var x0 = source[0][0], y0 = source[0][1];
        var x1 = source[1][0], y1 = source[1][1];
        var x2 = source[2][0], y2 = source[2][1];
        // Make sure that everything is on pixel boundaries
        var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
        var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
        var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
        var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
        var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
        var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
        // Shift all the source points to improve numerical stability
        // of all the subsequent calculations. The [x0, y0] is used here.
        // This is also used to simplify the linear system.
        var sourceNumericalShiftX = x0;
        var sourceNumericalShiftY = y0;
        x0 = 0;
        y0 = 0;
        x1 -= sourceNumericalShiftX;
        y1 -= sourceNumericalShiftY;
        x2 -= sourceNumericalShiftX;
        y2 -= sourceNumericalShiftY;
        var augmentedMatrix = [
            [x1, y1, 0, 0, u1 - u0],
            [x2, y2, 0, 0, u2 - u0],
            [0, 0, x1, y1, v1 - v0],
            [0, 0, x2, y2, v2 - v0],
        ];
        var affineCoefs = Object(_math_js__WEBPACK_IMPORTED_MODULE_5__[/* solveLinearSystem */ "h"])(augmentedMatrix);
        if (!affineCoefs) {
            return;
        }
        context.save();
        context.beginPath();
        if (isBrokenDiagonalRendering() || !opt_interpolate) {
            // Make sure that all lines are horizontal or vertical
            context.moveTo(u1, v1);
            // This is the diagonal line. Do it in 4 steps
            var steps = 4;
            var ud = u0 - u1;
            var vd = v0 - v1;
            for (var step = 0; step < steps; step++) {
                // Go horizontally
                context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound((step * vd) / (steps - 1)));
                // Go vertically
                if (step != steps - 1) {
                    context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound(((step + 1) * vd) / (steps - 1)));
                }
            }
            // We are almost at u0r, v0r
            context.lineTo(u2, v2);
        }
        else {
            context.moveTo(u1, v1);
            context.lineTo(u0, v0);
            context.lineTo(u2, v2);
        }
        context.clip();
        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
        context.drawImage(stitchContext.canvas, 0, 0);
        context.restore();
    });
    if (opt_renderEdges) {
        context.save();
        context.globalCompositeOperation = 'source-over';
        context.strokeStyle = 'black';
        context.lineWidth = 1;
        triangulation.getTriangles().forEach(function (triangle, i, arr) {
            var target = triangle.target;
            var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
            var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
            var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
            var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
            var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
            var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
            context.beginPath();
            context.moveTo(u1, v1);
            context.lineTo(u0, v0);
            context.lineTo(u2, v2);
            context.closePath();
            context.stroke();
        });
        context.restore();
    }
    return context.canvas;
}
//# sourceMappingURL=reproj.js.map

/***/ }),

/***/ "3c87":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "3e6b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js
var Layer = __webpack_require__("1af9");

// EXTERNAL MODULE: ./node_modules/rbush/rbush.min.js
var rbush_min = __webpack_require__("25a5");
var rbush_min_default = /*#__PURE__*/__webpack_require__.n(rbush_min);

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__("38f3");

// EXTERNAL MODULE: ./node_modules/ol/style/Style.js
var Style = __webpack_require__("6c77");

// CONCATENATED MODULE: ./node_modules/ol/layer/BaseVector.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/BaseVector
 */




/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @enum {string}
 * @private
 */
var Property = {
    RENDER_ORDER: 'renderOrder',
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */
var BaseVector_BaseVectorLayer = /** @class */ (function (_super) {
    __extends(BaseVectorLayer, _super);
    /**
     * @param {Options<VectorSourceType>} [opt_options] Options.
     */
    function BaseVectorLayer(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        var baseOptions = Object(obj["a" /* assign */])({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        _this = _super.call(this, baseOptions) || this;
        /**
         * @private
         * @type {boolean}
         */
        _this.declutter_ =
            options.declutter !== undefined ? options.declutter : false;
        /**
         * @type {number}
         * @private
         */
        _this.renderBuffer_ =
            options.renderBuffer !== undefined ? options.renderBuffer : 100;
        /**
         * User provided style.
         * @type {import("../style/Style.js").StyleLike}
         * @private
         */
        _this.style_ = null;
        /**
         * Style function for use within the library.
         * @type {import("../style/Style.js").StyleFunction|undefined}
         * @private
         */
        _this.styleFunction_ = undefined;
        _this.setStyle(options.style);
        /**
         * @type {boolean}
         * @private
         */
        _this.updateWhileAnimating_ =
            options.updateWhileAnimating !== undefined
                ? options.updateWhileAnimating
                : false;
        /**
         * @type {boolean}
         * @private
         */
        _this.updateWhileInteracting_ =
            options.updateWhileInteracting !== undefined
                ? options.updateWhileInteracting
                : false;
        return _this;
    }
    /**
     * @return {boolean} Declutter.
     */
    BaseVectorLayer.prototype.getDeclutter = function () {
        return this.declutter_;
    };
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
     * is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
     * @api
     */
    BaseVectorLayer.prototype.getFeatures = function (pixel) {
        return _super.prototype.getFeatures.call(this, pixel);
    };
    /**
     * @return {number|undefined} Render buffer.
     */
    BaseVectorLayer.prototype.getRenderBuffer = function () {
        return this.renderBuffer_;
    };
    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */
    BaseVectorLayer.prototype.getRenderOrder = function () {
        return /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property.RENDER_ORDER));
    };
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
     * @api
     */
    BaseVectorLayer.prototype.getStyle = function () {
        return this.style_;
    };
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */
    BaseVectorLayer.prototype.getStyleFunction = function () {
        return this.styleFunction_;
    };
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */
    BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
        return this.updateWhileAnimating_;
    };
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */
    BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
        return this.updateWhileInteracting_;
    };
    /**
     * Render declutter items for this layer
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     */
    BaseVectorLayer.prototype.renderDeclutter = function (frameState) {
        if (!frameState.declutterTree) {
            frameState.declutterTree = new rbush_min_default.a(9);
        }
        /** @type {*} */ (this.getRenderer()).renderDeclutter(frameState);
    };
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */
    BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
        this.set(Property.RENDER_ORDER, renderOrder);
    };
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * {@link module:ol/style/Style~Style} for information on the default style.
     * @param {import("../style/Style.js").StyleLike|null} [opt_style] Layer style.
     * @api
     */
    BaseVectorLayer.prototype.setStyle = function (opt_style) {
        this.style_ = opt_style !== undefined ? opt_style : Style["a" /* createDefaultStyle */];
        this.styleFunction_ =
            opt_style === null ? undefined : Object(Style["d" /* toFunction */])(this.style_);
        this.changed();
    };
    return BaseVectorLayer;
}(Layer["a" /* default */]));
/* harmony default export */ var BaseVector = (BaseVector_BaseVectorLayer);
//# sourceMappingURL=BaseVector.js.map
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Instruction.js
/**
 * @module ol/render/canvas/Instruction
 */
/**
 * @enum {number}
 */
var Instruction = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12,
};
/**
 * @type {Array<Instruction>}
 */
var Instruction_fillInstruction = [Instruction.FILL];
/**
 * @type {Array<Instruction>}
 */
var Instruction_strokeInstruction = [Instruction.STROKE];
/**
 * @type {Array<Instruction>}
 */
var beginPathInstruction = [Instruction.BEGIN_PATH];
/**
 * @type {Array<Instruction>}
 */
var closePathInstruction = [Instruction.CLOSE_PATH];
/* harmony default export */ var canvas_Instruction = (Instruction);
//# sourceMappingURL=Instruction.js.map
// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js
var GeometryType = __webpack_require__("f623");

// EXTERNAL MODULE: ./node_modules/ol/extent/Relationship.js
var Relationship = __webpack_require__("045d");

// CONCATENATED MODULE: ./node_modules/ol/render/VectorContext.js
/**
 * @module ol/render/VectorContext
 */
/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext = /** @class */ (function () {
    function VectorContext() {
    }
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */
    VectorContext.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) { };
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */
    VectorContext.prototype.drawGeometry = function (geometry) { };
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */
    VectorContext.prototype.setStyle = function (style) { };
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     */
    VectorContext.prototype.drawCircle = function (circleGeometry, feature) { };
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     */
    VectorContext.prototype.drawFeature = function (feature, style) { };
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     */
    VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) { };
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) { };
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) { };
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) { };
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) { };
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    VectorContext.prototype.drawPoint = function (pointGeometry, feature) { };
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) { };
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    VectorContext.prototype.drawText = function (geometry, feature) { };
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */
    VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) { };
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [opt_declutterImageWithText] Shared data for combined decluttering with a text style.
     */
    VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterImageWithText) { };
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [opt_declutterImageWithText] Shared data for combined decluttering with an image style.
     */
    VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterImageWithText) { };
    return VectorContext;
}());
/* harmony default export */ var render_VectorContext = (VectorContext);
//# sourceMappingURL=VectorContext.js.map
// EXTERNAL MODULE: ./node_modules/ol/colorlike.js
var colorlike = __webpack_require__("e98d");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js
var render_canvas = __webpack_require__("ddea");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js
var inflate = __webpack_require__("bb6c");

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Builder.js
var Builder_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/render/canvas/Builder
 */









var Builder_CanvasBuilder = /** @class */ (function (_super) {
    Builder_extends(CanvasBuilder, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {number}
         */
        _this.tolerance = tolerance;
        /**
         * @protected
         * @const
         * @type {import("../../extent.js").Extent}
         */
        _this.maxExtent = maxExtent;
        /**
         * @protected
         * @type {number}
         */
        _this.pixelRatio = pixelRatio;
        /**
         * @protected
         * @type {number}
         */
        _this.maxLineWidth = 0;
        /**
         * @protected
         * @const
         * @type {number}
         */
        _this.resolution = resolution;
        /**
         * @private
         * @type {Array<*>}
         */
        _this.beginGeometryInstruction1_ = null;
        /**
         * @private
         * @type {Array<*>}
         */
        _this.beginGeometryInstruction2_ = null;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */
        _this.bufferedMaxExtent_ = null;
        /**
         * @protected
         * @type {Array<*>}
         */
        _this.instructions = [];
        /**
         * @protected
         * @type {Array<number>}
         */
        _this.coordinates = [];
        /**
         * @private
         * @type {import("../../coordinate.js").Coordinate}
         */
        _this.tmpCoordinate_ = [];
        /**
         * @protected
         * @type {Array<*>}
         */
        _this.hitDetectionInstructions = [];
        /**
         * @protected
         * @type {import("../canvas.js").FillStrokeState}
         */
        _this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});
        return _this;
    }
    /**
     * @protected
     * @param {Array<number>} dashArray Dash array.
     * @return {Array<number>} Dash array with pixel ratio applied
     */
    CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
        var pixelRatio = this.pixelRatio;
        return pixelRatio == 1
            ? dashArray
            : dashArray.map(function (dash) {
                return dash * pixelRatio;
            });
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */
    CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {
        var extent = this.getBufferedMaxExtent();
        var tmpCoord = this.tmpCoordinate_;
        var coordinates = this.coordinates;
        var myEnd = coordinates.length;
        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
            tmpCoord[0] = flatCoordinates[i];
            tmpCoord[1] = flatCoordinates[i + 1];
            if (Object(ol_extent["f" /* containsCoordinate */])(extent, tmpCoord)) {
                coordinates[myEnd++] = tmpCoord[0];
                coordinates[myEnd++] = tmpCoord[1];
            }
        }
        return myEnd;
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */
    CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
        var coordinates = this.coordinates;
        var myEnd = coordinates.length;
        var extent = this.getBufferedMaxExtent();
        if (skipFirst) {
            offset += stride;
        }
        var lastXCoord = flatCoordinates[offset];
        var lastYCoord = flatCoordinates[offset + 1];
        var nextCoord = this.tmpCoordinate_;
        var skipped = true;
        var i, lastRel, nextRel;
        for (i = offset + stride; i < end; i += stride) {
            nextCoord[0] = flatCoordinates[i];
            nextCoord[1] = flatCoordinates[i + 1];
            nextRel = Object(ol_extent["i" /* coordinateRelationship */])(extent, nextCoord);
            if (nextRel !== lastRel) {
                if (skipped) {
                    coordinates[myEnd++] = lastXCoord;
                    coordinates[myEnd++] = lastYCoord;
                    skipped = false;
                }
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
            }
            else if (nextRel === Relationship["a" /* default */].INTERSECTING) {
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
                skipped = false;
            }
            else {
                skipped = true;
            }
            lastXCoord = nextCoord[0];
            lastYCoord = nextCoord[1];
            lastRel = nextRel;
        }
        // Last coordinate equals first or only one point to append:
        if ((closed && skipped) || i === offset + stride) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
        }
        return myEnd;
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */
    CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            builderEnds.push(builderEnd);
            offset = end;
        }
        return offset;
    };
    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */
    CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer, hitDetectionRenderer) {
        this.beginGeometry(geometry, feature);
        var type = geometry.getType();
        var stride = geometry.getStride();
        var builderBegin = this.coordinates.length;
        var flatCoordinates, builderEnd, builderEnds, builderEndss;
        var offset;
        switch (type) {
            case GeometryType["a" /* default */].MULTI_POLYGON:
                flatCoordinates =
                    /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getOrientedFlatCoordinates();
                builderEndss = [];
                var endss = 
                /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
                offset = 0;
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                    var myEnds = [];
                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                    builderEndss.push(myEnds);
                }
                this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    renderer,
                    inflate["c" /* inflateMultiCoordinatesArray */],
                ]);
                this.hitDetectionInstructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    hitDetectionRenderer || renderer,
                    inflate["c" /* inflateMultiCoordinatesArray */],
                ]);
                break;
            case GeometryType["a" /* default */].POLYGON:
            case GeometryType["a" /* default */].MULTI_LINE_STRING:
                builderEnds = [];
                flatCoordinates =
                    type == GeometryType["a" /* default */].POLYGON
                        ? /** @type {import("../../geom/Polygon.js").default} */ (geometry).getOrientedFlatCoordinates()
                        : geometry.getFlatCoordinates();
                offset = this.drawCustomCoordinates_(flatCoordinates, 0, 
                /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (geometry).getEnds(), stride, builderEnds);
                this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    renderer,
                    inflate["b" /* inflateCoordinatesArray */],
                ]);
                this.hitDetectionInstructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    hitDetectionRenderer || renderer,
                    inflate["b" /* inflateCoordinatesArray */],
                ]);
                break;
            case GeometryType["a" /* default */].LINE_STRING:
            case GeometryType["a" /* default */].CIRCLE:
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    inflate["a" /* inflateCoordinates */],
                ]);
                this.hitDetectionInstructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer,
                    inflate["a" /* inflateCoordinates */],
                ]);
                break;
            case GeometryType["a" /* default */].MULTI_POINT:
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (builderEnd > builderBegin) {
                    this.instructions.push([
                        canvas_Instruction.CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        renderer,
                        inflate["a" /* inflateCoordinates */],
                    ]);
                    this.hitDetectionInstructions.push([
                        canvas_Instruction.CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        hitDetectionRenderer || renderer,
                        inflate["a" /* inflateCoordinates */],
                    ]);
                }
                break;
            case GeometryType["a" /* default */].POINT:
                flatCoordinates = geometry.getFlatCoordinates();
                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                builderEnd = this.coordinates.length;
                this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                ]);
                this.hitDetectionInstructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer,
                ]);
                break;
            default:
        }
        this.endGeometry(feature);
    };
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
        this.beginGeometryInstruction1_ = [
            canvas_Instruction.BEGIN_GEOMETRY,
            feature,
            0,
            geometry,
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
            canvas_Instruction.BEGIN_GEOMETRY,
            feature,
            0,
            geometry,
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    CanvasBuilder.prototype.finish = function () {
        return {
            instructions: this.instructions,
            hitDetectionInstructions: this.hitDetectionInstructions,
            coordinates: this.coordinates,
        };
    };
    /**
     * Reverse the hit detection instructions.
     */
    CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
        var hitDetectionInstructions = this.hitDetectionInstructions;
        // step 1 - reverse array
        hitDetectionInstructions.reverse();
        // step 2 - reverse instructions within geometry blocks
        var i;
        var n = hitDetectionInstructions.length;
        var instruction;
        var type;
        var begin = -1;
        for (i = 0; i < n; ++i) {
            instruction = hitDetectionInstructions[i];
            type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
            if (type == canvas_Instruction.END_GEOMETRY) {
                begin = i;
            }
            else if (type == canvas_Instruction.BEGIN_GEOMETRY) {
                instruction[2] = i;
                Object(array["h" /* reverseSubArray */])(this.hitDetectionInstructions, begin, i);
                begin = -1;
            }
        }
    };
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */
    CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
        var state = this.state;
        if (fillStyle) {
            var fillStyleColor = fillStyle.getColor();
            state.fillStyle = Object(colorlike["a" /* asColorLike */])(fillStyleColor ? fillStyleColor : render_canvas["b" /* defaultFillStyle */]);
        }
        else {
            state.fillStyle = undefined;
        }
        if (strokeStyle) {
            var strokeStyleColor = strokeStyle.getColor();
            state.strokeStyle = Object(colorlike["a" /* asColorLike */])(strokeStyleColor ? strokeStyleColor : render_canvas["k" /* defaultStrokeStyle */]);
            var strokeStyleLineCap = strokeStyle.getLineCap();
            state.lineCap =
                strokeStyleLineCap !== undefined ? strokeStyleLineCap : render_canvas["d" /* defaultLineCap */];
            var strokeStyleLineDash = strokeStyle.getLineDash();
            state.lineDash = strokeStyleLineDash
                ? strokeStyleLineDash.slice()
                : render_canvas["e" /* defaultLineDash */];
            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            state.lineDashOffset = strokeStyleLineDashOffset
                ? strokeStyleLineDashOffset
                : render_canvas["f" /* defaultLineDashOffset */];
            var strokeStyleLineJoin = strokeStyle.getLineJoin();
            state.lineJoin =
                strokeStyleLineJoin !== undefined
                    ? strokeStyleLineJoin
                    : render_canvas["g" /* defaultLineJoin */];
            var strokeStyleWidth = strokeStyle.getWidth();
            state.lineWidth =
                strokeStyleWidth !== undefined ? strokeStyleWidth : render_canvas["h" /* defaultLineWidth */];
            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            state.miterLimit =
                strokeStyleMiterLimit !== undefined
                    ? strokeStyleMiterLimit
                    : render_canvas["i" /* defaultMiterLimit */];
            if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                // invalidate the buffered max extent cache
                this.bufferedMaxExtent_ = null;
            }
        }
        else {
            state.strokeStyle = undefined;
            state.lineCap = undefined;
            state.lineDash = null;
            state.lineDashOffset = undefined;
            state.lineJoin = undefined;
            state.lineWidth = undefined;
            state.miterLimit = undefined;
        }
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */
    CanvasBuilder.prototype.createFill = function (state) {
        var fillStyle = state.fillStyle;
        /** @type {Array<*>} */
        var fillInstruction = [canvas_Instruction.SET_FILL_STYLE, fillStyle];
        if (typeof fillStyle !== 'string') {
            // Fill is a pattern or gradient - align it!
            fillInstruction.push(true);
        }
        return fillInstruction;
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    CanvasBuilder.prototype.applyStroke = function (state) {
        this.instructions.push(this.createStroke(state));
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */
    CanvasBuilder.prototype.createStroke = function (state) {
        return [
            canvas_Instruction.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth * this.pixelRatio,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            this.applyPixelRatio(state.lineDash),
            state.lineDashOffset * this.pixelRatio,
        ];
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */
    CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
        var fillStyle = state.fillStyle;
        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
            if (fillStyle !== undefined) {
                this.instructions.push(createFill.call(this, state));
            }
            state.currentFillStyle = fillStyle;
        }
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */
    CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
        var strokeStyle = state.strokeStyle;
        var lineCap = state.lineCap;
        var lineDash = state.lineDash;
        var lineDashOffset = state.lineDashOffset;
        var lineJoin = state.lineJoin;
        var lineWidth = state.lineWidth;
        var miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle ||
            state.currentLineCap != lineCap ||
            (lineDash != state.currentLineDash &&
                !Object(array["b" /* equals */])(state.currentLineDash, lineDash)) ||
            state.currentLineDashOffset != lineDashOffset ||
            state.currentLineJoin != lineJoin ||
            state.currentLineWidth != lineWidth ||
            state.currentMiterLimit != miterLimit) {
            if (strokeStyle !== undefined) {
                applyStroke.call(this, state);
            }
            state.currentStrokeStyle = strokeStyle;
            state.currentLineCap = lineCap;
            state.currentLineDash = lineDash;
            state.currentLineDashOffset = lineDashOffset;
            state.currentLineJoin = lineJoin;
            state.currentLineWidth = lineWidth;
            state.currentMiterLimit = miterLimit;
        }
    };
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasBuilder.prototype.endGeometry = function (feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        var endGeometryInstruction = [canvas_Instruction.END_GEOMETRY, feature];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
    };
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */
    CanvasBuilder.prototype.getBufferedMaxExtent = function () {
        if (!this.bufferedMaxExtent_) {
            this.bufferedMaxExtent_ = Object(ol_extent["d" /* clone */])(this.maxExtent);
            if (this.maxLineWidth > 0) {
                var width = (this.resolution * (this.maxLineWidth + 1)) / 2;
                Object(ol_extent["c" /* buffer */])(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
            }
        }
        return this.bufferedMaxExtent_;
    };
    return CanvasBuilder;
}(render_VectorContext));
/* harmony default export */ var Builder = (Builder_CanvasBuilder);
//# sourceMappingURL=Builder.js.map
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/ImageBuilder.js
var ImageBuilder_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/render/canvas/ImageBuilder
 */


var ImageBuilder_CanvasImageBuilder = /** @class */ (function (_super) {
    ImageBuilder_extends(CanvasImageBuilder, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
        var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */
        _this.hitDetectionImage_ = null;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */
        _this.image_ = null;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.imagePixelRatio_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.anchorX_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.anchorY_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.height_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.opacity_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.originX_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.originY_ = undefined;
        /**
         * @private
         * @type {boolean|undefined}
         */
        _this.rotateWithView_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.rotation_ = undefined;
        /**
         * @private
         * @type {import("../../size.js").Size|undefined}
         */
        _this.scale_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.width_ = undefined;
        /**
         * Data shared with a text builder for combined decluttering.
         * @private
         * @type {import("../canvas.js").DeclutterImageWithText}
         */
        _this.declutterImageWithText_ = undefined;
        return _this;
    }
    /**
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
        if (!this.image_) {
            return;
        }
        this.beginGeometry(pointGeometry, feature);
        var flatCoordinates = pointGeometry.getFlatCoordinates();
        var stride = pointGeometry.getStride();
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            canvas_Instruction.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            [
                (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterImageWithText_,
        ]);
        this.hitDetectionInstructions.push([
            canvas_Instruction.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterImageWithText_,
        ]);
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
        if (!this.image_) {
            return;
        }
        this.beginGeometry(multiPointGeometry, feature);
        var flatCoordinates = multiPointGeometry.getFlatCoordinates();
        var stride = multiPointGeometry.getStride();
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            canvas_Instruction.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            [
                (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterImageWithText_,
        ]);
        this.hitDetectionInstructions.push([
            canvas_Instruction.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterImageWithText_,
        ]);
        this.endGeometry(feature);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    CanvasImageBuilder.prototype.finish = function () {
        this.reverseHitDetectionInstructions();
        // FIXME this doesn't really protect us against further calls to draw*Geometry
        this.anchorX_ = undefined;
        this.anchorY_ = undefined;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = undefined;
        this.height_ = undefined;
        this.scale_ = undefined;
        this.opacity_ = undefined;
        this.originX_ = undefined;
        this.originY_ = undefined;
        this.rotateWithView_ = undefined;
        this.rotation_ = undefined;
        this.width_ = undefined;
        return _super.prototype.finish.call(this);
    };
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [opt_sharedData] Shared data.
     */
    CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, opt_sharedData) {
        var anchor = imageStyle.getAnchor();
        var size = imageStyle.getSize();
        var hitDetectionImage = imageStyle.getHitDetectionImage();
        var image = imageStyle.getImage(this.pixelRatio);
        var origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = hitDetectionImage;
        this.image_ = image;
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0] * this.imagePixelRatio_;
        this.originY_ = origin[1] * this.imagePixelRatio_;
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterImageWithText_ = opt_sharedData;
    };
    return CanvasImageBuilder;
}(Builder));
/* harmony default export */ var ImageBuilder = (ImageBuilder_CanvasImageBuilder);
//# sourceMappingURL=ImageBuilder.js.map
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/LineStringBuilder.js
var LineStringBuilder_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/render/canvas/LineStringBuilder
 */



var LineStringBuilder_CanvasLineStringBuilder = /** @class */ (function (_super) {
    LineStringBuilder_extends(CanvasLineStringBuilder, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
        return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     * @return {number} end.
     */
    CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        var moveToLineToInstruction = [
            canvas_Instruction.MOVE_TO_LINE_TO,
            myBegin,
            myEnd,
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
    };
    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
        var state = this.state;
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) {
            return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            canvas_Instruction.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            render_canvas["e" /* defaultLineDash */],
            render_canvas["f" /* defaultLineDashOffset */],
        ], beginPathInstruction);
        var flatCoordinates = lineStringGeometry.getFlatCoordinates();
        var stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
        this.hitDetectionInstructions.push(Instruction_strokeInstruction);
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
        var state = this.state;
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) {
            return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            canvas_Instruction.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset,
        ], beginPathInstruction);
        var ends = multiLineStringGeometry.getEnds();
        var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        var stride = multiLineStringGeometry.getStride();
        var offset = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            offset = this.drawFlatCoordinates_(flatCoordinates, offset, 
            /** @type {number} */ (ends[i]), stride);
        }
        this.hitDetectionInstructions.push(Instruction_strokeInstruction);
        this.endGeometry(feature);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    CanvasLineStringBuilder.prototype.finish = function () {
        var state = this.state;
        if (state.lastStroke != undefined &&
            state.lastStroke != this.coordinates.length) {
            this.instructions.push(Instruction_strokeInstruction);
        }
        this.reverseHitDetectionInstructions();
        this.state = null;
        return _super.prototype.finish.call(this);
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    CanvasLineStringBuilder.prototype.applyStroke = function (state) {
        if (state.lastStroke != undefined &&
            state.lastStroke != this.coordinates.length) {
            this.instructions.push(Instruction_strokeInstruction);
            state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        _super.prototype.applyStroke.call(this, state);
        this.instructions.push(beginPathInstruction);
    };
    return CanvasLineStringBuilder;
}(Builder));
/* harmony default export */ var LineStringBuilder = (LineStringBuilder_CanvasLineStringBuilder);
//# sourceMappingURL=LineStringBuilder.js.map
// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js
var simplify = __webpack_require__("1c48");

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/PolygonBuilder.js
var PolygonBuilder_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/render/canvas/PolygonBuilder
 */




var PolygonBuilder_CanvasPolygonBuilder = /** @class */ (function (_super) {
    PolygonBuilder_extends(CanvasPolygonBuilder, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
        return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
        var state = this.state;
        var fill = state.fillStyle !== undefined;
        var stroke = state.strokeStyle !== undefined;
        var numEnds = ends.length;
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (var i = 0; i < numEnds; ++i) {
            var end = ends[i];
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
            var moveToLineToInstruction = [
                canvas_Instruction.MOVE_TO_LINE_TO,
                myBegin,
                myEnd,
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            if (stroke) {
                // Performance optimization: only call closePath() when we have a stroke.
                // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
                this.instructions.push(closePathInstruction);
                this.hitDetectionInstructions.push(closePathInstruction);
            }
            offset = end;
        }
        if (fill) {
            this.instructions.push(Instruction_fillInstruction);
            this.hitDetectionInstructions.push(Instruction_fillInstruction);
        }
        if (stroke) {
            this.instructions.push(Instruction_strokeInstruction);
            this.hitDetectionInstructions.push(Instruction_strokeInstruction);
        }
        return offset;
    };
    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     */
    CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) {
            return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== undefined) {
            this.hitDetectionInstructions.push([
                canvas_Instruction.SET_FILL_STYLE,
                render_canvas["b" /* defaultFillStyle */],
            ]);
        }
        if (state.strokeStyle !== undefined) {
            this.hitDetectionInstructions.push([
                canvas_Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset,
            ]);
        }
        var flatCoordinates = circleGeometry.getFlatCoordinates();
        var stride = circleGeometry.getStride();
        var myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        var circleInstruction = [canvas_Instruction.CIRCLE, myBegin];
        this.instructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
        if (state.fillStyle !== undefined) {
            this.instructions.push(Instruction_fillInstruction);
            this.hitDetectionInstructions.push(Instruction_fillInstruction);
        }
        if (state.strokeStyle !== undefined) {
            this.instructions.push(Instruction_strokeInstruction);
            this.hitDetectionInstructions.push(Instruction_strokeInstruction);
        }
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) {
            return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== undefined) {
            this.hitDetectionInstructions.push([
                canvas_Instruction.SET_FILL_STYLE,
                render_canvas["b" /* defaultFillStyle */],
            ]);
        }
        if (state.strokeStyle !== undefined) {
            this.hitDetectionInstructions.push([
                canvas_Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset,
            ]);
        }
        var ends = polygonGeometry.getEnds();
        var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        var stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(flatCoordinates, 0, 
        /** @type {Array<number>} */ (ends), stride);
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) {
            return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== undefined) {
            this.hitDetectionInstructions.push([
                canvas_Instruction.SET_FILL_STYLE,
                render_canvas["b" /* defaultFillStyle */],
            ]);
        }
        if (state.strokeStyle !== undefined) {
            this.hitDetectionInstructions.push([
                canvas_Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset,
            ]);
        }
        var endss = multiPolygonGeometry.getEndss();
        var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        var stride = multiPolygonGeometry.getStride();
        var offset = 0;
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
        }
        this.endGeometry(feature);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    CanvasPolygonBuilder.prototype.finish = function () {
        this.reverseHitDetectionInstructions();
        this.state = null;
        // We want to preserve topology when drawing polygons.  Polygons are
        // simplified using quantization and point elimination. However, we might
        // have received a mix of quantized and non-quantized geometries, so ensure
        // that all are quantized by quantizing all coordinates in the batch.
        var tolerance = this.tolerance;
        if (tolerance !== 0) {
            var coordinates = this.coordinates;
            for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                coordinates[i] = Object(simplify["e" /* snap */])(coordinates[i], tolerance);
            }
        }
        return _super.prototype.finish.call(this);
    };
    /**
     * @private
     */
    CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
        var state = this.state;
        var fillStyle = state.fillStyle;
        if (fillStyle !== undefined) {
            this.updateFillStyle(state, this.createFill);
        }
        if (state.strokeStyle !== undefined) {
            this.updateStrokeStyle(state, this.applyStroke);
        }
    };
    return CanvasPolygonBuilder;
}(Builder));
/* harmony default export */ var PolygonBuilder = (PolygonBuilder_CanvasPolygonBuilder);
//# sourceMappingURL=PolygonBuilder.js.map
// EXTERNAL MODULE: ./node_modules/ol/style/TextPlacement.js
var TextPlacement = __webpack_require__("29f6");

// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/straightchunk.js
/**
 * @module ol/geom/flat/straightchunk
 */
/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
    var chunkStart = offset;
    var chunkEnd = offset;
    var chunkM = 0;
    var m = 0;
    var start = offset;
    var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
    for (i = offset; i < end; i += stride) {
        var x2 = flatCoordinates[i];
        var y2 = flatCoordinates[i + 1];
        if (x1 !== undefined) {
            x23 = x2 - x1;
            y23 = y2 - y1;
            m23 = Math.sqrt(x23 * x23 + y23 * y23);
            if (x12 !== undefined) {
                m += m12;
                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                if (acos > maxAngle) {
                    if (m > chunkM) {
                        chunkM = m;
                        chunkStart = start;
                        chunkEnd = i;
                    }
                    m = 0;
                    start = i - stride;
                }
            }
            m12 = m23;
            x12 = x23;
            y12 = y23;
        }
        x1 = x2;
        y1 = y2;
    }
    m += m23;
    return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
//# sourceMappingURL=straightchunk.js.map
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/TextBuilder.js
var TextBuilder_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/render/canvas/TextBuilder
 */









/**
 * @const
 * @enum {number}
 */
var TEXT_ALIGN = {
    'left': 0,
    'end': 0,
    'center': 0.5,
    'right': 1,
    'start': 1,
    'top': 0,
    'middle': 0.5,
    'hanging': 0.2,
    'alphabetic': 0.8,
    'ideographic': 0.8,
    'bottom': 1,
};
var TextBuilder_CanvasTextBuilder = /** @class */ (function (_super) {
    TextBuilder_extends(CanvasTextBuilder, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
        var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
        /**
         * @private
         * @type {Array<HTMLCanvasElement>}
         */
        _this.labels_ = null;
        /**
         * @private
         * @type {string|Array<string>}
         */
        _this.text_ = '';
        /**
         * @private
         * @type {number}
         */
        _this.textOffsetX_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.textOffsetY_ = 0;
        /**
         * @private
         * @type {boolean|undefined}
         */
        _this.textRotateWithView_ = undefined;
        /**
         * @private
         * @type {number}
         */
        _this.textRotation_ = 0;
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */
        _this.textFillState_ = null;
        /**
         * @type {!Object<string, import("../canvas.js").FillState>}
         */
        _this.fillStates = {};
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */
        _this.textStrokeState_ = null;
        /**
         * @type {!Object<string, import("../canvas.js").StrokeState>}
         */
        _this.strokeStates = {};
        /**
         * @private
         * @type {import("../canvas.js").TextState}
         */
        _this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});
        /**
         * @type {!Object<string, import("../canvas.js").TextState>}
         */
        _this.textStates = {};
        /**
         * @private
         * @type {string}
         */
        _this.textKey_ = '';
        /**
         * @private
         * @type {string}
         */
        _this.fillKey_ = '';
        /**
         * @private
         * @type {string}
         */
        _this.strokeKey_ = '';
        /**
         * Data shared with an image builder for combined decluttering.
         * @private
         * @type {import("../canvas.js").DeclutterImageWithText}
         */
        _this.declutterImageWithText_ = undefined;
        return _this;
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    CanvasTextBuilder.prototype.finish = function () {
        var instructions = _super.prototype.finish.call(this);
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
    };
    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
        var fillState = this.textFillState_;
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
            return;
        }
        var coordinates = this.coordinates;
        var begin = coordinates.length;
        var geometryType = geometry.getType();
        var flatCoordinates = null;
        var stride = geometry.getStride();
        if (textState.placement === TextPlacement["a" /* default */].LINE &&
            (geometryType == GeometryType["a" /* default */].LINE_STRING ||
                geometryType == GeometryType["a" /* default */].MULTI_LINE_STRING ||
                geometryType == GeometryType["a" /* default */].POLYGON ||
                geometryType == GeometryType["a" /* default */].MULTI_POLYGON)) {
            if (!Object(ol_extent["E" /* intersects */])(this.getBufferedMaxExtent(), geometry.getExtent())) {
                return;
            }
            var ends = void 0;
            flatCoordinates = geometry.getFlatCoordinates();
            if (geometryType == GeometryType["a" /* default */].LINE_STRING) {
                ends = [flatCoordinates.length];
            }
            else if (geometryType == GeometryType["a" /* default */].MULTI_LINE_STRING) {
                ends = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getEnds();
            }
            else if (geometryType == GeometryType["a" /* default */].POLYGON) {
                ends = /** @type {import("../../geom/Polygon.js").default} */ (geometry)
                    .getEnds()
                    .slice(0, 1);
            }
            else if (geometryType == GeometryType["a" /* default */].MULTI_POLYGON) {
                var endss = 
                /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
                ends = [];
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                    ends.push(endss[i][0]);
                }
            }
            this.beginGeometry(geometry, feature);
            var textAlign = textState.textAlign;
            var flatOffset = 0;
            var flatEnd = void 0;
            for (var o = 0, oo = ends.length; o < oo; ++o) {
                if (textAlign == undefined) {
                    var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                    flatOffset = range[0];
                    flatEnd = range[1];
                }
                else {
                    flatEnd = ends[o];
                }
                for (var i = flatOffset; i < flatEnd; i += stride) {
                    coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                }
                var end = coordinates.length;
                flatOffset = ends[o];
                this.drawChars_(begin, end);
                begin = end;
            }
            this.endGeometry(feature);
        }
        else {
            var geometryWidths = textState.overflow ? null : [];
            switch (geometryType) {
                case GeometryType["a" /* default */].POINT:
                case GeometryType["a" /* default */].MULTI_POINT:
                    flatCoordinates =
                        /** @type {import("../../geom/MultiPoint.js").default} */ (geometry).getFlatCoordinates();
                    break;
                case GeometryType["a" /* default */].LINE_STRING:
                    flatCoordinates =
                        /** @type {import("../../geom/LineString.js").default} */ (geometry).getFlatMidpoint();
                    break;
                case GeometryType["a" /* default */].CIRCLE:
                    flatCoordinates =
                        /** @type {import("../../geom/Circle.js").default} */ (geometry).getCenter();
                    break;
                case GeometryType["a" /* default */].MULTI_LINE_STRING:
                    flatCoordinates =
                        /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getFlatMidpoints();
                    stride = 2;
                    break;
                case GeometryType["a" /* default */].POLYGON:
                    flatCoordinates =
                        /** @type {import("../../geom/Polygon.js").default} */ (geometry).getFlatInteriorPoint();
                    if (!textState.overflow) {
                        geometryWidths.push(flatCoordinates[2] / this.resolution);
                    }
                    stride = 3;
                    break;
                case GeometryType["a" /* default */].MULTI_POLYGON:
                    var interiorPoints = 
                    /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getFlatInteriorPoints();
                    flatCoordinates = [];
                    for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                        if (!textState.overflow) {
                            geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                        }
                        flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                    }
                    if (flatCoordinates.length === 0) {
                        return;
                    }
                    stride = 2;
                    break;
                default:
            }
            var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (end === begin) {
                return;
            }
            if (geometryWidths &&
                (end - begin) / 2 !== flatCoordinates.length / stride) {
                var beg_1 = begin / 2;
                geometryWidths = geometryWidths.filter(function (w, i) {
                    var keep = coordinates[(beg_1 + i) * 2] === flatCoordinates[i * stride] &&
                        coordinates[(beg_1 + i) * 2 + 1] === flatCoordinates[i * stride + 1];
                    if (!keep) {
                        --beg_1;
                    }
                    return keep;
                });
            }
            this.saveTextStates_();
            if (textState.backgroundFill || textState.backgroundStroke) {
                this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                if (textState.backgroundFill) {
                    this.updateFillStyle(this.state, this.createFill);
                    this.hitDetectionInstructions.push(this.createFill(this.state));
                }
                if (textState.backgroundStroke) {
                    this.updateStrokeStyle(this.state, this.applyStroke);
                    this.hitDetectionInstructions.push(this.createStroke(this.state));
                }
            }
            this.beginGeometry(geometry, feature);
            // adjust padding for negative scale
            var padding = textState.padding;
            if (padding != render_canvas["j" /* defaultPadding */] &&
                (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                var p0 = textState.padding[0];
                var p1 = textState.padding[1];
                var p2 = textState.padding[2];
                var p3 = textState.padding[3];
                if (textState.scale[0] < 0) {
                    p1 = -p1;
                    p3 = -p3;
                }
                if (textState.scale[1] < 0) {
                    p0 = -p0;
                    p2 = -p2;
                }
                padding = [p0, p1, p2, p3];
            }
            // The image is unknown at this stage so we pass null; it will be computed at render time.
            // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
            // render time.
            var pixelRatio_1 = this.pixelRatio;
            this.instructions.push([
                canvas_Instruction.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [1, 1],
                NaN,
                this.declutterImageWithText_,
                padding == render_canvas["j" /* defaultPadding */]
                    ? render_canvas["j" /* defaultPadding */]
                    : padding.map(function (p) {
                        return p * pixelRatio_1;
                    }),
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths,
            ]);
            var scale = 1 / pixelRatio_1;
            this.hitDetectionInstructions.push([
                canvas_Instruction.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [scale, scale],
                NaN,
                this.declutterImageWithText_,
                padding,
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths,
            ]);
            this.endGeometry(feature);
        }
    };
    /**
     * @private
     */
    CanvasTextBuilder.prototype.saveTextStates_ = function () {
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        var fillState = this.textFillState_;
        var strokeKey = this.strokeKey_;
        if (strokeState) {
            if (!(strokeKey in this.strokeStates)) {
                this.strokeStates[strokeKey] = {
                    strokeStyle: strokeState.strokeStyle,
                    lineCap: strokeState.lineCap,
                    lineDashOffset: strokeState.lineDashOffset,
                    lineWidth: strokeState.lineWidth,
                    lineJoin: strokeState.lineJoin,
                    miterLimit: strokeState.miterLimit,
                    lineDash: strokeState.lineDash,
                };
            }
        }
        var textKey = this.textKey_;
        if (!(textKey in this.textStates)) {
            this.textStates[textKey] = {
                font: textState.font,
                textAlign: textState.textAlign || render_canvas["l" /* defaultTextAlign */],
                textBaseline: textState.textBaseline || render_canvas["m" /* defaultTextBaseline */],
                scale: textState.scale,
            };
        }
        var fillKey = this.fillKey_;
        if (fillState) {
            if (!(fillKey in this.fillStates)) {
                this.fillStates[fillKey] = {
                    fillStyle: fillState.fillStyle,
                };
            }
        }
    };
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */
    CanvasTextBuilder.prototype.drawChars_ = function (begin, end) {
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        var strokeKey = this.strokeKey_;
        var textKey = this.textKey_;
        var fillKey = this.fillKey_;
        this.saveTextStates_();
        var pixelRatio = this.pixelRatio;
        var baseline = TEXT_ALIGN[textState.textBaseline];
        var offsetY = this.textOffsetY_ * pixelRatio;
        var text = this.text_;
        var strokeWidth = strokeState
            ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2
            : 0;
        this.instructions.push([
            canvas_Instruction.DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            pixelRatio,
            offsetY,
            strokeKey,
            strokeWidth * pixelRatio,
            text,
            textKey,
            1,
        ]);
        this.hitDetectionInstructions.push([
            canvas_Instruction.DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            1,
            offsetY,
            strokeKey,
            strokeWidth,
            text,
            textKey,
            1 / pixelRatio,
        ]);
    };
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [opt_sharedData] Shared data.
     */
    CanvasTextBuilder.prototype.setTextStyle = function (textStyle, opt_sharedData) {
        var textState, fillState, strokeState;
        if (!textStyle) {
            this.text_ = '';
        }
        else {
            var textFillStyle = textStyle.getFill();
            if (!textFillStyle) {
                fillState = null;
                this.textFillState_ = fillState;
            }
            else {
                fillState = this.textFillState_;
                if (!fillState) {
                    fillState = /** @type {import("../canvas.js").FillState} */ ({});
                    this.textFillState_ = fillState;
                }
                fillState.fillStyle = Object(colorlike["a" /* asColorLike */])(textFillStyle.getColor() || render_canvas["b" /* defaultFillStyle */]);
            }
            var textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) {
                strokeState = null;
                this.textStrokeState_ = strokeState;
            }
            else {
                strokeState = this.textStrokeState_;
                if (!strokeState) {
                    strokeState = /** @type {import("../canvas.js").StrokeState} */ ({});
                    this.textStrokeState_ = strokeState;
                }
                var lineDash = textStrokeStyle.getLineDash();
                var lineDashOffset = textStrokeStyle.getLineDashOffset();
                var lineWidth = textStrokeStyle.getWidth();
                var miterLimit = textStrokeStyle.getMiterLimit();
                strokeState.lineCap = textStrokeStyle.getLineCap() || render_canvas["d" /* defaultLineCap */];
                strokeState.lineDash = lineDash ? lineDash.slice() : render_canvas["e" /* defaultLineDash */];
                strokeState.lineDashOffset =
                    lineDashOffset === undefined ? render_canvas["f" /* defaultLineDashOffset */] : lineDashOffset;
                strokeState.lineJoin = textStrokeStyle.getLineJoin() || render_canvas["g" /* defaultLineJoin */];
                strokeState.lineWidth =
                    lineWidth === undefined ? render_canvas["h" /* defaultLineWidth */] : lineWidth;
                strokeState.miterLimit =
                    miterLimit === undefined ? render_canvas["i" /* defaultMiterLimit */] : miterLimit;
                strokeState.strokeStyle = Object(colorlike["a" /* asColorLike */])(textStrokeStyle.getColor() || render_canvas["k" /* defaultStrokeStyle */]);
            }
            textState = this.textState_;
            var font = textStyle.getFont() || render_canvas["c" /* defaultFont */];
            Object(render_canvas["q" /* registerFont */])(font);
            var textScale = textStyle.getScaleArray();
            textState.overflow = textStyle.getOverflow();
            textState.font = font;
            textState.maxAngle = textStyle.getMaxAngle();
            textState.placement = textStyle.getPlacement();
            textState.textAlign = textStyle.getTextAlign();
            textState.textBaseline =
                textStyle.getTextBaseline() || render_canvas["m" /* defaultTextBaseline */];
            textState.backgroundFill = textStyle.getBackgroundFill();
            textState.backgroundStroke = textStyle.getBackgroundStroke();
            textState.padding = textStyle.getPadding() || render_canvas["j" /* defaultPadding */];
            textState.scale = textScale === undefined ? [1, 1] : textScale;
            var textOffsetX = textStyle.getOffsetX();
            var textOffsetY = textStyle.getOffsetY();
            var textRotateWithView = textStyle.getRotateWithView();
            var textRotation = textStyle.getRotation();
            this.text_ = textStyle.getText() || '';
            this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
            this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
            this.textRotateWithView_ =
                textRotateWithView === undefined ? false : textRotateWithView;
            this.textRotation_ = textRotation === undefined ? 0 : textRotation;
            this.strokeKey_ = strokeState
                ? (typeof strokeState.strokeStyle == 'string'
                    ? strokeState.strokeStyle
                    : Object(util["c" /* getUid */])(strokeState.strokeStyle)) +
                    strokeState.lineCap +
                    strokeState.lineDashOffset +
                    '|' +
                    strokeState.lineWidth +
                    strokeState.lineJoin +
                    strokeState.miterLimit +
                    '[' +
                    strokeState.lineDash.join() +
                    ']'
                : '';
            this.textKey_ =
                textState.font +
                    textState.scale +
                    (textState.textAlign || '?') +
                    (textState.textBaseline || '?');
            this.fillKey_ = fillState
                ? typeof fillState.fillStyle == 'string'
                    ? fillState.fillStyle
                    : '|' + Object(util["c" /* getUid */])(fillState.fillStyle)
                : '';
        }
        this.declutterImageWithText_ = opt_sharedData;
    };
    return CanvasTextBuilder;
}(Builder));
/* harmony default export */ var TextBuilder = (TextBuilder_CanvasTextBuilder);
//# sourceMappingURL=TextBuilder.js.map
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/BuilderGroup.js
/**
 * @module ol/render/canvas/BuilderGroup
 */





/**
 * @type {Object<import("./BuilderType").default, typeof Builder>}
 */
var BATCH_CONSTRUCTORS = {
    'Circle': PolygonBuilder,
    'Default': Builder,
    'Image': ImageBuilder,
    'LineString': LineStringBuilder,
    'Polygon': PolygonBuilder,
    'Text': TextBuilder,
};
var BuilderGroup = /** @class */ (function () {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Max extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio) {
        /**
         * @private
         * @type {number}
         */
        this.tolerance_ = tolerance;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */
        this.maxExtent_ = maxExtent;
        /**
         * @private
         * @type {number}
         */
        this.pixelRatio_ = pixelRatio;
        /**
         * @private
         * @type {number}
         */
        this.resolution_ = resolution;
        /**
         * @private
         * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
         */
        this.buildersByZIndex_ = {};
    }
    /**
     * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
     */
    BuilderGroup.prototype.finish = function () {
        var builderInstructions = {};
        for (var zKey in this.buildersByZIndex_) {
            builderInstructions[zKey] = builderInstructions[zKey] || {};
            var builders = this.buildersByZIndex_[zKey];
            for (var builderKey in builders) {
                var builderInstruction = builders[builderKey].finish();
                builderInstructions[zKey][builderKey] = builderInstruction;
            }
        }
        return builderInstructions;
    };
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("./BuilderType.js").default} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */
    BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
        var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
        var replays = this.buildersByZIndex_[zIndexKey];
        if (replays === undefined) {
            replays = {};
            this.buildersByZIndex_[zIndexKey] = replays;
        }
        var replay = replays[builderType];
        if (replay === undefined) {
            var Constructor = BATCH_CONSTRUCTORS[builderType];
            replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
            replays[builderType] = replay;
        }
        return replay;
    };
    return BuilderGroup;
}());
/* harmony default export */ var canvas_BuilderGroup = (BuilderGroup);
//# sourceMappingURL=BuilderGroup.js.map
// EXTERNAL MODULE: ./node_modules/ol/renderer/canvas/Layer.js + 1 modules
var canvas_Layer = __webpack_require__("137e");

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/BuilderType.js
/**
 * @module ol/render/canvas/BuilderType
 */
/**
 * @enum {string}
 */
/* harmony default export */ var BuilderType = ({
    CIRCLE: 'Circle',
    DEFAULT: 'Default',
    IMAGE: 'Image',
    LINE_STRING: 'LineString',
    POLYGON: 'Polygon',
    TEXT: 'Text',
});
//# sourceMappingURL=BuilderType.js.map
// EXTERNAL MODULE: ./node_modules/ol/has.js
var has = __webpack_require__("617d");

// EXTERNAL MODULE: ./node_modules/ol/transform.js
var ol_transform = __webpack_require__("a896");

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__("7fc9");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/transform.js
var flat_transform = __webpack_require__("bef8");

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/textpath.js
/**
 * @module ol/geom/flat/textpath
 */


/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var x1 = 0;
    var y1 = 0;
    var segmentLength = 0;
    var segmentM = 0;
    function advance() {
        x1 = x2;
        y1 = y2;
        offset += stride;
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        segmentM += segmentLength;
        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    do {
        advance();
    } while (offset < end - stride && segmentM + segmentLength < startM);
    var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
    var beginX = Object(math["e" /* lerp */])(x1, x2, interpolate);
    var beginY = Object(math["e" /* lerp */])(y1, y2, interpolate);
    var startOffset = offset - stride;
    var startLength = segmentM;
    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
    while (offset < end - stride && segmentM + segmentLength < endM) {
        advance();
    }
    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
    var endX = Object(math["e" /* lerp */])(x1, x2, interpolate);
    var endY = Object(math["e" /* lerp */])(y1, y2, interpolate);
    // Keep text upright
    var reverse;
    if (rotation) {
        var flat = [beginX, beginY, endX, endY];
        Object(flat_transform["a" /* rotate */])(flat, 0, 4, 2, rotation, flat, flat);
        reverse = flat[0] > flat[2];
    }
    else {
        reverse = beginX > endX;
    }
    var PI = Math.PI;
    var result = [];
    var singleSegment = startOffset + stride === offset;
    offset = startOffset;
    segmentLength = 0;
    segmentM = startLength;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    var previousAngle;
    // All on the same segment
    if (singleSegment) {
        advance();
        previousAngle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) {
            previousAngle += previousAngle > 0 ? -PI : PI;
        }
        var x = (endX + beginX) / 2;
        var y = (endY + beginY) / 2;
        result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
        return result;
    }
    for (var i = 0, ii = text.length; i < ii;) {
        advance();
        var angle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) {
            angle += angle > 0 ? -PI : PI;
        }
        if (previousAngle !== undefined) {
            var delta = angle - previousAngle;
            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
            if (Math.abs(delta) > maxAngle) {
                return null;
            }
        }
        previousAngle = angle;
        var iStart = i;
        var charLength = 0;
        for (; i < ii; ++i) {
            var index = reverse ? ii - i - 1 : i;
            var len = scale * measureAndCacheTextWidth(font, text[index], cache);
            if (offset + stride < end &&
                segmentM + segmentLength < startM + charLength + len / 2) {
                break;
            }
            charLength += len;
        }
        if (i === iStart) {
            continue;
        }
        var chars = reverse
            ? text.substring(ii - iStart, ii - i)
            : text.substring(iStart, i);
        interpolate =
            segmentLength === 0
                ? 0
                : (startM + charLength / 2 - segmentM) / segmentLength;
        var x = Object(math["e" /* lerp */])(x1, x2, interpolate);
        var y = Object(math["e" /* lerp */])(y1, y2, interpolate);
        result.push([x, y, charLength / 2, angle, chars]);
        startM += charLength;
    }
    return result;
}
//# sourceMappingURL=textpath.js.map
// EXTERNAL MODULE: ./node_modules/ol/geom/flat/length.js
var flat_length = __webpack_require__("5938");

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Executor.js
/**
 * @module ol/render/canvas/Executor
 */










/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */
/**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */
/**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */
/**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */
/**
 * @type {import("../../extent.js").Extent}
 */
var tmpExtent = Object(ol_extent["j" /* createEmpty */])();
/** @type {import("../../coordinate.js").Coordinate} */
var Executor_p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */
var Executor_p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */
var Executor_p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */
var p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */
function getDeclutterBox(replayImageOrLabelArgs) {
    return replayImageOrLabelArgs[3].declutterBox;
}
var rtlRegEx = new RegExp(
/* eslint-disable prettier/prettier */
'[' +
    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +
    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +
    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +
    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +
    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +
    ']'
/* eslint-enable prettier/prettier */
);
/**
 * @param {string} text Text.
 * @param {string} align Alignment.
 * @return {number} Text alignment.
 */
function horizontalTextAlign(text, align) {
    if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {
        align = align === 'start' ? 'left' : 'right';
    }
    return TEXT_ALIGN[align];
}
/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */
function createTextChunks(acc, line, i) {
    if (i > 0) {
        acc.push('\n', '');
    }
    acc.push(line, '');
    return acc;
}
var Executor_Executor = /** @class */ (function () {
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The replay can have overlapping geometries.
     * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
     */
    function Executor(resolution, pixelRatio, overlaps, instructions) {
        /**
         * @protected
         * @type {boolean}
         */
        this.overlaps = overlaps;
        /**
         * @protected
         * @type {number}
         */
        this.pixelRatio = pixelRatio;
        /**
         * @protected
         * @const
         * @type {number}
         */
        this.resolution = resolution;
        /**
         * @private
         * @type {boolean}
         */
        this.alignFill_;
        /**
         * @protected
         * @type {Array<*>}
         */
        this.instructions = instructions.instructions;
        /**
         * @protected
         * @type {Array<number>}
         */
        this.coordinates = instructions.coordinates;
        /**
         * @private
         * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
         */
        this.coordinateCache_ = {};
        /**
         * @private
         * @type {!import("../../transform.js").Transform}
         */
        this.renderedTransform_ = Object(ol_transform["c" /* create */])();
        /**
         * @protected
         * @type {Array<*>}
         */
        this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        /**
         * @private
         * @type {Array<number>}
         */
        this.pixelCoordinates_ = null;
        /**
         * @private
         * @type {number}
         */
        this.viewRotation_ = 0;
        /**
         * @type {!Object<string, import("../canvas.js").FillState>}
         */
        this.fillStates = instructions.fillStates || {};
        /**
         * @type {!Object<string, import("../canvas.js").StrokeState>}
         */
        this.strokeStates = instructions.strokeStates || {};
        /**
         * @type {!Object<string, import("../canvas.js").TextState>}
         */
        this.textStates = instructions.textStates || {};
        /**
         * @private
         * @type {Object<string, Object<string, number>>}
         */
        this.widths_ = {};
        /**
         * @private
         * @type {Object<string, import("../canvas.js").Label>}
         */
        this.labels_ = {};
    }
    /**
     * @param {string|Array<string>} text Text.
     * @param {string} textKey Text style key.
     * @param {string} fillKey Fill style key.
     * @param {string} strokeKey Stroke style key.
     * @return {import("../canvas.js").Label} Label.
     */
    Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
        var key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) {
            return this.labels_[key];
        }
        var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        var fillState = fillKey ? this.fillStates[fillKey] : null;
        var textState = this.textStates[textKey];
        var pixelRatio = this.pixelRatio;
        var scale = [
            textState.scale[0] * pixelRatio,
            textState.scale[1] * pixelRatio,
        ];
        var textIsArray = Array.isArray(text);
        var align = horizontalTextAlign(textIsArray ? text[0] : text, textState.textAlign || render_canvas["l" /* defaultTextAlign */]);
        var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        var chunks = textIsArray
            ? text
            : text.split('\n').reduce(createTextChunks, []);
        var _a = Object(render_canvas["o" /* getTextDimensions */])(textState, chunks), width = _a.width, height = _a.height, widths = _a.widths, heights = _a.heights, lineWidths = _a.lineWidths;
        var renderWidth = width + strokeWidth;
        var contextInstructions = [];
        // make canvas 2 pixels wider to account for italic text width measurement errors
        var w = (renderWidth + 2) * scale[0];
        var h = (height + strokeWidth) * scale[1];
        /** @type {import("../canvas.js").Label} */
        var label = {
            width: w < 0 ? Math.floor(w) : Math.ceil(w),
            height: h < 0 ? Math.floor(h) : Math.ceil(h),
            contextInstructions: contextInstructions,
        };
        if (scale[0] != 1 || scale[1] != 1) {
            contextInstructions.push('scale', scale);
        }
        if (strokeKey) {
            contextInstructions.push('strokeStyle', strokeState.strokeStyle);
            contextInstructions.push('lineWidth', strokeWidth);
            contextInstructions.push('lineCap', strokeState.lineCap);
            contextInstructions.push('lineJoin', strokeState.lineJoin);
            contextInstructions.push('miterLimit', strokeState.miterLimit);
            // eslint-disable-next-line
            var Context = has["g" /* WORKER_OFFSCREEN_CANVAS */] ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
            if (Context.prototype.setLineDash) {
                contextInstructions.push('setLineDash', [strokeState.lineDash]);
                contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
            }
        }
        if (fillKey) {
            contextInstructions.push('fillStyle', fillState.fillStyle);
        }
        contextInstructions.push('textBaseline', 'middle');
        contextInstructions.push('textAlign', 'center');
        var leftRight = 0.5 - align;
        var x = align * renderWidth + leftRight * strokeWidth;
        var strokeInstructions = [];
        var fillInstructions = [];
        var lineHeight = 0;
        var lineOffset = 0;
        var widthHeightIndex = 0;
        var lineWidthIndex = 0;
        var previousFont;
        for (var i = 0, ii = chunks.length; i < ii; i += 2) {
            var text_1 = chunks[i];
            if (text_1 === '\n') {
                lineOffset += lineHeight;
                lineHeight = 0;
                x = align * renderWidth + leftRight * strokeWidth;
                ++lineWidthIndex;
                continue;
            }
            var font = chunks[i + 1] || textState.font;
            if (font !== previousFont) {
                if (strokeKey) {
                    strokeInstructions.push('font', font);
                }
                if (fillKey) {
                    fillInstructions.push('font', font);
                }
                previousFont = font;
            }
            lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
            var fillStrokeArgs = [
                text_1,
                x +
                    leftRight * widths[widthHeightIndex] +
                    align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
                0.5 * (strokeWidth + lineHeight) + lineOffset,
            ];
            x += widths[widthHeightIndex];
            if (strokeKey) {
                strokeInstructions.push('strokeText', fillStrokeArgs);
            }
            if (fillKey) {
                fillInstructions.push('fillText', fillStrokeArgs);
            }
            ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */
    Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
        context.beginPath();
        context.moveTo.apply(context, p1);
        context.lineTo.apply(context, p2);
        context.lineTo.apply(context, p3);
        context.lineTo.apply(context, p4);
        context.lineTo.apply(context, p1);
        if (fillInstruction) {
            this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
            this.fill_(context);
        }
        if (strokeInstruction) {
            this.setStrokeStyle_(context, 
            /** @type {Array<*>} */ (strokeInstruction));
            context.stroke();
        }
    };
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */
    Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale[0];
        anchorY *= scale[1];
        var x = centerX - anchorX;
        var y = centerY - anchorY;
        var w = width + originX > sheetWidth ? sheetWidth - originX : width;
        var h = height + originY > sheetHeight ? sheetHeight - originY : height;
        var boxW = padding[3] + w * scale[0] + padding[1];
        var boxH = padding[0] + h * scale[1] + padding[2];
        var boxX = x - padding[3];
        var boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
            Executor_p1[0] = boxX;
            p4[0] = boxX;
            Executor_p1[1] = boxY;
            Executor_p2[1] = boxY;
            Executor_p2[0] = boxX + boxW;
            Executor_p3[0] = Executor_p2[0];
            Executor_p3[1] = boxY + boxH;
            p4[1] = Executor_p3[1];
        }
        var transform;
        if (rotation !== 0) {
            transform = Object(ol_transform["b" /* compose */])(Object(ol_transform["c" /* create */])(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
            Object(ol_transform["a" /* apply */])(transform, Executor_p1);
            Object(ol_transform["a" /* apply */])(transform, Executor_p2);
            Object(ol_transform["a" /* apply */])(transform, Executor_p3);
            Object(ol_transform["a" /* apply */])(transform, p4);
            Object(ol_extent["k" /* createOrUpdate */])(Math.min(Executor_p1[0], Executor_p2[0], Executor_p3[0], p4[0]), Math.min(Executor_p1[1], Executor_p2[1], Executor_p3[1], p4[1]), Math.max(Executor_p1[0], Executor_p2[0], Executor_p3[0], p4[0]), Math.max(Executor_p1[1], Executor_p2[1], Executor_p3[1], p4[1]), tmpExtent);
        }
        else {
            Object(ol_extent["k" /* createOrUpdate */])(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
        }
        if (snapToPixel) {
            x = Math.round(x);
            y = Math.round(y);
        }
        return {
            drawImageX: x,
            drawImageY: y,
            drawImageW: w,
            drawImageH: h,
            originX: originX,
            originY: originY,
            declutterBox: {
                minX: tmpExtent[0],
                minY: tmpExtent[1],
                maxX: tmpExtent[2],
                maxY: tmpExtent[3],
                value: feature,
            },
            canvasTransform: transform,
            scale: scale,
        };
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */
    Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
        var fillStroke = !!(fillInstruction || strokeInstruction);
        var box = dimensions.declutterBox;
        var canvas = context.canvas;
        var strokePadding = strokeInstruction
            ? (strokeInstruction[2] * dimensions.scale[0]) / 2
            : 0;
        var intersects = box.minX - strokePadding <= canvas.width / contextScale &&
            box.maxX + strokePadding >= 0 &&
            box.minY - strokePadding <= canvas.height / contextScale &&
            box.maxY + strokePadding >= 0;
        if (intersects) {
            if (fillStroke) {
                this.replayTextBackground_(context, Executor_p1, Executor_p2, Executor_p3, p4, 
                /** @type {Array<*>} */ (fillInstruction), 
                /** @type {Array<*>} */ (strokeInstruction));
            }
            Object(render_canvas["n" /* drawImageOrLabel */])(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
        }
        return true;
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */
    Executor.prototype.fill_ = function (context) {
        if (this.alignFill_) {
            var origin_1 = Object(ol_transform["a" /* apply */])(this.renderedTransform_, [0, 0]);
            var repeatSize = 512 * this.pixelRatio;
            context.save();
            context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
            context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) {
            context.restore();
        }
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */
    Executor.prototype.setStrokeStyle_ = function (context, instruction) {
        context['strokeStyle'] =
            /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
        context.lineWidth = /** @type {number} */ (instruction[2]);
        context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
        context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
        context.miterLimit = /** @type {number} */ (instruction[5]);
        if (context.setLineDash) {
            context.lineDashOffset = /** @type {number} */ (instruction[7]);
            context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
        }
    };
    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */
    Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
        var textState = this.textStates[textKey];
        var label = this.createLabel(text, textKey, fillKey, strokeKey);
        var strokeState = this.strokeStates[strokeKey];
        var pixelRatio = this.pixelRatio;
        var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || render_canvas["l" /* defaultTextAlign */]);
        var baseline = TEXT_ALIGN[textState.textBaseline || render_canvas["m" /* defaultTextBaseline */]];
        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        // Remove the 2 pixels we added in createLabel() for the anchor
        var width = label.width / pixelRatio - 2 * textState.scale[0];
        var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        var anchorY = (baseline * label.height) / pixelRatio +
            2 * (0.5 - baseline) * strokeWidth;
        return {
            label: label,
            anchorX: anchorX,
            anchorY: anchorY,
        };
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [opt_hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */
    Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
        /** @type {Array<number>} */
        var pixelCoordinates;
        if (this.pixelCoordinates_ && Object(array["b" /* equals */])(transform, this.renderedTransform_)) {
            pixelCoordinates = this.pixelCoordinates_;
        }
        else {
            if (!this.pixelCoordinates_) {
                this.pixelCoordinates_ = [];
            }
            pixelCoordinates = Object(flat_transform["c" /* transform2D */])(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
            Object(ol_transform["f" /* setFromArray */])(this.renderedTransform_, transform);
        }
        var i = 0; // instruction index
        var ii = instructions.length; // end of instructions
        var d = 0; // data index
        var dd; // end of per-instruction data
        var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        var pendingFill = 0;
        var pendingStroke = 0;
        var lastFillInstruction = null;
        var lastStrokeInstruction = null;
        var coordinateCache = this.coordinateCache_;
        var viewRotation = this.viewRotation_;
        var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
        var state = /** @type {import("../../render.js").State} */ ({
            context: context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation,
        });
        // When the batch size gets too big, performance decreases. 200 is a good
        // balance between batch size and number of fill/stroke instructions.
        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        var /** @type {import("../../Feature.js").FeatureLike} */ feature;
        var x, y, currentGeometry;
        while (i < ii) {
            var instruction = instructions[i];
            var type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
            switch (type) {
                case canvas_Instruction.BEGIN_GEOMETRY:
                    feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                    currentGeometry = instruction[3];
                    if (!feature.getGeometry()) {
                        i = /** @type {number} */ (instruction[2]);
                    }
                    else if (opt_hitExtent !== undefined &&
                        !Object(ol_extent["E" /* intersects */])(opt_hitExtent, currentGeometry.getExtent())) {
                        i = /** @type {number} */ (instruction[2]) + 1;
                    }
                    else {
                        ++i;
                    }
                    break;
                case canvas_Instruction.BEGIN_PATH:
                    if (pendingFill > batchSize) {
                        this.fill_(context);
                        pendingFill = 0;
                    }
                    if (pendingStroke > batchSize) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    if (!pendingFill && !pendingStroke) {
                        context.beginPath();
                        prevX = NaN;
                        prevY = NaN;
                    }
                    ++i;
                    break;
                case canvas_Instruction.CIRCLE:
                    d = /** @type {number} */ (instruction[1]);
                    var x1 = pixelCoordinates[d];
                    var y1 = pixelCoordinates[d + 1];
                    var x2 = pixelCoordinates[d + 2];
                    var y2 = pixelCoordinates[d + 3];
                    var dx = x2 - x1;
                    var dy = y2 - y1;
                    var r = Math.sqrt(dx * dx + dy * dy);
                    context.moveTo(x1 + r, y1);
                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                    ++i;
                    break;
                case canvas_Instruction.CLOSE_PATH:
                    context.closePath();
                    ++i;
                    break;
                case canvas_Instruction.CUSTOM:
                    d = /** @type {number} */ (instruction[1]);
                    dd = instruction[2];
                    var geometry = 
                    /** @type {import("../../geom/SimpleGeometry.js").default} */ (instruction[3]);
                    var renderer = instruction[4];
                    var fn = instruction.length == 6 ? instruction[5] : undefined;
                    state.geometry = geometry;
                    state.feature = feature;
                    if (!(i in coordinateCache)) {
                        coordinateCache[i] = [];
                    }
                    var coords = coordinateCache[i];
                    if (fn) {
                        fn(pixelCoordinates, d, dd, 2, coords);
                    }
                    else {
                        coords[0] = pixelCoordinates[d];
                        coords[1] = pixelCoordinates[d + 1];
                        coords.length = 2;
                    }
                    renderer(coords, state);
                    ++i;
                    break;
                case canvas_Instruction.DRAW_IMAGE:
                    d = /** @type {number} */ (instruction[1]);
                    dd = /** @type {number} */ (instruction[2]);
                    image =
                        /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);
                    // Remaining arguments in DRAW_IMAGE are in alphabetical order
                    anchorX = /** @type {number} */ (instruction[4]);
                    anchorY = /** @type {number} */ (instruction[5]);
                    var height = /** @type {number} */ (instruction[6]);
                    var opacity = /** @type {number} */ (instruction[7]);
                    var originX = /** @type {number} */ (instruction[8]);
                    var originY = /** @type {number} */ (instruction[9]);
                    var rotateWithView = /** @type {boolean} */ (instruction[10]);
                    var rotation = /** @type {number} */ (instruction[11]);
                    var scale = /** @type {import("../../size.js").Size} */ (instruction[12]);
                    var width = /** @type {number} */ (instruction[13]);
                    var declutterImageWithText = 
                    /** @type {import("../canvas.js").DeclutterImageWithText} */ (instruction[14]);
                    if (!image && instruction.length >= 19) {
                        // create label images
                        text = /** @type {string} */ (instruction[18]);
                        textKey = /** @type {string} */ (instruction[19]);
                        strokeKey = /** @type {string} */ (instruction[20]);
                        fillKey = /** @type {string} */ (instruction[21]);
                        var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                        image = labelWithAnchor.label;
                        instruction[3] = image;
                        var textOffsetX = /** @type {number} */ (instruction[22]);
                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                        instruction[4] = anchorX;
                        var textOffsetY = /** @type {number} */ (instruction[23]);
                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                        instruction[5] = anchorY;
                        height = image.height;
                        instruction[6] = height;
                        width = image.width;
                        instruction[13] = width;
                    }
                    var geometryWidths = void 0;
                    if (instruction.length > 24) {
                        geometryWidths = /** @type {number} */ (instruction[24]);
                    }
                    var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                    if (instruction.length > 16) {
                        padding = /** @type {Array<number>} */ (instruction[15]);
                        backgroundFill = /** @type {boolean} */ (instruction[16]);
                        backgroundStroke = /** @type {boolean} */ (instruction[17]);
                    }
                    else {
                        padding = render_canvas["j" /* defaultPadding */];
                        backgroundFill = false;
                        backgroundStroke = false;
                    }
                    if (rotateWithView && viewRotationFromTransform) {
                        // Canvas is expected to be rotated to reverse view rotation.
                        rotation += viewRotation;
                    }
                    else if (!rotateWithView && !viewRotationFromTransform) {
                        // Canvas is not rotated, images need to be rotated back to be north-up.
                        rotation -= viewRotation;
                    }
                    var widthIndex = 0;
                    for (; d < dd; d += 2) {
                        if (geometryWidths &&
                            geometryWidths[widthIndex++] < width / this.pixelRatio) {
                            continue;
                        }
                        var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                        /** @type {ReplayImageOrLabelArgs} */
                        var args = [
                            context,
                            contextScale,
                            image,
                            dimensions,
                            opacity,
                            backgroundFill
                                ? /** @type {Array<*>} */ (lastFillInstruction)
                                : null,
                            backgroundStroke
                                ? /** @type {Array<*>} */ (lastStrokeInstruction)
                                : null,
                        ];
                        var imageArgs = void 0;
                        var imageDeclutterBox = void 0;
                        if (opt_declutterTree && declutterImageWithText) {
                            var index = dd - d;
                            if (!declutterImageWithText[index]) {
                                // We now have the image for an image+text combination.
                                declutterImageWithText[index] = args;
                                // Don't render anything for now, wait for the text.
                                continue;
                            }
                            imageArgs = declutterImageWithText[index];
                            delete declutterImageWithText[index];
                            imageDeclutterBox = getDeclutterBox(imageArgs);
                            if (opt_declutterTree.collides(imageDeclutterBox)) {
                                continue;
                            }
                        }
                        if (opt_declutterTree &&
                            opt_declutterTree.collides(dimensions.declutterBox)) {
                            continue;
                        }
                        if (imageArgs) {
                            // We now have image and text for an image+text combination.
                            if (opt_declutterTree) {
                                opt_declutterTree.insert(imageDeclutterBox);
                            }
                            // Render the image before we render the text.
                            this.replayImageOrLabel_.apply(this, imageArgs);
                        }
                        if (opt_declutterTree) {
                            opt_declutterTree.insert(dimensions.declutterBox);
                        }
                        this.replayImageOrLabel_.apply(this, args);
                    }
                    ++i;
                    break;
                case canvas_Instruction.DRAW_CHARS:
                    var begin = /** @type {number} */ (instruction[1]);
                    var end = /** @type {number} */ (instruction[2]);
                    var baseline = /** @type {number} */ (instruction[3]);
                    var overflow = /** @type {number} */ (instruction[4]);
                    fillKey = /** @type {string} */ (instruction[5]);
                    var maxAngle = /** @type {number} */ (instruction[6]);
                    var measurePixelRatio = /** @type {number} */ (instruction[7]);
                    var offsetY = /** @type {number} */ (instruction[8]);
                    strokeKey = /** @type {string} */ (instruction[9]);
                    var strokeWidth = /** @type {number} */ (instruction[10]);
                    text = /** @type {string} */ (instruction[11]);
                    textKey = /** @type {string} */ (instruction[12]);
                    var pixelRatioScale = [
                        /** @type {number} */ (instruction[13]),
                        /** @type {number} */ (instruction[13]),
                    ];
                    var textState = this.textStates[textKey];
                    var font = textState.font;
                    var textScale = [
                        textState.scale[0] * measurePixelRatio,
                        textState.scale[1] * measurePixelRatio,
                    ];
                    var cachedWidths = void 0;
                    if (font in this.widths_) {
                        cachedWidths = this.widths_[font];
                    }
                    else {
                        cachedWidths = {};
                        this.widths_[font] = cachedWidths;
                    }
                    var pathLength = Object(flat_length["a" /* lineStringLength */])(pixelCoordinates, begin, end, 2);
                    var textLength = Math.abs(textScale[0]) *
                        Object(render_canvas["p" /* measureAndCacheTextWidth */])(font, text, cachedWidths);
                    if (overflow || textLength <= pathLength) {
                        var textAlign = this.textStates[textKey].textAlign;
                        var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                        var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), render_canvas["p" /* measureAndCacheTextWidth */], font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                        drawChars: if (parts) {
                            /** @type {Array<ReplayImageOrLabelArgs>} */
                            var replayImageOrLabelArgs = [];
                            var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                            if (strokeKey) {
                                for (c = 0, cc = parts.length; c < cc; ++c) {
                                    part = parts[c]; // x, y, anchorX, rotation, chunk
                                    chars = /** @type {string} */ (part[4]);
                                    label = this.createLabel(chars, textKey, '', strokeKey);
                                    anchorX =
                                        /** @type {number} */ (part[2]) +
                                            (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                                    anchorY =
                                        baseline * label.height +
                                            ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /
                                                textScale[0] -
                                            offsetY;
                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, render_canvas["j" /* defaultPadding */], false, feature);
                                    if (opt_declutterTree &&
                                        opt_declutterTree.collides(dimensions.declutterBox)) {
                                        break drawChars;
                                    }
                                    replayImageOrLabelArgs.push([
                                        context,
                                        contextScale,
                                        label,
                                        dimensions,
                                        1,
                                        null,
                                        null,
                                    ]);
                                }
                            }
                            if (fillKey) {
                                for (c = 0, cc = parts.length; c < cc; ++c) {
                                    part = parts[c]; // x, y, anchorX, rotation, chunk
                                    chars = /** @type {string} */ (part[4]);
                                    label = this.createLabel(chars, textKey, fillKey, '');
                                    anchorX = /** @type {number} */ (part[2]);
                                    anchorY = baseline * label.height - offsetY;
                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, render_canvas["j" /* defaultPadding */], false, feature);
                                    if (opt_declutterTree &&
                                        opt_declutterTree.collides(dimensions.declutterBox)) {
                                        break drawChars;
                                    }
                                    replayImageOrLabelArgs.push([
                                        context,
                                        contextScale,
                                        label,
                                        dimensions,
                                        1,
                                        null,
                                        null,
                                    ]);
                                }
                            }
                            if (opt_declutterTree) {
                                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                            }
                            for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                            }
                        }
                    }
                    ++i;
                    break;
                case canvas_Instruction.END_GEOMETRY:
                    if (opt_featureCallback !== undefined) {
                        feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                        var result = opt_featureCallback(feature, currentGeometry);
                        if (result) {
                            return result;
                        }
                    }
                    ++i;
                    break;
                case canvas_Instruction.FILL:
                    if (batchSize) {
                        pendingFill++;
                    }
                    else {
                        this.fill_(context);
                    }
                    ++i;
                    break;
                case canvas_Instruction.MOVE_TO_LINE_TO:
                    d = /** @type {number} */ (instruction[1]);
                    dd = /** @type {number} */ (instruction[2]);
                    x = pixelCoordinates[d];
                    y = pixelCoordinates[d + 1];
                    roundX = (x + 0.5) | 0;
                    roundY = (y + 0.5) | 0;
                    if (roundX !== prevX || roundY !== prevY) {
                        context.moveTo(x, y);
                        prevX = roundX;
                        prevY = roundY;
                    }
                    for (d += 2; d < dd; d += 2) {
                        x = pixelCoordinates[d];
                        y = pixelCoordinates[d + 1];
                        roundX = (x + 0.5) | 0;
                        roundY = (y + 0.5) | 0;
                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                            context.lineTo(x, y);
                            prevX = roundX;
                            prevY = roundY;
                        }
                    }
                    ++i;
                    break;
                case canvas_Instruction.SET_FILL_STYLE:
                    lastFillInstruction = instruction;
                    this.alignFill_ = instruction[2];
                    if (pendingFill) {
                        this.fill_(context);
                        pendingFill = 0;
                        if (pendingStroke) {
                            context.stroke();
                            pendingStroke = 0;
                        }
                    }
                    context.fillStyle =
                        /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
                    ++i;
                    break;
                case canvas_Instruction.SET_STROKE_STYLE:
                    lastStrokeInstruction = instruction;
                    if (pendingStroke) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
                    ++i;
                    break;
                case canvas_Instruction.STROKE:
                    if (batchSize) {
                        pendingStroke++;
                    }
                    else {
                        context.stroke();
                    }
                    ++i;
                    break;
                default:
                    ++i; // consume the instruction anyway, to avoid an infinite loop
                    break;
            }
        }
        if (pendingFill) {
            this.fill_(context);
        }
        if (pendingStroke) {
            context.stroke();
        }
        return undefined;
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     */
    Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [opt_hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */
    Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
    };
    return Executor;
}());
/* harmony default export */ var canvas_Executor = (Executor_Executor);
//# sourceMappingURL=Executor.js.map
// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__("0999");

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/ExecutorGroup.js
/**
 * @module ol/render/canvas/ExecutorGroup
 */








/**
 * @const
 * @type {Array<import("./BuilderType.js").default>}
 */
var ORDER = [
    BuilderType.POLYGON,
    BuilderType.CIRCLE,
    BuilderType.LINE_STRING,
    BuilderType.IMAGE,
    BuilderType.TEXT,
    BuilderType.DEFAULT,
];
var ExecutorGroup_ExecutorGroup = /** @class */ (function () {
    /**
     * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
     * should be set here, unless the target context does not exceed that extent (which
     * can be the case when rendering to tiles).
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The executor group can have overlapping geometries.
     * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions
     * The serializable instructions.
     * @param {number} [opt_renderBuffer] Optional rendering buffer.
     */
    function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */
        this.maxExtent_ = maxExtent;
        /**
         * @private
         * @type {boolean}
         */
        this.overlaps_ = overlaps;
        /**
         * @private
         * @type {number}
         */
        this.pixelRatio_ = pixelRatio;
        /**
         * @private
         * @type {number}
         */
        this.resolution_ = resolution;
        /**
         * @private
         * @type {number|undefined}
         */
        this.renderBuffer_ = opt_renderBuffer;
        /**
         * @private
         * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
         */
        this.executorsByZIndex_ = {};
        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */
        this.hitDetectionContext_ = null;
        /**
         * @private
         * @type {import("../../transform.js").Transform}
         */
        this.hitDetectionTransform_ = Object(ol_transform["c" /* create */])();
        this.createExecutors_(allInstructions);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    ExecutorGroup.prototype.clip = function (context, transform) {
        var flatClipCoords = this.getClipCoords(transform);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
    };
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     */
    ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
        for (var zIndex in allInstructions) {
            var executors = this.executorsByZIndex_[zIndex];
            if (executors === undefined) {
                executors = {};
                this.executorsByZIndex_[zIndex] = executors;
            }
            var instructionByZindex = allInstructions[zIndex];
            for (var builderType in instructionByZindex) {
                var instructions = instructionByZindex[builderType];
                executors[builderType] = new canvas_Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
            }
        }
    };
    /**
     * @param {Array<import("./BuilderType.js").default>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */
    ExecutorGroup.prototype.hasExecutors = function (executors) {
        for (var zIndex in this.executorsByZIndex_) {
            var candidates = this.executorsByZIndex_[zIndex];
            for (var i = 0, ii = executors.length; i < ii; ++i) {
                if (executors[i] in candidates) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */
    ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        var contextSize = hitTolerance * 2 + 1;
        var transform = Object(ol_transform["b" /* compose */])(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
        var newContext = !this.hitDetectionContext_;
        if (newContext) {
            this.hitDetectionContext_ = Object(dom["a" /* createCanvasContext2D */])(contextSize, contextSize);
        }
        var context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize ||
            context.canvas.height !== contextSize) {
            context.canvas.width = contextSize;
            context.canvas.height = contextSize;
        }
        else if (!newContext) {
            context.clearRect(0, 0, contextSize, contextSize);
        }
        /**
         * @type {import("../../extent.js").Extent}
         */
        var hitExtent;
        if (this.renderBuffer_ !== undefined) {
            hitExtent = Object(ol_extent["j" /* createEmpty */])();
            Object(ol_extent["q" /* extendCoordinate */])(hitExtent, coordinate);
            Object(ol_extent["c" /* buffer */])(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
        }
        var indexes = getPixelIndexArray(hitTolerance);
        var builderType;
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
         * @return {T|undefined} Callback result.
         */
        function featureCallback(feature, geometry) {
            var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
            for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
                if (imageData[indexes[i_1]] > 0) {
                    if (!declutteredFeatures ||
                        (builderType !== BuilderType.IMAGE &&
                            builderType !== BuilderType.TEXT) ||
                        declutteredFeatures.indexOf(feature) !== -1) {
                        var idx = (indexes[i_1] - 3) / 4;
                        var x = hitTolerance - (idx % contextSize);
                        var y = hitTolerance - ((idx / contextSize) | 0);
                        var result_1 = callback(feature, geometry, x * x + y * y);
                        if (result_1) {
                            return result_1;
                        }
                    }
                    context.clearRect(0, 0, contextSize, contextSize);
                    break;
                }
            }
            return undefined;
        }
        /** @type {Array<number>} */
        var zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(array["g" /* numberSafeCompareFunction */]);
        var i, j, executors, executor, result;
        for (i = zs.length - 1; i >= 0; --i) {
            var zIndexKey = zs[i].toString();
            executors = this.executorsByZIndex_[zIndexKey];
            for (j = ORDER.length - 1; j >= 0; --j) {
                builderType = ORDER[j];
                executor = executors[builderType];
                if (executor !== undefined) {
                    result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return undefined;
    };
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>} Clip coordinates.
     */
    ExecutorGroup.prototype.getClipCoords = function (transform) {
        var maxExtent = this.maxExtent_;
        if (!maxExtent) {
            return null;
        }
        var minX = maxExtent[0];
        var minY = maxExtent[1];
        var maxX = maxExtent[2];
        var maxY = maxExtent[3];
        var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
        Object(flat_transform["c" /* transform2D */])(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
        return flatClipCoords;
    };
    /**
     * @return {boolean} Is empty.
     */
    ExecutorGroup.prototype.isEmpty = function () {
        return Object(obj["d" /* isEmpty */])(this.executorsByZIndex_);
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("./BuilderType.js").default>} [opt_builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ORDER}
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     */
    ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
        /** @type {Array<number>} */
        var zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(array["g" /* numberSafeCompareFunction */]);
        // setup clipping so that the parts of over-simplified geometries are not
        // visible outside the current extent when panning
        if (this.maxExtent_) {
            context.save();
            this.clip(context, transform);
        }
        var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
        var i, ii, j, jj, replays, replay;
        if (opt_declutterTree) {
            zs.reverse();
        }
        for (i = 0, ii = zs.length; i < ii; ++i) {
            var zIndexKey = zs[i].toString();
            replays = this.executorsByZIndex_[zIndexKey];
            for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                var builderType = builderTypes[j];
                replay = replays[builderType];
                if (replay !== undefined) {
                    replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);
                }
            }
        }
        if (this.maxExtent_) {
            context.restore();
        }
    };
    return ExecutorGroup;
}());
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */
var circlePixelIndexArrayCache = {};
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */
function getPixelIndexArray(radius) {
    if (circlePixelIndexArrayCache[radius] !== undefined) {
        return circlePixelIndexArrayCache[radius];
    }
    var size = radius * 2 + 1;
    var maxDistanceSq = radius * radius;
    var distances = new Array(maxDistanceSq + 1);
    for (var i = 0; i <= radius; ++i) {
        for (var j = 0; j <= radius; ++j) {
            var distanceSq = i * i + j * j;
            if (distanceSq > maxDistanceSq) {
                break;
            }
            var distance = distances[distanceSq];
            if (!distance) {
                distance = [];
                distances[distanceSq] = distance;
            }
            distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
            if (i > 0) {
                distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
            }
            if (j > 0) {
                distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
                if (i > 0) {
                    distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
                }
            }
        }
    }
    var pixelIndex = [];
    for (var i = 0, ii = distances.length; i < ii; ++i) {
        if (distances[i]) {
            pixelIndex.push.apply(pixelIndex, distances[i]);
        }
    }
    circlePixelIndexArrayCache[radius] = pixelIndex;
    return pixelIndex;
}
/* harmony default export */ var canvas_ExecutorGroup = (ExecutorGroup_ExecutorGroup);
//# sourceMappingURL=ExecutorGroup.js.map
// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js
var ViewHint = __webpack_require__("496f");

// EXTERNAL MODULE: ./node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = __webpack_require__("9abc");

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Immediate.js
/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var Immediate_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var Immediate_CanvasImmediateRenderer = /** @class */ (function (_super) {
    Immediate_extends(CanvasImmediateRenderer, _super);
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {number} [opt_squaredTolerance] Optional squared tolerance for simplification.
     * @param {import("../../proj.js").TransformFunction} [opt_userTransform] Transform from user to view projection.
     */
    function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */
        _this.context_ = context;
        /**
         * @private
         * @type {number}
         */
        _this.pixelRatio_ = pixelRatio;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */
        _this.extent_ = extent;
        /**
         * @private
         * @type {import("../../transform.js").Transform}
         */
        _this.transform_ = transform;
        /**
         * @private
         * @type {number}
         */
        _this.viewRotation_ = viewRotation;
        /**
         * @private
         * @type {number}
         */
        _this.squaredTolerance_ = opt_squaredTolerance;
        /**
         * @private
         * @type {import("../../proj.js").TransformFunction}
         */
        _this.userTransform_ = opt_userTransform;
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */
        _this.contextFillState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */
        _this.contextStrokeState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").TextState}
         */
        _this.contextTextState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */
        _this.fillState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */
        _this.strokeState_ = null;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */
        _this.image_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.imageAnchorX_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.imageAnchorY_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.imageHeight_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.imageOpacity_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.imageOriginX_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.imageOriginY_ = 0;
        /**
         * @private
         * @type {boolean}
         */
        _this.imageRotateWithView_ = false;
        /**
         * @private
         * @type {number}
         */
        _this.imageRotation_ = 0;
        /**
         * @private
         * @type {import("../../size.js").Size}
         */
        _this.imageScale_ = [0, 0];
        /**
         * @private
         * @type {number}
         */
        _this.imageWidth_ = 0;
        /**
         * @private
         * @type {string}
         */
        _this.text_ = '';
        /**
         * @private
         * @type {number}
         */
        _this.textOffsetX_ = 0;
        /**
         * @private
         * @type {number}
         */
        _this.textOffsetY_ = 0;
        /**
         * @private
         * @type {boolean}
         */
        _this.textRotateWithView_ = false;
        /**
         * @private
         * @type {number}
         */
        _this.textRotation_ = 0;
        /**
         * @private
         * @type {import("../../size.js").Size}
         */
        _this.textScale_ = [0, 0];
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */
        _this.textFillState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */
        _this.textStrokeState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").TextState}
         */
        _this.textState_ = null;
        /**
         * @private
         * @type {Array<number>}
         */
        _this.pixelCoordinates_ = [];
        /**
         * @private
         * @type {import("../../transform.js").Transform}
         */
        _this.tmpLocalTransform_ = Object(ol_transform["c" /* create */])();
        return _this;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
        if (!this.image_) {
            return;
        }
        var pixelCoordinates = Object(flat_transform["c" /* transform2D */])(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        var context = this.context_;
        var localTransform = this.tmpLocalTransform_;
        var alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) {
            context.globalAlpha = alpha * this.imageOpacity_;
        }
        var rotation = this.imageRotation_;
        if (this.imageRotateWithView_) {
            rotation += this.viewRotation_;
        }
        for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
            var x = pixelCoordinates[i] - this.imageAnchorX_;
            var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
            if (rotation !== 0 ||
                this.imageScale_[0] != 1 ||
                this.imageScale_[1] != 1) {
                var centerX = x + this.imageAnchorX_;
                var centerY = y + this.imageAnchorY_;
                Object(ol_transform["b" /* compose */])(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                context.setTransform.apply(context, localTransform);
                context.translate(centerX, centerY);
                context.scale(this.imageScale_[0], this.imageScale_[1]);
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                context.setTransform(1, 0, 0, 1, 0, 0);
            }
            else {
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
            }
        }
        if (this.imageOpacity_ != 1) {
            context.globalAlpha = alpha;
        }
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
        if (!this.textState_ || this.text_ === '') {
            return;
        }
        if (this.textFillState_) {
            this.setContextFillState_(this.textFillState_);
        }
        if (this.textStrokeState_) {
            this.setContextStrokeState_(this.textStrokeState_);
        }
        this.setContextTextState_(this.textState_);
        var pixelCoordinates = Object(flat_transform["c" /* transform2D */])(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        var context = this.context_;
        var rotation = this.textRotation_;
        if (this.textRotateWithView_) {
            rotation += this.viewRotation_;
        }
        for (; offset < end; offset += stride) {
            var x = pixelCoordinates[offset] + this.textOffsetX_;
            var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
            if (rotation !== 0 ||
                this.textScale_[0] != 1 ||
                this.textScale_[1] != 1) {
                var localTransform = Object(ol_transform["b" /* compose */])(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                context.setTransform.apply(context, localTransform);
                context.translate(x, y);
                context.scale(this.textScale_[0], this.textScale_[1]);
                if (this.textStrokeState_) {
                    context.strokeText(this.text_, 0, 0);
                }
                if (this.textFillState_) {
                    context.fillText(this.text_, 0, 0);
                }
                context.setTransform(1, 0, 0, 1, 0, 0);
            }
            else {
                if (this.textStrokeState_) {
                    context.strokeText(this.text_, x, y);
                }
                if (this.textFillState_) {
                    context.fillText(this.text_, x, y);
                }
            }
        }
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */
    CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
        var context = this.context_;
        var pixelCoordinates = Object(flat_transform["c" /* transform2D */])(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        var length = pixelCoordinates.length;
        if (close) {
            length -= 2;
        }
        for (var i = 2; i < length; i += 2) {
            context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        }
        if (close) {
            context.closePath();
        }
        return end;
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
        }
        return offset;
    };
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     */
    CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
        if (!Object(ol_extent["E" /* intersects */])(this.extent_, geometry.getExtent())) {
            return;
        }
        if (this.fillState_ || this.strokeState_) {
            if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
            }
            if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
            }
            var pixelCoordinates = Object(SimpleGeometry["b" /* transformGeom2D */])(geometry, this.transform_, this.pixelCoordinates_);
            var dx = pixelCoordinates[2] - pixelCoordinates[0];
            var dy = pixelCoordinates[3] - pixelCoordinates[1];
            var radius = Math.sqrt(dx * dx + dy * dy);
            var context = this.context_;
            context.beginPath();
            context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
            if (this.fillState_) {
                context.fill();
            }
            if (this.strokeState_) {
                context.stroke();
            }
        }
        if (this.text_ !== '') {
            this.drawText_(geometry.getCenter(), 0, 2, 2);
        }
    };
    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     */
    CanvasImmediateRenderer.prototype.setStyle = function (style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
    };
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    CanvasImmediateRenderer.prototype.setTransform = function (transform) {
        this.transform_ = transform;
    };
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     */
    CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
        var type = geometry.getType();
        switch (type) {
            case GeometryType["a" /* default */].POINT:
                this.drawPoint(
                /** @type {import("../../geom/Point.js").default} */ (geometry));
                break;
            case GeometryType["a" /* default */].LINE_STRING:
                this.drawLineString(
                /** @type {import("../../geom/LineString.js").default} */ (geometry));
                break;
            case GeometryType["a" /* default */].POLYGON:
                this.drawPolygon(
                /** @type {import("../../geom/Polygon.js").default} */ (geometry));
                break;
            case GeometryType["a" /* default */].MULTI_POINT:
                this.drawMultiPoint(
                /** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
                break;
            case GeometryType["a" /* default */].MULTI_LINE_STRING:
                this.drawMultiLineString(
                /** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
                break;
            case GeometryType["a" /* default */].MULTI_POLYGON:
                this.drawMultiPolygon(
                /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
                break;
            case GeometryType["a" /* default */].GEOMETRY_COLLECTION:
                this.drawGeometryCollection(
                /** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
                break;
            case GeometryType["a" /* default */].CIRCLE:
                this.drawCircle(
                /** @type {import("../../geom/Circle.js").default} */ (geometry));
                break;
            default:
        }
    };
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     */
    CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
        var geometry = style.getGeometryFunction()(feature);
        if (!geometry || !Object(ol_extent["E" /* intersects */])(this.extent_, geometry.getExtent())) {
            return;
        }
        this.setStyle(style);
        this.drawGeometry(geometry);
    };
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     */
    CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
        var geometries = geometry.getGeometriesArray();
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            this.drawGeometry(geometries[i]);
        }
    };
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     */
    CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
        if (this.squaredTolerance_) {
            geometry = /** @type {import("../../geom/Point.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        }
        var flatCoordinates = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        if (this.image_) {
            this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== '') {
            this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
    };
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     */
    CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
        if (this.squaredTolerance_) {
            geometry = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        }
        var flatCoordinates = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        if (this.image_) {
            this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== '') {
            this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
    };
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     */
    CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
        if (this.squaredTolerance_) {
            geometry = /** @type {import("../../geom/LineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        }
        if (!Object(ol_extent["E" /* intersects */])(this.extent_, geometry.getExtent())) {
            return;
        }
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            var context = this.context_;
            var flatCoordinates = geometry.getFlatCoordinates();
            context.beginPath();
            this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
            context.stroke();
        }
        if (this.text_ !== '') {
            var flatMidpoint = geometry.getFlatMidpoint();
            this.drawText_(flatMidpoint, 0, 2, 2);
        }
    };
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     */
    CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
        if (this.squaredTolerance_) {
            geometry =
                /** @type {import("../../geom/MultiLineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        }
        var geometryExtent = geometry.getExtent();
        if (!Object(ol_extent["E" /* intersects */])(this.extent_, geometryExtent)) {
            return;
        }
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            var context = this.context_;
            var flatCoordinates = geometry.getFlatCoordinates();
            var offset = 0;
            var ends = /** @type {Array<number>} */ (geometry.getEnds());
            var stride = geometry.getStride();
            context.beginPath();
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
            }
            context.stroke();
        }
        if (this.text_ !== '') {
            var flatMidpoints = geometry.getFlatMidpoints();
            this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
    };
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     */
    CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
        if (this.squaredTolerance_) {
            geometry = /** @type {import("../../geom/Polygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        }
        if (!Object(ol_extent["E" /* intersects */])(this.extent_, geometry.getExtent())) {
            return;
        }
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
            }
            if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
            }
            var context = this.context_;
            context.beginPath();
            this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, 
            /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
            if (this.fillState_) {
                context.fill();
            }
            if (this.strokeState_) {
                context.stroke();
            }
        }
        if (this.text_ !== '') {
            var flatInteriorPoint = geometry.getFlatInteriorPoint();
            this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
    };
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     */
    CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
        if (this.squaredTolerance_) {
            geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        }
        if (!Object(ol_extent["E" /* intersects */])(this.extent_, geometry.getExtent())) {
            return;
        }
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
            }
            if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
            }
            var context = this.context_;
            var flatCoordinates = geometry.getOrientedFlatCoordinates();
            var offset = 0;
            var endss = geometry.getEndss();
            var stride = geometry.getStride();
            context.beginPath();
            for (var i = 0, ii = endss.length; i < ii; ++i) {
                var ends = endss[i];
                offset = this.drawRings_(flatCoordinates, offset, ends, stride);
            }
            if (this.fillState_) {
                context.fill();
            }
            if (this.strokeState_) {
                context.stroke();
            }
        }
        if (this.text_ !== '') {
            var flatInteriorPoints = geometry.getFlatInteriorPoints();
            this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
    };
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */
    CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
        var context = this.context_;
        var contextFillState = this.contextFillState_;
        if (!contextFillState) {
            context.fillStyle = fillState.fillStyle;
            this.contextFillState_ = {
                fillStyle: fillState.fillStyle,
            };
        }
        else {
            if (contextFillState.fillStyle != fillState.fillStyle) {
                contextFillState.fillStyle = fillState.fillStyle;
                context.fillStyle = fillState.fillStyle;
            }
        }
    };
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */
    CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
        var context = this.context_;
        var contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
            context.lineCap = strokeState.lineCap;
            if (context.setLineDash) {
                context.setLineDash(strokeState.lineDash);
                context.lineDashOffset = strokeState.lineDashOffset;
            }
            context.lineJoin = strokeState.lineJoin;
            context.lineWidth = strokeState.lineWidth;
            context.miterLimit = strokeState.miterLimit;
            context.strokeStyle = strokeState.strokeStyle;
            this.contextStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineDashOffset: strokeState.lineDashOffset,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle,
            };
        }
        else {
            if (contextStrokeState.lineCap != strokeState.lineCap) {
                contextStrokeState.lineCap = strokeState.lineCap;
                context.lineCap = strokeState.lineCap;
            }
            if (context.setLineDash) {
                if (!Object(array["b" /* equals */])(contextStrokeState.lineDash, strokeState.lineDash)) {
                    context.setLineDash((contextStrokeState.lineDash = strokeState.lineDash));
                }
                if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                    contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                    context.lineDashOffset = strokeState.lineDashOffset;
                }
            }
            if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                contextStrokeState.lineJoin = strokeState.lineJoin;
                context.lineJoin = strokeState.lineJoin;
            }
            if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                contextStrokeState.lineWidth = strokeState.lineWidth;
                context.lineWidth = strokeState.lineWidth;
            }
            if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                contextStrokeState.miterLimit = strokeState.miterLimit;
                context.miterLimit = strokeState.miterLimit;
            }
            if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                contextStrokeState.strokeStyle = strokeState.strokeStyle;
                context.strokeStyle = strokeState.strokeStyle;
            }
        }
    };
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */
    CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
        var context = this.context_;
        var contextTextState = this.contextTextState_;
        var textAlign = textState.textAlign
            ? textState.textAlign
            : render_canvas["l" /* defaultTextAlign */];
        if (!contextTextState) {
            context.font = textState.font;
            context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
            context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
            this.contextTextState_ = {
                font: textState.font,
                textAlign: textAlign,
                textBaseline: textState.textBaseline,
            };
        }
        else {
            if (contextTextState.font != textState.font) {
                contextTextState.font = textState.font;
                context.font = textState.font;
            }
            if (contextTextState.textAlign != textAlign) {
                contextTextState.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
                context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
            }
            if (contextTextState.textBaseline != textState.textBaseline) {
                contextTextState.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
                context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
            }
        }
    };
    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */
    CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
        var _this = this;
        if (!fillStyle) {
            this.fillState_ = null;
        }
        else {
            var fillStyleColor = fillStyle.getColor();
            this.fillState_ = {
                fillStyle: Object(colorlike["a" /* asColorLike */])(fillStyleColor ? fillStyleColor : render_canvas["b" /* defaultFillStyle */]),
            };
        }
        if (!strokeStyle) {
            this.strokeState_ = null;
        }
        else {
            var strokeStyleColor = strokeStyle.getColor();
            var strokeStyleLineCap = strokeStyle.getLineCap();
            var strokeStyleLineDash = strokeStyle.getLineDash();
            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            var strokeStyleLineJoin = strokeStyle.getLineJoin();
            var strokeStyleWidth = strokeStyle.getWidth();
            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            var lineDash = strokeStyleLineDash
                ? strokeStyleLineDash
                : render_canvas["e" /* defaultLineDash */];
            this.strokeState_ = {
                lineCap: strokeStyleLineCap !== undefined
                    ? strokeStyleLineCap
                    : render_canvas["d" /* defaultLineCap */],
                lineDash: this.pixelRatio_ === 1
                    ? lineDash
                    : lineDash.map(function (n) { return n * _this.pixelRatio_; }),
                lineDashOffset: (strokeStyleLineDashOffset
                    ? strokeStyleLineDashOffset
                    : render_canvas["f" /* defaultLineDashOffset */]) * this.pixelRatio_,
                lineJoin: strokeStyleLineJoin !== undefined
                    ? strokeStyleLineJoin
                    : render_canvas["g" /* defaultLineJoin */],
                lineWidth: (strokeStyleWidth !== undefined
                    ? strokeStyleWidth
                    : render_canvas["h" /* defaultLineWidth */]) * this.pixelRatio_,
                miterLimit: strokeStyleMiterLimit !== undefined
                    ? strokeStyleMiterLimit
                    : render_canvas["i" /* defaultMiterLimit */],
                strokeStyle: Object(colorlike["a" /* asColorLike */])(strokeStyleColor ? strokeStyleColor : render_canvas["k" /* defaultStrokeStyle */]),
            };
        }
    };
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     */
    CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
        var imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
            this.image_ = null;
            return;
        }
        var imageAnchor = imageStyle.getAnchor();
        var imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;
        this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;
        this.imageHeight_ = imageSize[1] * this.pixelRatio_;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        this.imageScale_ = imageStyle.getScaleArray();
        this.imageWidth_ = imageSize[0] * this.pixelRatio_;
    };
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     */
    CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
        if (!textStyle) {
            this.text_ = '';
        }
        else {
            var textFillStyle = textStyle.getFill();
            if (!textFillStyle) {
                this.textFillState_ = null;
            }
            else {
                var textFillStyleColor = textFillStyle.getColor();
                this.textFillState_ = {
                    fillStyle: Object(colorlike["a" /* asColorLike */])(textFillStyleColor ? textFillStyleColor : render_canvas["b" /* defaultFillStyle */]),
                };
            }
            var textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) {
                this.textStrokeState_ = null;
            }
            else {
                var textStrokeStyleColor = textStrokeStyle.getColor();
                var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                var textStrokeStyleWidth = textStrokeStyle.getWidth();
                var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                this.textStrokeState_ = {
                    lineCap: textStrokeStyleLineCap !== undefined
                        ? textStrokeStyleLineCap
                        : render_canvas["d" /* defaultLineCap */],
                    lineDash: textStrokeStyleLineDash
                        ? textStrokeStyleLineDash
                        : render_canvas["e" /* defaultLineDash */],
                    lineDashOffset: textStrokeStyleLineDashOffset
                        ? textStrokeStyleLineDashOffset
                        : render_canvas["f" /* defaultLineDashOffset */],
                    lineJoin: textStrokeStyleLineJoin !== undefined
                        ? textStrokeStyleLineJoin
                        : render_canvas["g" /* defaultLineJoin */],
                    lineWidth: textStrokeStyleWidth !== undefined
                        ? textStrokeStyleWidth
                        : render_canvas["h" /* defaultLineWidth */],
                    miterLimit: textStrokeStyleMiterLimit !== undefined
                        ? textStrokeStyleMiterLimit
                        : render_canvas["i" /* defaultMiterLimit */],
                    strokeStyle: Object(colorlike["a" /* asColorLike */])(textStrokeStyleColor ? textStrokeStyleColor : render_canvas["k" /* defaultStrokeStyle */]),
                };
            }
            var textFont = textStyle.getFont();
            var textOffsetX = textStyle.getOffsetX();
            var textOffsetY = textStyle.getOffsetY();
            var textRotateWithView = textStyle.getRotateWithView();
            var textRotation = textStyle.getRotation();
            var textScale = textStyle.getScaleArray();
            var textText = textStyle.getText();
            var textTextAlign = textStyle.getTextAlign();
            var textTextBaseline = textStyle.getTextBaseline();
            this.textState_ = {
                font: textFont !== undefined ? textFont : render_canvas["c" /* defaultFont */],
                textAlign: textTextAlign !== undefined ? textTextAlign : render_canvas["l" /* defaultTextAlign */],
                textBaseline: textTextBaseline !== undefined
                    ? textTextBaseline
                    : render_canvas["m" /* defaultTextBaseline */],
            };
            this.text_ =
                textText !== undefined
                    ? Array.isArray(textText)
                        ? textText.reduce(function (acc, t, i) { return (acc += i % 2 ? ' ' : t); }, '')
                        : textText
                    : '';
            this.textOffsetX_ =
                textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
            this.textOffsetY_ =
                textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
            this.textRotateWithView_ =
                textRotateWithView !== undefined ? textRotateWithView : false;
            this.textRotation_ = textRotation !== undefined ? textRotation : 0;
            this.textScale_ = [
                this.pixelRatio_ * textScale[0],
                this.pixelRatio_ * textScale[1],
            ];
        }
    };
    return CanvasImmediateRenderer;
}(render_VectorContext));
/* harmony default export */ var Immediate = (Immediate_CanvasImmediateRenderer);
//# sourceMappingURL=Immediate.js.map
// EXTERNAL MODULE: ./node_modules/ol/style/IconAnchorUnits.js
var IconAnchorUnits = __webpack_require__("82b0");

// EXTERNAL MODULE: ./node_modules/ol/style/Icon.js + 1 modules
var Icon = __webpack_require__("6cbf");

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/hitdetect.js
/**
 * @module ol/render/canvas/hitdetect
 */








var HIT_DETECT_RESOLUTION = 0.5;
/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
    var width = size[0] * HIT_DETECT_RESOLUTION;
    var height = size[1] * HIT_DETECT_RESOLUTION;
    var context = Object(dom["a" /* createCanvasContext2D */])(width, height);
    context.imageSmoothingEnabled = false;
    var canvas = context.canvas;
    var renderer = new Immediate(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
    var featureCount = features.length;
    // Stretch hit detection index to use the whole available color range
    var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
    var featuresByZIndex = {};
    for (var i = 1; i <= featureCount; ++i) {
        var feature = features[i - 1];
        var featureStyleFunction = feature.getStyleFunction() || styleFunction;
        if (!styleFunction) {
            continue;
        }
        var styles = featureStyleFunction(feature, resolution);
        if (!styles) {
            continue;
        }
        if (!Array.isArray(styles)) {
            styles = [styles];
        }
        var index = i * indexFactor;
        var color = '#' + ('000000' + index.toString(16)).slice(-6);
        for (var j = 0, jj = styles.length; j < jj; ++j) {
            var originalStyle = styles[j];
            var geometry = originalStyle.getGeometryFunction()(feature);
            if (!geometry || !Object(ol_extent["E" /* intersects */])(extent, geometry.getExtent())) {
                continue;
            }
            var style = originalStyle.clone();
            var fill = style.getFill();
            if (fill) {
                fill.setColor(color);
            }
            var stroke = style.getStroke();
            if (stroke) {
                stroke.setColor(color);
                stroke.setLineDash(null);
            }
            style.setText(undefined);
            var image = originalStyle.getImage();
            if (image && image.getOpacity() !== 0) {
                var imgSize = image.getImageSize();
                if (!imgSize) {
                    continue;
                }
                var imgContext = Object(dom["a" /* createCanvasContext2D */])(imgSize[0], imgSize[1], undefined, { alpha: false });
                var img = imgContext.canvas;
                imgContext.fillStyle = color;
                imgContext.fillRect(0, 0, img.width, img.height);
                style.setImage(new Icon["a" /* default */]({
                    img: img,
                    imgSize: imgSize,
                    anchor: image.getAnchor(),
                    anchorXUnits: IconAnchorUnits["a" /* default */].PIXELS,
                    anchorYUnits: IconAnchorUnits["a" /* default */].PIXELS,
                    offset: image.getOrigin(),
                    opacity: 1,
                    size: image.getSize(),
                    scale: image.getScale(),
                    rotation: image.getRotation(),
                    rotateWithView: image.getRotateWithView(),
                }));
            }
            var zIndex = style.getZIndex() || 0;
            var byGeometryType = featuresByZIndex[zIndex];
            if (!byGeometryType) {
                byGeometryType = {};
                featuresByZIndex[zIndex] = byGeometryType;
                byGeometryType[GeometryType["a" /* default */].POLYGON] = [];
                byGeometryType[GeometryType["a" /* default */].CIRCLE] = [];
                byGeometryType[GeometryType["a" /* default */].LINE_STRING] = [];
                byGeometryType[GeometryType["a" /* default */].POINT] = [];
            }
            byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
        }
    }
    var zIndexKeys = Object.keys(featuresByZIndex)
        .map(Number)
        .sort(array["g" /* numberSafeCompareFunction */]);
    for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
        var byGeometryType = featuresByZIndex[zIndexKeys[i]];
        for (var type in byGeometryType) {
            var geomAndStyle = byGeometryType[type];
            for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
                renderer.setStyle(geomAndStyle[j + 1]);
                for (var k = 0, kk = transforms.length; k < kk; ++k) {
                    renderer.setTransform(transforms[k]);
                    renderer.drawGeometry(geomAndStyle[j]);
                }
            }
        }
    }
    return context.getImageData(0, 0, canvas.width, canvas.height);
}
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<import("../../Feature").FeatureLike>} features Features.
 */
function hitDetect(pixel, features, imageData) {
    var resultFeatures = [];
    if (imageData) {
        var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
        var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
        // The pixel coordinate is clamped down to the hit-detect canvas' size to account
        // for browsers returning coordinates slightly larger than the actual canvas size
        // due to a non-integer pixel ratio.
        var index = (Object(math["b" /* clamp */])(x, 0, imageData.width - 1) +
            Object(math["b" /* clamp */])(y, 0, imageData.height - 1) * imageData.width) *
            4;
        var r = imageData.data[index];
        var g = imageData.data[index + 1];
        var b = imageData.data[index + 2];
        var i = b + 256 * (g + 256 * r);
        var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
        if (i && i % indexFactor === 0) {
            resultFeatures.push(features[i / indexFactor - 1]);
        }
    }
    return resultFeatures;
}
//# sourceMappingURL=hitdetect.js.map
// EXTERNAL MODULE: ./node_modules/ol/css.js
var css = __webpack_require__("cd7e");

// EXTERNAL MODULE: ./node_modules/ol/ImageState.js
var ImageState = __webpack_require__("869f");

// CONCATENATED MODULE: ./node_modules/ol/renderer/vector.js
/**
 * @module ol/renderer/vector
 */




/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */
/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
var SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */
var GEOMETRY_RENDERERS = {
    'Point': renderPointGeometry,
    'LineString': renderLineStringGeometry,
    'Polygon': renderPolygonGeometry,
    'MultiPoint': renderMultiPointGeometry,
    'MultiLineString': renderMultiLineStringGeometry,
    'MultiPolygon': renderMultiPolygonGeometry,
    'GeometryCollection': renderGeometryCollectionGeometry,
    'Circle': renderCircleGeometry,
};
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */
function defaultOrder(feature1, feature2) {
    return parseInt(Object(util["c" /* getUid */])(feature1), 10) - parseInt(Object(util["c" /* getUid */])(feature2), 10);
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
function getSquaredTolerance(resolution, pixelRatio) {
    var tolerance = getTolerance(resolution, pixelRatio);
    return tolerance * tolerance;
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
function getTolerance(resolution, pixelRatio) {
    return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var fillStyle = style.getFill();
    var strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);
        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        circleReplay.drawCircle(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
    var loading = false;
    var imageStyle = style.getImage();
    if (imageStyle) {
        var imageState = imageStyle.getImageState();
        if (imageState == ImageState["a" /* default */].LOADED || imageState == ImageState["a" /* default */].ERROR) {
            imageStyle.unlistenImageChange(listener);
        }
        else {
            if (imageState == ImageState["a" /* default */].IDLE) {
                imageStyle.load();
            }
            imageState = imageStyle.getImageState();
            imageStyle.listenImageChange(listener);
            loading = true;
        }
    }
    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
    return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
    var geometry = style.getGeometryFunction()(feature);
    if (!geometry) {
        return;
    }
    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
    var renderer = style.getRenderer();
    if (renderer) {
        renderGeometry(replayGroup, simplifiedGeometry, style, feature);
    }
    else {
        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderGeometry(replayGroup, geometry, style, feature) {
    if (geometry.getType() == GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
        var geometries = 
        /** @type {import("../geom/GeometryCollection.js").default} */ (geometry).getGeometries();
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            renderGeometry(replayGroup, geometries[i], style, feature);
        }
        return;
    }
    var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);
    replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */ (geometry), feature, style.getRenderer(), style.getHitDetectionRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var geometries = geometry.getGeometriesArray();
    var i, ii;
    for (i = 0, ii = geometries.length; i < ii; ++i) {
        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var strokeStyle = style.getStroke();
    if (strokeStyle) {
        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawLineString(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var strokeStyle = style.getStroke();
    if (strokeStyle) {
        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawMultiLineString(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var fillStyle = style.getFill();
    var strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawMultiPolygon(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var imageStyle = style.getImage();
    var textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */
    var declutterImageWithText;
    if (opt_declutterBuilderGroup) {
        builderGroup = opt_declutterBuilderGroup;
        declutterImageWithText =
            imageStyle && textStyle && textStyle.getText() ? {} : undefined;
    }
    if (imageStyle) {
        if (imageStyle.getImageState() != ImageState["a" /* default */].LOADED) {
            return;
        }
        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var imageStyle = style.getImage();
    var textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */
    var declutterImageWithText;
    if (opt_declutterBuilderGroup) {
        builderGroup = opt_declutterBuilderGroup;
        declutterImageWithText =
            imageStyle && textStyle && textStyle.getText() ? {} : undefined;
    }
    if (imageStyle) {
        if (imageStyle.getImageState() != ImageState["a" /* default */].LOADED) {
            return;
        }
        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawMultiPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */
function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var fillStyle = style.getFill();
    var strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawPolygon(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
//# sourceMappingURL=vector.js.map
// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules
var proj = __webpack_require__("256f");

// EXTERNAL MODULE: ./node_modules/ol/coordinate.js
var ol_coordinate = __webpack_require__("a568");

// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/VectorLayer.js
var VectorLayer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/renderer/canvas/VectorLayer
 */













/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
var VectorLayer_CanvasVectorLayerRenderer = /** @class */ (function (_super) {
    VectorLayer_extends(CanvasVectorLayerRenderer, _super);
    /**
     * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
     */
    function CanvasVectorLayerRenderer(vectorLayer) {
        var _this = _super.call(this, vectorLayer) || this;
        /** @private */
        _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
        /**
         * @type {boolean}
         */
        _this.animatingOrInteracting_;
        /**
         * @private
         * @type {boolean}
         */
        _this.dirty_ = false;
        /**
         * @type {ImageData}
         */
        _this.hitDetectionImageData_ = null;
        /**
         * @type {Array<import("../../Feature.js").default>}
         */
        _this.renderedFeatures_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.renderedRevision_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.renderedResolution_ = NaN;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */
        _this.renderedExtent_ = Object(ol_extent["j" /* createEmpty */])();
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */
        _this.wrappedRenderedExtent_ = Object(ol_extent["j" /* createEmpty */])();
        /**
         * @private
         * @type {number}
         */
        _this.renderedRotation_;
        /**
         * @private
         * @type {import("../../coordinate").Coordinate}
         */
        _this.renderedCenter_ = null;
        /**
         * @private
         * @type {import("../../proj/Projection").default}
         */
        _this.renderedProjection_ = null;
        /**
         * @private
         * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
         */
        _this.renderedRenderOrder_ = null;
        /**
         * @private
         * @type {import("../../render/canvas/ExecutorGroup").default}
         */
        _this.replayGroup_ = null;
        /**
         * A new replay group had to be created by `prepareFrame()`
         * @type {boolean}
         */
        _this.replayGroupChanged = true;
        /**
         * @type {import("../../render/canvas/ExecutorGroup").default}
         */
        _this.declutterExecutorGroup = null;
        /**
         * Clipping to be performed by `renderFrame()`
         * @type {boolean}
         */
        _this.clipping = true;
        return _this;
    }
    /**
     * @param {ExecutorGroup} executorGroup Executor group.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     */
    CanvasVectorLayerRenderer.prototype.renderWorlds = function (executorGroup, frameState, opt_declutterTree) {
        var extent = frameState.extent;
        var viewState = frameState.viewState;
        var center = viewState.center;
        var resolution = viewState.resolution;
        var projection = viewState.projection;
        var rotation = viewState.rotation;
        var projectionExtent = projection.getExtent();
        var vectorSource = this.getLayer().getSource();
        var pixelRatio = frameState.pixelRatio;
        var viewHints = frameState.viewHints;
        var snapToPixel = !(viewHints[ViewHint["a" /* default */].ANIMATING] || viewHints[ViewHint["a" /* default */].INTERACTING]);
        var context = this.context;
        var width = Math.round(frameState.size[0] * pixelRatio);
        var height = Math.round(frameState.size[1] * pixelRatio);
        var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        var worldWidth = multiWorld ? Object(ol_extent["D" /* getWidth */])(projectionExtent) : null;
        var endWorld = multiWorld
            ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1
            : 1;
        var world = multiWorld
            ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)
            : 0;
        do {
            var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
            executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, opt_declutterTree);
        } while (++world < endWorld);
    };
    /**
     * Render declutter items for this layer
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     */
    CanvasVectorLayerRenderer.prototype.renderDeclutter = function (frameState) {
        if (this.declutterExecutorGroup) {
            this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
        }
    };
    /**
     * Render the layer.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */
    CanvasVectorLayerRenderer.prototype.renderFrame = function (frameState, target) {
        var pixelRatio = frameState.pixelRatio;
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        // set forward and inverse pixel transforms
        Object(ol_transform["e" /* makeScale */])(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
        Object(ol_transform["d" /* makeInverse */])(this.inversePixelTransform, this.pixelTransform);
        var canvasTransform = Object(ol_transform["g" /* toString */])(this.pixelTransform);
        this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
        var context = this.context;
        var canvas = context.canvas;
        var replayGroup = this.replayGroup_;
        var declutterExecutorGroup = this.declutterExecutorGroup;
        if ((!replayGroup || replayGroup.isEmpty()) &&
            (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
            return null;
        }
        // resize and clear
        var width = Math.round(frameState.size[0] * pixelRatio);
        var height = Math.round(frameState.size[1] * pixelRatio);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
            if (canvas.style.transform !== canvasTransform) {
                canvas.style.transform = canvasTransform;
            }
        }
        else if (!this.containerReused) {
            context.clearRect(0, 0, width, height);
        }
        this.preRender(context, frameState);
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        // clipped rendering if layer extent is set
        var clipped = false;
        var render = true;
        if (layerState.extent && this.clipping) {
            var layerExtent = Object(proj["k" /* fromUserExtent */])(layerState.extent, projection);
            render = Object(ol_extent["E" /* intersects */])(layerExtent, frameState.extent);
            clipped = render && !Object(ol_extent["g" /* containsExtent */])(layerExtent, frameState.extent);
            if (clipped) {
                this.clipUnrotated(context, frameState, layerExtent);
            }
        }
        if (render) {
            this.renderWorlds(replayGroup, frameState);
        }
        if (clipped) {
            context.restore();
        }
        this.postRender(context, frameState);
        var opacity = Object(css["g" /* cssOpacity */])(layerState.opacity);
        var container = this.container;
        if (opacity !== container.style.opacity) {
            container.style.opacity = opacity;
        }
        if (this.renderedRotation_ !== viewState.rotation) {
            this.renderedRotation_ = viewState.rotation;
            this.hitDetectionImageData_ = null;
        }
        return this.container;
    };
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
     */
    CanvasVectorLayerRenderer.prototype.getFeatures = function (pixel) {
        return new Promise(
        /**
         * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
         * @this {CanvasVectorLayerRenderer}
         */
        function (resolve) {
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                var size = [this.context.canvas.width, this.context.canvas.height];
                Object(ol_transform["a" /* apply */])(this.pixelTransform, size);
                var center = this.renderedCenter_;
                var resolution = this.renderedResolution_;
                var rotation = this.renderedRotation_;
                var projection = this.renderedProjection_;
                var extent = this.wrappedRenderedExtent_;
                var layer = this.getLayer();
                var transforms = [];
                var width = size[0] * HIT_DETECT_RESOLUTION;
                var height = size[1] * HIT_DETECT_RESOLUTION;
                transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());
                var source = layer.getSource();
                var projectionExtent = projection.getExtent();
                if (source.getWrapX() &&
                    projection.canWrapX() &&
                    !Object(ol_extent["g" /* containsExtent */])(projectionExtent, extent)) {
                    var startX = extent[0];
                    var worldWidth = Object(ol_extent["D" /* getWidth */])(projectionExtent);
                    var world = 0;
                    var offsetX = void 0;
                    while (startX < projectionExtent[0]) {
                        --world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                        startX += worldWidth;
                    }
                    world = 0;
                    startX = extent[2];
                    while (startX > projectionExtent[2]) {
                        ++world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                        startX -= worldWidth;
                    }
                }
                this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
            }
            resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
        }.bind(this));
    };
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
        var _this = this;
        if (!this.replayGroup_) {
            return undefined;
        }
        var resolution = frameState.viewState.resolution;
        var rotation = frameState.viewState.rotation;
        var layer = this.getLayer();
        /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */
        var features = {};
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
         * @param {number} distanceSq The squared distance to the click position
         * @return {T|undefined} Callback result.
         */
        var featureCallback = function (feature, geometry, distanceSq) {
            var key = Object(util["c" /* getUid */])(feature);
            var match = features[key];
            if (!match) {
                if (distanceSq === 0) {
                    features[key] = true;
                    return callback(feature, layer, geometry);
                }
                matches.push((features[key] = {
                    feature: feature,
                    layer: layer,
                    geometry: geometry,
                    distanceSq: distanceSq,
                    callback: callback,
                }));
            }
            else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                    features[key] = true;
                    matches.splice(matches.lastIndexOf(match), 1);
                    return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
            }
            return undefined;
        };
        var result;
        var executorGroups = [this.replayGroup_];
        if (this.declutterExecutorGroup) {
            executorGroups.push(this.declutterExecutorGroup);
        }
        executorGroups.some(function (executorGroup) {
            return (result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup &&
                frameState.declutterTree
                ? frameState.declutterTree.all().map(function (item) { return item.value; })
                : null));
        });
        return result;
    };
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     */
    CanvasVectorLayerRenderer.prototype.handleFontsChanged = function () {
        var layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) {
            layer.changed();
        }
    };
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
        this.renderIfReadyAndVisible();
    };
    /**
     * Determine whether render should be called.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    CanvasVectorLayerRenderer.prototype.prepareFrame = function (frameState) {
        var vectorLayer = this.getLayer();
        var vectorSource = vectorLayer.getSource();
        if (!vectorSource) {
            return false;
        }
        var animating = frameState.viewHints[ViewHint["a" /* default */].ANIMATING];
        var interacting = frameState.viewHints[ViewHint["a" /* default */].INTERACTING];
        var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if ((!this.dirty_ && !updateWhileAnimating && animating) ||
            (!updateWhileInteracting && interacting)) {
            this.animatingOrInteracting_ = true;
            return true;
        }
        this.animatingOrInteracting_ = false;
        var frameStateExtent = frameState.extent;
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        var resolution = viewState.resolution;
        var pixelRatio = frameState.pixelRatio;
        var vectorLayerRevision = vectorLayer.getRevision();
        var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === undefined) {
            vectorLayerRenderOrder = defaultOrder;
        }
        var center = viewState.center.slice();
        var extent = Object(ol_extent["c" /* buffer */])(frameStateExtent, vectorLayerRenderBuffer * resolution);
        var renderedExtent = extent.slice();
        var loadExtents = [extent.slice()];
        var projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() &&
            projection.canWrapX() &&
            !Object(ol_extent["g" /* containsExtent */])(projectionExtent, frameState.extent)) {
            // For the replay group, we need an extent that intersects the real world
            // (-180° to +180°). To support geometries in a coordinate range from -540°
            // to +540°, we add at least 1 world width on each side of the projection
            // extent. If the viewport is wider than the world, we need to add half of
            // the viewport width to make sure we cover the whole viewport.
            var worldWidth = Object(ol_extent["D" /* getWidth */])(projectionExtent);
            var gutter = Math.max(Object(ol_extent["D" /* getWidth */])(extent) / 2, worldWidth);
            extent[0] = projectionExtent[0] - gutter;
            extent[2] = projectionExtent[2] + gutter;
            Object(ol_coordinate["j" /* wrapX */])(center, projection);
            var loadExtent = Object(ol_extent["I" /* wrapX */])(loadExtents[0], projection);
            // If the extent crosses the date line, we load data for both edges of the worlds
            if (loadExtent[0] < projectionExtent[0] &&
                loadExtent[2] < projectionExtent[2]) {
                loadExtents.push([
                    loadExtent[0] + worldWidth,
                    loadExtent[1],
                    loadExtent[2] + worldWidth,
                    loadExtent[3],
                ]);
            }
            else if (loadExtent[0] > projectionExtent[0] &&
                loadExtent[2] > projectionExtent[2]) {
                loadExtents.push([
                    loadExtent[0] - worldWidth,
                    loadExtent[1],
                    loadExtent[2] - worldWidth,
                    loadExtent[3],
                ]);
            }
        }
        if (!this.dirty_ &&
            this.renderedResolution_ == resolution &&
            this.renderedRevision_ == vectorLayerRevision &&
            this.renderedRenderOrder_ == vectorLayerRenderOrder &&
            Object(ol_extent["g" /* containsExtent */])(this.wrappedRenderedExtent_, extent)) {
            if (!Object(array["b" /* equals */])(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
            }
            this.renderedCenter_ = center;
            this.replayGroupChanged = false;
            return true;
        }
        this.replayGroup_ = null;
        this.dirty_ = false;
        var replayGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
        var declutterBuilderGroup;
        if (this.getLayer().getDeclutter()) {
            declutterBuilderGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
        }
        var userProjection = Object(proj["q" /* getUserProjection */])();
        var userTransform;
        if (userProjection) {
            for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                var extent_1 = loadExtents[i];
                var userExtent_1 = Object(proj["s" /* toUserExtent */])(extent_1, projection);
                vectorSource.loadFeatures(userExtent_1, Object(proj["t" /* toUserResolution */])(resolution, projection), userProjection);
            }
            userTransform = Object(proj["p" /* getTransformFromProjections */])(userProjection, projection);
        }
        else {
            for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                vectorSource.loadFeatures(loadExtents[i], resolution, projection);
            }
        }
        var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
        var render = 
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         * @this {CanvasVectorLayerRenderer}
         */
        function (feature) {
            var styles;
            var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) {
                styles = styleFunction(feature, resolution);
            }
            if (styles) {
                var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                this.dirty_ = this.dirty_ || dirty;
            }
        }.bind(this);
        var userExtent = Object(proj["s" /* toUserExtent */])(extent, projection);
        /** @type {Array<import("../../Feature.js").default>} */
        var features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) {
            features.sort(vectorLayerRenderOrder);
        }
        for (var i = 0, ii = features.length; i < ii; ++i) {
            render(features[i]);
        }
        this.renderedFeatures_ = features;
        var replayGroupInstructions = replayGroup.finish();
        var executorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
        if (declutterBuilderGroup) {
            this.declutterExecutorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
        }
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
    };
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
     * @param {import("../../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
     * @return {boolean} `true` if an image is loading.
     */
    CanvasVectorLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
        if (!styles) {
            return false;
        }
        var loading = false;
        if (Array.isArray(styles)) {
            for (var i = 0, ii = styles.length; i < ii; ++i) {
                loading =
                    renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
            }
        }
        else {
            loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
        }
        return loading;
    };
    return CanvasVectorLayerRenderer;
}(canvas_Layer["a" /* default */]));
/* harmony default export */ var canvas_VectorLayer = (VectorLayer_CanvasVectorLayerRenderer);
//# sourceMappingURL=VectorLayer.js.map
// CONCATENATED MODULE: ./node_modules/ol/layer/Vector.js
var Vector_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/Vector
 */


/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */
var Vector_VectorLayer = /** @class */ (function (_super) {
    Vector_extends(VectorLayer, _super);
    /**
     * @param {import("./BaseVector.js").Options<VectorSourceType>} [opt_options] Options.
     */
    function VectorLayer(opt_options) {
        return _super.call(this, opt_options) || this;
    }
    VectorLayer.prototype.createRenderer = function () {
        return new canvas_VectorLayer(this);
    };
    return VectorLayer;
}(BaseVector));
/* harmony default export */ var Vector = __webpack_exports__["a"] = (Vector_VectorLayer);
//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "3f8c":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "408a":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ "40d5":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "40db":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABG1JREFUeNq0l11oHFUUx/+z2USXrtklNiZpJKQBRQpNNmkxotWuhRo/WlzqQyEBE8ES7YNJIPXjwTYtPliptD7YgiLpigiCNfUhUBRJqJFoi+62gQoabRobrRWbzX5lZ3ZmrufOV2e3+5nUC4c7c3dmfvd/77nnnBVQZpNuwEedN2s4UlWDcDnfEUqE+anrJQvkgFpwstNkQZrE5KrAhrqjZP6Ml5wZt2AKiWUR+xAHD5W7Cia0j4yZJsf7mJqeYPmaKoeYnBhk0qKX2d7rKxc6ar6cjvqZqlxmJTd1kcmxgB0+Wip00HxJWR5hK22KOGqHDxZ1otsBzQP353Uu+jFEnc9RGUCFewzvv/UGZi/NoOu5bjxJdubUp/h7YR5tnVtw7eo8vvt6HI9sf0b7LV9TkkNQxWP8MkzO1n4L2HCEUQheOKtDuHD+Ks58NoC9r3Vg/8AEEvEG1DVE0PVsC4InfkX9Ohm7etbhi0+u4L7WfvS+8npuMnm7HG0HU+f43QsEP8kvHLZHerUBUis4mrWBusY7sOYuEe9+1IG6+r8I2oSHt3lw6FgL9h1aj7bNFQT3IPz9VIED64XjzoEMhgUmtV7zrNoeotmKZDHNnn95LYLHL+D44Z9IuQi3Ow5Gaq4tLJHNY6h7B6Zo6XM1R5V1qvwGC05jwGfOTqjw2XfdAKfQcr+MIx96MLznOj4+IaJ1M9C2ScUTO1PUk/ewXzDcfxG+zhm4qz23qObf1QKNzpo0l1pTmwk1FUfpo7pqrvLIBwIpvE57u6hHK7K1tXF4qkVs6vwHsz/P5F7xm9HOn73HOZqoQ6GDee92xzC8P0GwBAKPyRCTKUSjKiJLwAOtMg6/ujc32JEZ4guDmbnUUd3UGGRpGcmEgp4XU9iyTcI7B104+00lvhqvQv29Mlyu37Fnx6MI/zBV8NNFFevQGBQ5ieWkjHicdBu2c3cKDU0Kxk9VQVEZlkj107uTeHDrNILvvV3wy6ZzaYcM+lnL2GNVSSEtqRBpDikyrU/pPbcNPgk3/hUw86NTm9TddQoaGhnOTV5BPLpkOZqatjLlnF2x5m78kDMbXJZVWlYVMVptu3GAaVz5hg4RNfeo5FhOhL51oespFRvbZzMcjckWOGyBjbw5p29r0Hp44Q9BhxmAbGA8QQeOuwGjM/KQiO2BZfy5IGBf/xpMn61FfWOTrlY6aak1c7Q9ZI5Qd4BHLR4y+dl786UeKNIYPDUMikJxV+arQMavlfz7N3upFp9Pz99cudjjpuKDBB7JBnN/v8xLmwrXCEWwA9o4j0a/5Tmb+VrXrm7ycEMtJQieKIzSaD2BI4VzsTS26rTIqxJbRVI0J09oD9ILhUqdMqETpVQgXp6XV1MQKKmjdmjITAxlw9ORZq2aKAqk7eE1mq3qyAstVt5qnp6dZRyVWeWtHIbKvTazxLU8eEUFPcGbDXihYj67qOfQuVX/k7BNImDk0622Ip8HhC+Nmuo0/u9meH/pjnMbwV5jG1bU/hNgAB37KNknzJD1AAAAAElFTkSuQmCC"

/***/ }),

/***/ "4105":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return centroid; });
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("4334");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0b2d");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("38f3");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/Pointer
 */



/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */
/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
var PointerInteraction = /** @class */ (function (_super) {
    __extends(PointerInteraction, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function PointerInteraction(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this, 
        /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
        if (options.handleDownEvent) {
            _this.handleDownEvent = options.handleDownEvent;
        }
        if (options.handleDragEvent) {
            _this.handleDragEvent = options.handleDragEvent;
        }
        if (options.handleMoveEvent) {
            _this.handleMoveEvent = options.handleMoveEvent;
        }
        if (options.handleUpEvent) {
            _this.handleUpEvent = options.handleUpEvent;
        }
        if (options.stopDown) {
            _this.stopDown = options.stopDown;
        }
        /**
         * @type {boolean}
         * @protected
         */
        _this.handlingDownUpSequence = false;
        /**
         * @type {!Object<string, PointerEvent>}
         * @private
         */
        _this.trackedPointers_ = {};
        /**
         * @type {Array<PointerEvent>}
         * @protected
         */
        _this.targetPointers = [];
        return _this;
    }
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */
    PointerInteraction.prototype.getPointerCount = function () {
        return this.targetPointers.length;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
        return false;
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) { };
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) {
            return true;
        }
        var stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);
        if (this.handlingDownUpSequence) {
            if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERDRAG) {
                this.handleDragEvent(mapBrowserEvent);
                // prevent page scrolling during dragging
                mapBrowserEvent.originalEvent.preventDefault();
            }
            else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERUP) {
                var handledUp = this.handleUpEvent(mapBrowserEvent);
                this.handlingDownUpSequence =
                    handledUp && this.targetPointers.length > 0;
            }
        }
        else {
            if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERDOWN) {
                var handled = this.handleDownEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handled;
                stopEvent = this.stopDown(handled);
            }
            else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERMOVE) {
                this.handleMoveEvent(mapBrowserEvent);
            }
        }
        return !stopEvent;
    };
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) { };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
        return false;
    };
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    PointerInteraction.prototype.stopDown = function (handled) {
        return handled;
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
    PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
        if (isPointerDraggingEvent(mapBrowserEvent)) {
            var event_1 = mapBrowserEvent.originalEvent;
            var id = event_1.pointerId.toString();
            if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERUP) {
                delete this.trackedPointers_[id];
            }
            else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERDOWN) {
                this.trackedPointers_[id] = event_1;
            }
            else if (id in this.trackedPointers_) {
                // update only when there was a pointerdown event for this pointer
                this.trackedPointers_[id] = event_1;
            }
            this.targetPointers = Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__[/* getValues */ "c"])(this.trackedPointers_);
        }
    };
    return PointerInteraction;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */
function centroid(pointerEvents) {
    var length = pointerEvents.length;
    var clientX = 0;
    var clientY = 0;
    for (var i = 0; i < length; i++) {
        clientX += pointerEvents[i].clientX;
        clientY += pointerEvents[i].clientY;
    }
    return [clientX / length, clientY / length];
}
/**
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */
function isPointerDraggingEvent(mapBrowserEvent) {
    var type = mapBrowserEvent.type;
    return (type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERDOWN ||
        type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERDRAG ||
        type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINTERUP);
}
/* harmony default export */ __webpack_exports__["b"] = (PointerInteraction);
//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "4218":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track07.90611e0b.png";

/***/ }),

/***/ "42f5":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGc0lEQVR4nIWVe3CU1RnGf+fb3ewmX3Zzv5F7mqCwBmgMF2UABZJwKUpREJmpddo4Io4Ccq2tgyKFtil2LFY7CoidgiBUUBR1AmWU0BJAtATkEgKShNwgu9lNdjfZ29s/NmstZegzc2bOnMvznvO85z2PCofDACilGEQVMK/X5x/b8O2N3BNNXbZr3X00tfWgGQ3C4LJwIKTyMmzkp1opK0xzlxamtiTFW+qB3cCnACKCEpEocTWwZmvt2ZzNn5zmUoeLzMQ4CnOSGJKkYy9IJVk3g1IgQnffAOeu3qDN6eVSq4N2h4fc1Hiqq0p5atbIVgPqRWBLNEDNiaau5VXLd5KeEMeSR8Zwd3E6Lo+fxjYnX1++zrkOF91OL1arhTiTgcxknZJ0GxmJcaQnxFGYlcDJi51s3FVPa5ebvesfpmpU3kYlIk909HjfzHrkdWqqJ/JoxV3U7DzGrrpGOs63E1ucwczyAowGA/5AkPf/2QSOPrCYoKuXnPICcpLiaG52MHfSHaxcMI4dtWdZ8cpnfPPeIpSInFv458N3Nl93897KGaTPewNflwuVrPPhmtn8aEwRAG7PADbdTIfTQ9kzf6W91clPZ41i27Jp1P6rhcpFfwEFluR4XHufoXLNXvLSrGgiEt/Y3iM/n2qXJ/50SHwOj5CVKJqmSUOrU557+4gYH3xVEip/L6mPvSWZSbr8bOZIwTMgxVkJ0ufzS7fbJ1hMQoZN+h0eeeqNv8uTVaVyzeERI9BlNmo5TR0uudjWA9ZIIkMxRp5/7SC4fGCLZcK9xayaPxaALxpaIUnnhY2fUlFeQIrVDAKIgB7Dl5evM37YEGKMmjIqpS7kpVnLzCaDijEaIDz4qsICoTAL5o/l9UWTSdDN3HB5mb32A44ca4KEOPAHMRkNhMOAEkBBWMhPs3Ld7cOemxLWRKRmTElmoNcXkB8WpQmBkABCr082LK6Q7Sumy44vLsjQ6q2SNrVGPtj/taCbBaUEJAJEEBXZFxIp/0G6NDR3yx3ZiU5NKfXVffbspnOtDpWXGq8QFD6/GpKfqlbPKVdnmrvViYZWNaksXy19eopatbhClRZnKHx+Bag4s0nFxhgViAIUIio/3abaHR5VMTLvtBGgKDPhkHcgeGd2cjzEmsDnJz/dSpfLS1aSzuYV0yPVPtg6nV4aTl0FTdF8oxeHux80BcEQhsRYNAWaUhSk2/ZFC23sS7vqjyXpZrbXXeT4qasoWyzfFbnbByZDpO8PRmpgUEl0cyRfSkGPlwcr7RRnJJBqs7B6TvkQ4yBFffVU+9nn3j5iXzBhKMePXkJ0CwSC4PWzcUkl2ck6Ahg0hUJhNGocamjltXePQZw5coBgiHn3FLPpwGn2rpqxH2jXIikSslPiN+mWGLISdckqyRACQcGgCTFGmVGWL4u3HJFl247KxOHZUr3uQ3mr9ozcb88WUIJRE7wDMmp0ofgCQbHnJpOZpNeICBr/wZZnZ47o3H/yilo2+25w90euHQzhD4XZtXwa25dUoFtM7Hl5Di8/Oo4ezwDf6egZYNXsMrYc/EYtfWDUV8ARAE0pFf2qg6MK034dY9TITdFViT1b0devMBmUiKgH1n+k5vzuE9VyvVfNWr1brXinTukWk8KgKVw+NXnycNXh9KrCdBv23JRnoxagon4QHejs8V55fNPBgscnD5P5v9gNMUb2/2Yufb4ARqNGxYhcDtRfJt5q5kyLg+c3HUKLNVH727ks3VqnDq/98cFkq6UiagPf94Moxq/bfaLOHwzh7g/w6ubPISOBBINGapqVj345i3FLdhDUNDwDAehwsXXDw3x88gpTR+SysKo0B7gWJdNuZgeO/mru6C31jZ3cN3wI0yvvgo4eXG4fjr4BUuItuHq8eHp9cM3J2mVVdLt9ePuDLKwqXfR9ciBia7doqsPpOV++fKdcaHPKjBf+JoxbK8x8RSpe2idM2iBMXC+r36mTPf9olKKF2yQQDL17K65bSRRFyaHTLWce+2NtzNanp9Dc1cuB401cbncxuiSDefcPo7Glm/Xvf8mpPyw4mZEYdy8QuJnkv5L8P5NK3XO501U758V9+tDcZKaNLsKqx/Bth5s9h8+RZLXw8bqHThk0NV5E+m/JcbsAg0GKgTd3fH5hwmcnrxi9AwFJs8WphyaUuKeMzNsGLL6NCreV6Gb8BHgSsABtwErg/P/b9G+cewZg7yQbJgAAAABJRU5ErkJggg=="

/***/ }),

/***/ "4334":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return pan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return zoomByDelta; });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("bf62");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ca42");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/Interaction
 */



/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */
/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
var Interaction = /** @class */ (function (_super) {
    __extends(Interaction, _super);
    /**
     * @param {InteractionOptions} [opt_options] Options.
     */
    function Interaction(opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {InteractionOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {InteractionOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {InteractionOnSignature<void>}
         */
        _this.un;
        if (opt_options && opt_options.handleEvent) {
            _this.handleEvent = opt_options.handleEvent;
        }
        /**
         * @private
         * @type {import("../PluggableMap.js").default|null}
         */
        _this.map_ = null;
        _this.setActive(true);
        return _this;
    }
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */
    Interaction.prototype.getActive = function () {
        return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ACTIVE));
    };
    /**
     * Get the map associated with this interaction.
     * @return {import("../PluggableMap.js").default|null} Map.
     * @api
     */
    Interaction.prototype.getMap = function () {
        return this.map_;
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    Interaction.prototype.handleEvent = function (mapBrowserEvent) {
        return true;
    };
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
    Interaction.prototype.setActive = function (active) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ACTIVE, active);
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default|null} map Map.
     */
    Interaction.prototype.setMap = function (map) {
        this.map_ = map;
    };
    return Interaction;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [opt_duration] Duration.
 */
function pan(view, delta, opt_duration) {
    var currentCenter = view.getCenterInternal();
    if (currentCenter) {
        var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
        view.animateInternal({
            duration: opt_duration !== undefined ? opt_duration : 250,
            easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__[/* linear */ "d"],
            center: view.getConstrainedCenter(center),
        });
    }
}
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [opt_anchor] Anchor coordinate in the user projection.
 * @param {number} [opt_duration] Duration.
 */
function zoomByDelta(view, delta, opt_anchor, opt_duration) {
    var currentZoom = view.getZoom();
    if (currentZoom === undefined) {
        return;
    }
    var newZoom = view.getConstrainedZoom(currentZoom + delta);
    var newResolution = view.getResolutionForZoom(newZoom);
    if (view.getAnimating()) {
        view.cancelAnimations();
    }
    view.animate({
        resolution: newResolution,
        anchor: opt_anchor,
        duration: opt_duration !== undefined ? opt_duration : 250,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__[/* easeOut */ "b"],
    });
}
/* harmony default export */ __webpack_exports__["a"] = (Interaction);
//# sourceMappingURL=Interaction.js.map

/***/ }),

/***/ "44a9":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "44ad":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");

var Object = global.Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "44de":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "44e7":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var classof = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "465d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "466d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var call = __webpack_require__("c65b");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");
var getMethod = __webpack_require__("dc4a");
var advanceStringIndex = __webpack_require__("8aa5");
var regExpExec = __webpack_require__("14c3");

// @@match logic
fixRegExpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : getMethod(regexp, MATCH);
      return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (string) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(nativeMatch, rx, S);

      if (res.done) return res.value;

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = toString(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "4763":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "47e4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("521b");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("f623");
/* harmony import */ var _LineString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("7a09");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("9abc");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("9769");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("0af5");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("abb7");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("1c48");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("9f5e");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("bb6c");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("b1a2");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("c560");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/MultiLineString
 */












/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
var MultiLineString = /** @class */ (function (_super) {
    __extends(MultiLineString, _super);
    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `opt_layout` and `opt_ends` are also accepted.)
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.
     */
    function MultiLineString(coordinates, opt_layout, opt_ends) {
        var _this = _super.call(this) || this;
        /**
         * @type {Array<number>}
         * @private
         */
        _this.ends_ = [];
        /**
         * @private
         * @type {number}
         */
        _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates[0])) {
            _this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
        }
        else if (opt_layout !== undefined && opt_ends) {
            _this.setFlatCoordinates(opt_layout, 
            /** @type {Array<number>} */ (coordinates));
            _this.ends_ = opt_ends;
        }
        else {
            var layout = _this.getLayout();
            var lineStrings = /** @type {Array<LineString>} */ (coordinates);
            var flatCoordinates = [];
            var ends = [];
            for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
                var lineString = lineStrings[i];
                if (i === 0) {
                    layout = lineString.getLayout();
                }
                Object(_array_js__WEBPACK_IMPORTED_MODULE_8__[/* extend */ "c"])(flatCoordinates, lineString.getFlatCoordinates());
                ends.push(flatCoordinates.length);
            }
            _this.setFlatCoordinates(layout, flatCoordinates);
            _this.ends_ = ends;
        }
        return _this;
    }
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */
    MultiLineString.prototype.appendLineString = function (lineString) {
        if (!this.flatCoordinates) {
            this.flatCoordinates = lineString.getFlatCoordinates().slice();
        }
        else {
            Object(_array_js__WEBPACK_IMPORTED_MODULE_8__[/* extend */ "c"])(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     */
    MultiLineString.prototype.clone = function () {
        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        multiLineString.applyProperties(this);
        return multiLineString;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__[/* closestSquaredDistanceXY */ "e"])(this.getExtent(), x, y)) {
            return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_4__[/* arrayMaxSquaredDelta */ "a"])(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_4__[/* assignClosestArrayPoint */ "b"])(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `opt_interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `opt_interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
        if ((this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].XYM &&
            this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].XYZM) ||
            this.flatCoordinates.length === 0) {
            return null;
        }
        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
        return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__[/* lineStringsCoordinateAtM */ "c"])(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
    };
    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */
    MultiLineString.prototype.getCoordinates = function () {
        return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_9__[/* inflateCoordinatesArray */ "b"])(this.flatCoordinates, 0, this.ends_, this.stride);
    };
    /**
     * @return {Array<number>} Ends.
     */
    MultiLineString.prototype.getEnds = function () {
        return this.ends_;
    };
    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */
    MultiLineString.prototype.getLineString = function (index) {
        if (index < 0 || this.ends_.length <= index) {
            return null;
        }
        return new _LineString_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    };
    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */
    MultiLineString.prototype.getLineStrings = function () {
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var layout = this.layout;
        /** @type {Array<LineString>} */
        var lineStrings = [];
        var offset = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var lineString = new _LineString_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](flatCoordinates.slice(offset, end), layout);
            lineStrings.push(lineString);
            offset = end;
        }
        return lineStrings;
    };
    /**
     * @return {Array<number>} Flat midpoints.
     */
    MultiLineString.prototype.getFlatMidpoints = function () {
        var midpoints = [];
        var flatCoordinates = this.flatCoordinates;
        var offset = 0;
        var ends = this.ends_;
        var stride = this.stride;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var midpoint = Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__[/* interpolatePoint */ "a"])(flatCoordinates, offset, end, stride, 0.5);
            Object(_array_js__WEBPACK_IMPORTED_MODULE_8__[/* extend */ "c"])(midpoints, midpoint);
            offset = end;
        }
        return midpoints;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     */
    MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__[/* douglasPeuckerArray */ "b"])(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new MultiLineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].XY, simplifiedEnds);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    MultiLineString.prototype.getType = function () {
        return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_LINE_STRING;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    MultiLineString.prototype.intersectsExtent = function (extent) {
        return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_11__[/* intersectsLineStringArray */ "b"])(this.flatCoordinates, 0, this.ends_, this.stride, extent);
    };
    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {GeometryLayout} [opt_layout] Layout.
     * @api
     */
    MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 2);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        var ends = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__[/* deflateCoordinatesArray */ "c"])(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    };
    return MultiLineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (MultiLineString);
//# sourceMappingURL=MultiLineString.js.map

/***/ }),

/***/ "480c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js
var Layer = __webpack_require__("1af9");

// CONCATENATED MODULE: ./node_modules/ol/layer/TileProperty.js
/**
 * @module ol/layer/TileProperty
 */
/**
 * @enum {string}
 */
/* harmony default export */ var TileProperty = ({
    PRELOAD: 'preload',
    USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',
});
//# sourceMappingURL=TileProperty.js.map
// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__("38f3");

// CONCATENATED MODULE: ./node_modules/ol/layer/BaseTile.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/BaseTile
 */



/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */
/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */
var BaseTile_BaseTileLayer = /** @class */ (function (_super) {
    __extends(BaseTileLayer, _super);
    /**
     * @param {Options<TileSourceType>} [opt_options] Tile layer options.
     */
    function BaseTileLayer(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        var baseOptions = Object(obj["a" /* assign */])({}, options);
        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        _this = _super.call(this, baseOptions) || this;
        /***
         * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {BaseTileLayerOnSignature<void>}
         */
        _this.un;
        _this.setPreload(options.preload !== undefined ? options.preload : 0);
        _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined
            ? options.useInterimTilesOnError
            : true);
        return _this;
    }
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
    BaseTileLayer.prototype.getPreload = function () {
        return /** @type {number} */ (this.get(TileProperty.PRELOAD));
    };
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
    BaseTileLayer.prototype.setPreload = function (preload) {
        this.set(TileProperty.PRELOAD, preload);
    };
    /**
     * Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
    BaseTileLayer.prototype.getUseInterimTilesOnError = function () {
        return /** @type {boolean} */ (this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR));
    };
    /**
     * Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
    BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
        this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    };
    /**
     * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
     * a four element RGBA array will be returned.  For data tiles, the array length will match the
     * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
     * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     */
    BaseTileLayer.prototype.getData = function (pixel) {
        return _super.prototype.getData.call(this, pixel);
    };
    return BaseTileLayer;
}(Layer["a" /* default */]));
/* harmony default export */ var BaseTile = (BaseTile_BaseTileLayer);
//# sourceMappingURL=BaseTile.js.map
// EXTERNAL MODULE: ./node_modules/ol/renderer/canvas/Layer.js + 1 modules
var canvas_Layer = __webpack_require__("137e");

// EXTERNAL MODULE: ./node_modules/ol/ImageTile.js
var ImageTile = __webpack_require__("7f98");

// EXTERNAL MODULE: ./node_modules/ol/reproj/Tile.js
var Tile = __webpack_require__("2efc");

// EXTERNAL MODULE: ./node_modules/ol/TileRange.js
var TileRange = __webpack_require__("dc07");

// EXTERNAL MODULE: ./node_modules/ol/TileState.js
var TileState = __webpack_require__("acc1");

// EXTERNAL MODULE: ./node_modules/ol/renderer/canvas/common.js
var common = __webpack_require__("0b0e");

// EXTERNAL MODULE: ./node_modules/ol/transform.js
var transform = __webpack_require__("a896");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/css.js
var css = __webpack_require__("cd7e");

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules
var proj = __webpack_require__("256f");

// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// EXTERNAL MODULE: ./node_modules/ol/size.js
var ol_size = __webpack_require__("345d");

// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/TileLayer.js
var TileLayer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/renderer/canvas/TileLayer
 */














/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */
var TileLayer_CanvasTileLayerRenderer = /** @class */ (function (_super) {
    TileLayer_extends(CanvasTileLayerRenderer, _super);
    /**
     * @param {LayerType} tileLayer Tile layer.
     */
    function CanvasTileLayerRenderer(tileLayer) {
        var _this = _super.call(this, tileLayer) || this;
        /**
         * Rendered extent has changed since the previous `renderFrame()` call
         * @type {boolean}
         */
        _this.extentChanged = true;
        /**
         * @private
         * @type {?import("../../extent.js").Extent}
         */
        _this.renderedExtent_ = null;
        /**
         * @protected
         * @type {number}
         */
        _this.renderedPixelRatio;
        /**
         * @protected
         * @type {import("../../proj/Projection.js").default}
         */
        _this.renderedProjection = null;
        /**
         * @protected
         * @type {number}
         */
        _this.renderedRevision;
        /**
         * @protected
         * @type {!Array<import("../../Tile.js").default>}
         */
        _this.renderedTiles = [];
        /**
         * @private
         * @type {boolean}
         */
        _this.newTiles_ = false;
        /**
         * @protected
         * @type {import("../../extent.js").Extent}
         */
        _this.tmpExtent = Object(ol_extent["j" /* createEmpty */])();
        /**
         * @private
         * @type {import("../../TileRange.js").default}
         */
        _this.tmpTileRange_ = new TileRange["b" /* default */](0, 0, 0, 0);
        return _this;
    }
    /**
     * @protected
     * @param {import("../../Tile.js").default} tile Tile.
     * @return {boolean} Tile is drawable.
     */
    CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {
        var tileLayer = this.getLayer();
        var tileState = tile.getState();
        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
        return (tileState == TileState["a" /* default */].LOADED ||
            tileState == TileState["a" /* default */].EMPTY ||
            (tileState == TileState["a" /* default */].ERROR && !useInterimTilesOnError));
    };
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @return {!import("../../Tile.js").default} Tile.
     */
    CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
        var pixelRatio = frameState.pixelRatio;
        var projection = frameState.viewState.projection;
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getSource();
        var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
        if (tile.getState() == TileState["a" /* default */].ERROR) {
            if (!tileLayer.getUseInterimTilesOnError()) {
                // When useInterimTilesOnError is false, we consider the error tile as loaded.
                tile.setState(TileState["a" /* default */].LOADED);
            }
            else if (tileLayer.getPreload() > 0) {
                // Preloaded tiles for lower resolutions might have finished loading.
                this.newTiles_ = true;
            }
        }
        if (!this.isDrawableTile(tile)) {
            tile = tile.getInterimTile();
        }
        return tile;
    };
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     */
    CanvasTileLayerRenderer.prototype.getData = function (pixel) {
        var frameState = this.frameState;
        if (!frameState) {
            return null;
        }
        var layer = this.getLayer();
        var coordinate = Object(transform["a" /* apply */])(frameState.pixelToCoordinateTransform, pixel.slice());
        var layerExtent = layer.getExtent();
        if (layerExtent) {
            if (!Object(ol_extent["f" /* containsCoordinate */])(layerExtent, coordinate)) {
                return null;
            }
        }
        var pixelRatio = frameState.pixelRatio;
        var projection = frameState.viewState.projection;
        var viewState = frameState.viewState;
        var source = layer.getRenderSource();
        var tileGrid = source.getTileGridForProjection(viewState.projection);
        var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
        for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
            var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
            var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);
            if (!(tile instanceof ImageTile["a" /* default */] || tile instanceof Tile["a" /* default */])) {
                return null;
            }
            if (tile.getState() !== TileState["a" /* default */].LOADED) {
                continue;
            }
            var tileOrigin = tileGrid.getOrigin(z);
            var tileSize = Object(ol_size["c" /* toSize */])(tileGrid.getTileSize(z));
            var tileResolution = tileGrid.getResolution(z);
            var col = Math.floor(tilePixelRatio *
                ((coordinate[0] - tileOrigin[0]) / tileResolution -
                    tileCoord[1] * tileSize[0]));
            var row = Math.floor(tilePixelRatio *
                ((tileOrigin[1] - coordinate[1]) / tileResolution -
                    tileCoord[2] * tileSize[1]));
            return this.getImageData(tile.getImage(), col, row);
        }
        return null;
    };
    /**
     * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */
    CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
        if (this.isDrawableTile(tile)) {
            return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
        }
        return false;
    };
    /**
     * Determine whether render should be called.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {
        return !!this.getLayer().getSource();
    };
    /**
     * Render the layer.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */
    CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        var viewResolution = viewState.resolution;
        var viewCenter = viewState.center;
        var rotation = viewState.rotation;
        var pixelRatio = frameState.pixelRatio;
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getSource();
        var sourceRevision = tileSource.getRevision();
        var tileGrid = tileSource.getTileGridForProjection(projection);
        var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
        var tileResolution = tileGrid.getResolution(z);
        var extent = frameState.extent;
        var layerExtent = layerState.extent && Object(proj["k" /* fromUserExtent */])(layerState.extent, projection);
        if (layerExtent) {
            extent = Object(ol_extent["A" /* getIntersection */])(extent, Object(proj["k" /* fromUserExtent */])(layerState.extent, projection));
        }
        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
        // desired dimensions of the canvas in pixels
        var width = Math.round(frameState.size[0] * tilePixelRatio);
        var height = Math.round(frameState.size[1] * tilePixelRatio);
        if (rotation) {
            var size = Math.round(Math.sqrt(width * width + height * height));
            width = size;
            height = size;
        }
        var dx = (tileResolution * width) / 2 / tilePixelRatio;
        var dy = (tileResolution * height) / 2 / tilePixelRatio;
        var canvasExtent = [
            viewCenter[0] - dx,
            viewCenter[1] - dy,
            viewCenter[0] + dx,
            viewCenter[1] + dy,
        ];
        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
        /**
         * @type {Object<number, Object<string, import("../../Tile.js").default>>}
         */
        var tilesToDrawByZ = {};
        tilesToDrawByZ[z] = {};
        var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
        var tmpExtent = this.tmpExtent;
        var tmpTileRange = this.tmpTileRange_;
        this.newTiles_ = false;
        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                var tile = this.getTile(z, x, y, frameState);
                if (this.isDrawableTile(tile)) {
                    var uid = Object(util["c" /* getUid */])(this);
                    if (tile.getState() == TileState["a" /* default */].LOADED) {
                        tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                        var inTransition = tile.inTransition(uid);
                        if (!this.newTiles_ &&
                            (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
                            this.newTiles_ = true;
                        }
                    }
                    if (tile.getAlpha(uid, frameState.time) === 1) {
                        // don't look for alt tiles if alpha is 1
                        continue;
                    }
                }
                var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
                var covered = false;
                if (childTileRange) {
                    covered = findLoadedTiles(z + 1, childTileRange);
                }
                if (!covered) {
                    tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
                }
            }
        }
        var canvasScale = tileResolution / viewResolution;
        // set forward and inverse pixel transforms
        Object(transform["b" /* compose */])(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
        var canvasTransform = Object(transform["g" /* toString */])(this.pixelTransform);
        this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
        var context = this.context;
        var canvas = context.canvas;
        Object(transform["d" /* makeInverse */])(this.inversePixelTransform, this.pixelTransform);
        // set scale transform for calculating tile positions on the canvas
        Object(transform["b" /* compose */])(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
        }
        else if (!this.containerReused) {
            context.clearRect(0, 0, width, height);
        }
        if (layerExtent) {
            this.clipUnrotated(context, frameState, layerExtent);
        }
        if (!tileSource.getInterpolate()) {
            Object(obj["a" /* assign */])(context, common["a" /* IMAGE_SMOOTHING_DISABLED */]);
        }
        this.preRender(context, frameState);
        this.renderedTiles.length = 0;
        /** @type {Array<number>} */
        var zs = Object.keys(tilesToDrawByZ).map(Number);
        zs.sort(array["g" /* numberSafeCompareFunction */]);
        var clips, clipZs, currentClip;
        if (layerState.opacity === 1 &&
            (!this.containerReused ||
                tileSource.getOpaque(frameState.viewState.projection))) {
            zs = zs.reverse();
        }
        else {
            clips = [];
            clipZs = [];
        }
        for (var i = zs.length - 1; i >= 0; --i) {
            var currentZ = zs[i];
            var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
            var currentResolution = tileGrid.getResolution(currentZ);
            var currentScale = currentResolution / tileResolution;
            var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
            var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
            var originTileCoord = tileGrid.getTileCoordForCoordAndZ(Object(ol_extent["B" /* getTopLeft */])(canvasExtent), currentZ);
            var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
            var origin_1 = Object(transform["a" /* apply */])(this.tempTransform, [
                (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /
                    tileResolution,
                (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /
                    tileResolution,
            ]);
            var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
            var tilesToDraw = tilesToDrawByZ[currentZ];
            for (var tileCoordKey in tilesToDraw) {
                var tile = /** @type {import("../../ImageTile.js").default} */ (tilesToDraw[tileCoordKey]);
                var tileCoord = tile.tileCoord;
                // Calculate integer positions and sizes so that tiles align
                var xIndex = originTileCoord[1] - tileCoord[1];
                var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);
                var yIndex = originTileCoord[2] - tileCoord[2];
                var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);
                var x = Math.round(origin_1[0] - xIndex * dx_1);
                var y = Math.round(origin_1[1] - yIndex * dy_1);
                var w = nextX - x;
                var h = nextY - y;
                var transition = z === currentZ;
                var inTransition = transition && tile.getAlpha(Object(util["c" /* getUid */])(this), frameState.time) !== 1;
                var contextSaved = false;
                if (!inTransition) {
                    if (clips) {
                        // Clip mask for regions in this tile that already filled by a higher z tile
                        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
                        for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
                            if (z !== currentZ && currentZ < clipZs[i_1]) {
                                var clip = clips[i_1];
                                if (Object(ol_extent["E" /* intersects */])([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {
                                    if (!contextSaved) {
                                        context.save();
                                        contextSaved = true;
                                    }
                                    context.beginPath();
                                    // counter-clockwise (outer ring) for current tile
                                    context.moveTo(currentClip[0], currentClip[1]);
                                    context.lineTo(currentClip[2], currentClip[3]);
                                    context.lineTo(currentClip[4], currentClip[5]);
                                    context.lineTo(currentClip[6], currentClip[7]);
                                    // clockwise (inner ring) for higher z tile
                                    context.moveTo(clip[6], clip[7]);
                                    context.lineTo(clip[4], clip[5]);
                                    context.lineTo(clip[2], clip[3]);
                                    context.lineTo(clip[0], clip[1]);
                                    context.clip();
                                }
                            }
                        }
                        clips.push(currentClip);
                        clipZs.push(currentZ);
                    }
                    else {
                        context.clearRect(x, y, w, h);
                    }
                }
                this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);
                if (clips && !inTransition) {
                    if (contextSaved) {
                        context.restore();
                    }
                    this.renderedTiles.unshift(tile);
                }
                else {
                    this.renderedTiles.push(tile);
                }
                this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
            }
        }
        this.renderedRevision = sourceRevision;
        this.renderedResolution = tileResolution;
        this.extentChanged =
            !this.renderedExtent_ || !Object(ol_extent["o" /* equals */])(this.renderedExtent_, canvasExtent);
        this.renderedExtent_ = canvasExtent;
        this.renderedPixelRatio = pixelRatio;
        this.renderedProjection = projection;
        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
        this.scheduleExpireCache(frameState, tileSource);
        this.postRender(context, frameState);
        if (layerState.extent) {
            context.restore();
        }
        Object(obj["a" /* assign */])(context, common["b" /* IMAGE_SMOOTHING_ENABLED */]);
        if (canvasTransform !== canvas.style.transform) {
            canvas.style.transform = canvasTransform;
        }
        var opacity = Object(css["g" /* cssOpacity */])(layerState.opacity);
        var container = this.container;
        if (opacity !== container.style.opacity) {
            container.style.opacity = opacity;
        }
        return this.container;
    };
    /**
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     */
    CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition) {
        var image = this.getTileImage(tile);
        if (!image) {
            return;
        }
        var uid = Object(util["c" /* getUid */])(this);
        var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
        var alphaChanged = alpha !== this.context.globalAlpha;
        if (alphaChanged) {
            this.context.save();
            this.context.globalAlpha = alpha;
        }
        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
        if (alphaChanged) {
            this.context.restore();
        }
        if (alpha !== 1) {
            frameState.animate = true;
        }
        else if (transition) {
            tile.endTransition(uid);
        }
    };
    /**
     * @return {HTMLCanvasElement} Image
     */
    CanvasTileLayerRenderer.prototype.getImage = function () {
        var context = this.context;
        return context ? context.canvas : null;
    };
    /**
     * Get the image from a tile.
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @protected
     */
    CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {
        return tile.getImage();
    };
    /**
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @protected
     */
    CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {
        if (tileSource.canExpireCache()) {
            /**
             * @param {import("../../source/Tile.js").default} tileSource Tile source.
             * @param {import("../../PluggableMap.js").default} map Map.
             * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
             */
            var postRenderFunction = function (tileSource, map, frameState) {
                var tileSourceKey = Object(util["c" /* getUid */])(tileSource);
                if (tileSourceKey in frameState.usedTiles) {
                    tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
                }
            }.bind(null, tileSource);
            frameState.postRenderFunctions.push(
            /** @type {import("../../PluggableMap.js").PostRenderFunction} */ (postRenderFunction));
        }
    };
    /**
     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import('../../Tile.js').default} tile Tile.
     * @protected
     */
    CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {
        // FIXME should we use tilesToDrawByZ instead?
        var tileSourceKey = Object(util["c" /* getUid */])(tileSource);
        if (!(tileSourceKey in usedTiles)) {
            usedTiles[tileSourceKey] = {};
        }
        usedTiles[tileSourceKey][tile.getKey()] = true;
    };
    /**
     * Manage tile pyramid.
     * This function performs a number of functions related to the tiles at the
     * current zoom and lower zoom levels:
     * - registers idle tiles in frameState.wantedTiles so that they are not
     *   discarded by the tile queue
     * - enqueues missing tiles
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../proj/Projection.js").default} projection Projection.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {number} currentZ Current Z.
     * @param {number} preload Load low resolution tiles up to `preload` levels.
     * @param {function(import("../../Tile.js").default):void} [opt_tileCallback] Tile callback.
     * @protected
     */
    CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
        var tileSourceKey = Object(util["c" /* getUid */])(tileSource);
        if (!(tileSourceKey in frameState.wantedTiles)) {
            frameState.wantedTiles[tileSourceKey] = {};
        }
        var wantedTiles = frameState.wantedTiles[tileSourceKey];
        var tileQueue = frameState.tileQueue;
        var minZoom = tileGrid.getMinZoom();
        var tileCount = 0;
        var tile, tileRange, tileResolution, x, y, z;
        for (z = minZoom; z <= currentZ; ++z) {
            tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
            tileResolution = tileGrid.getResolution(z);
            for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
                for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
                    if (currentZ - z <= preload) {
                        ++tileCount;
                        tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                        if (tile.getState() == TileState["a" /* default */].IDLE) {
                            wantedTiles[tile.getKey()] = true;
                            if (!tileQueue.isKeyQueued(tile.getKey())) {
                                tileQueue.enqueue([
                                    tile,
                                    tileSourceKey,
                                    tileGrid.getTileCoordCenter(tile.tileCoord),
                                    tileResolution,
                                ]);
                            }
                        }
                        if (opt_tileCallback !== undefined) {
                            opt_tileCallback(tile);
                        }
                    }
                    else {
                        tileSource.useTile(z, x, y, projection);
                    }
                }
            }
        }
        tileSource.updateCacheSize(tileCount, projection);
    };
    return CanvasTileLayerRenderer;
}(canvas_Layer["a" /* default */]));
/* harmony default export */ var canvas_TileLayer = (TileLayer_CanvasTileLayerRenderer);
//# sourceMappingURL=TileLayer.js.map
// CONCATENATED MODULE: ./node_modules/ol/layer/Tile.js
var Tile_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/Tile
 */


/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */
var Tile_TileLayer = /** @class */ (function (_super) {
    Tile_extends(TileLayer, _super);
    /**
     * @param {import("./BaseTile.js").Options<TileSourceType>} [opt_options] Tile layer options.
     */
    function TileLayer(opt_options) {
        return _super.call(this, opt_options) || this;
    }
    TileLayer.prototype.createRenderer = function () {
        return new canvas_TileLayer(this);
    };
    return TileLayer;
}(BaseTile));
/* harmony default export */ var layer_Tile = __webpack_exports__["a"] = (Tile_TileLayer);
//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "4840":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aConstructor = __webpack_require__("5087");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ "485a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");

var TypeError = global.TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "48d6":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABKdJREFUeNqsl39MW1UUx7/tCrSF2ZaJEgi4jf0joEM3FhOCK//MbBhX/yCSmCgkzjkTEo1hxmTJWPzDBIxLNNHsDyP7w4AuUVh0JPxhQXDGDRUHW5ZsjFoSomWulJa+9/p+1HMf7z1eSykFdpLTe9/r7f3cc+65555asEkJtTxaR4077fXiY5fuT25mHkuOMC81r5P6MkANOOkA6UVaxMi2wJp150m95vd5NQ0p46TANJLLEfMrBn43mxcsWaBt1HylP9u9rarmVTdkHM/g/Eg/+NF+8yLaCd6bM5igDNimW7fz7c+wo6Qip71j0OjnHRCuD+mvegnenst+vkOaZLr8bXdyq8L5+5L6PGzOrBZrQeRn/cKW03C2dGI7wlzPrNekyRx0O8wDO2uc31NTWlB/FEUnPsbg+2fgP/+purqyp2sx8XU/pn9cceG98asY/qgbkiCo32US2+5acv0SpDu/s8e6nlvxC2ss1oPJUuiCp9uPwO0gJrrew0vHn0HvlyPgikpRnIzgYP0eDP90B8V2GY2HyjH2awBlLSdw5IPOdfc8fLoJ8sJcSrBZTWPYOQWzVg8kj6sADgg49dqzKBb+wcEDlajd50b78Sq8cnQvqkqsaHzKhZmxX9Y/r2SIo/lkCsMAk7Vu/aw6jp1c/ZUo0EbFVD1yqATDQ39hcOAPePIFOJRlIB7Bg/tLCP8dxBfHfJj+YSgj3H64Ve96NZZhcZ2+OrYvq4czAXBRVct2yjj1ghszMyEMjwbUlrmxrlxBW81/aHZcx0BHB7hIJKPVpnnrzGCvHgypWYGBYwa8QOHwhteO0L9h/Dz5AALPgyd12BKwWwXsdYYxf2M6o9WmxONN3+O1wlxNwCTBRZ6DQBFsTYp4cb+FYCI+/C6qvmNw1la4eHzzVkfGqaxkdcpz1ixEFkt8XJ00kUioqvef3yfiyVIJl/+UcXtexo05BR47h7zwPXzS0JQ14DYEy5K8Bqj3mT5XuYxdjjgmglaIioSImERt5RIq4uN0xnuygm1aG2AfSiiYCpZlAshqK0mSofqzICsoc4tYFCwIhAsQlYEiOt8epw3B+aAaaA7XiosTtwwPBMwWq9cXO+TaQdfAUoqFusUcaUxSSIEo6eMeDk67hNBSAeYWPNhfXoRyeS4l0MSbBnjSAGv3proSgfKrLuGYkgLkSZdF2QAyCwWFYoHGVuziUF0eRTguoe834G7MheInKo2crVur39E2k2cvkp7lR/ooibyJqsYGjB1oxvC1yyjMJ+sVK2QiSJqyfiYpeSSBBcmDs7N3Vy+L0X4zY02uZhlllpU25puJZaP5qelN3Ur1r7bCU7mSdrkrFxDrPaOXRnvI4sWsdzF/7UpyuyLOTiUX2qrWvZPT4X42kP0gcXP8YUH9uZzjl1nksTy82OVD/FLPpgsA5t7Fcz699prU5syp5nJrlYia0Nk16aR9Z8VeNmF1FoOmHZ2mTPu6UXnbxSI9/ZbJr04vb6coQVxNL3HPEbBrywU9wXdr8GzFfHpRz6CBbf+TMC3Cp7n/sKnIZ+4cZC3BBh7qX5j1ol/zQMY93Ehs26heWaS6twJl8r8AAwDGSjLZ1jtA5AAAAABJRU5ErkJggg=="

/***/ }),

/***/ "490c":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "4930":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__("2d00");
var fails = __webpack_require__("d039");

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "496f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/ViewHint
 */
/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    ANIMATING: 0,
    INTERACTING: 1,
});
//# sourceMappingURL=ViewHint.js.map

/***/ }),

/***/ "498a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $trim = __webpack_require__("58a8").trim;
var forcedStringTrimMethod = __webpack_require__("c8d2");

// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ "4a7d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("25a5");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0af5");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1300");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
/**
 * @module ol/structs/RBush
 */




/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */
/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush = /** @class */ (function () {
    /**
     * @param {number} [opt_maxEntries] Max entries.
     */
    function RBush(opt_maxEntries) {
        /**
         * @private
         */
        this.rbush_ = new rbush__WEBPACK_IMPORTED_MODULE_0___default.a(opt_maxEntries);
        /**
         * A mapping between the objects added to this rbush wrapper
         * and the objects that are actually added to the internal rbush.
         * @private
         * @type {Object<string, Entry>}
         */
        this.items_ = {};
    }
    /**
     * Insert a value into the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    RBush.prototype.insert = function (extent, value) {
        /** @type {Entry} */
        var item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value: value,
        };
        this.rbush_.insert(item);
        this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* getUid */ "c"])(value)] = item;
    };
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */
    RBush.prototype.load = function (extents, values) {
        var items = new Array(values.length);
        for (var i = 0, l = values.length; i < l; i++) {
            var extent = extents[i];
            var value = values[i];
            /** @type {Entry} */
            var item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value: value,
            };
            items[i] = item;
            this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* getUid */ "c"])(value)] = item;
        }
        this.rbush_.load(items);
    };
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
    RBush.prototype.remove = function (value) {
        var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* getUid */ "c"])(value);
        // get the object in which the value was wrapped when adding to the
        // internal rbush. then use that object to do the removal.
        var item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
    };
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    RBush.prototype.update = function (extent, value) {
        var item = this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* getUid */ "c"])(value)];
        var bbox = [item.minX, item.minY, item.maxX, item.maxY];
        if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__[/* equals */ "o"])(bbox, extent)) {
            this.remove(value);
            this.insert(extent, value);
        }
    };
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */
    RBush.prototype.getAll = function () {
        var items = this.rbush_.all();
        return items.map(function (item) {
            return item.value;
        });
    };
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */
    RBush.prototype.getInExtent = function (extent) {
        /** @type {Entry} */
        var bbox = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
        };
        var items = this.rbush_.search(bbox);
        return items.map(function (item) {
            return item.value;
        });
    };
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */
    RBush.prototype.forEach = function (callback) {
        return this.forEach_(this.getAll(), callback);
    };
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */
    RBush.prototype.forEachInExtent = function (extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
    };
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): *} callback Callback.
     * @private
     * @return {*} Callback return value.
     */
    RBush.prototype.forEach_ = function (values, callback) {
        var result;
        for (var i = 0, l = values.length; i < l; i++) {
            result = callback(values[i]);
            if (result) {
                return result;
            }
        }
        return result;
    };
    /**
     * @return {boolean} Is empty.
     */
    RBush.prototype.isEmpty = function () {
        return Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[/* isEmpty */ "d"])(this.items_);
    };
    /**
     * Remove all values from the RBush.
     */
    RBush.prototype.clear = function () {
        this.rbush_.clear();
        this.items_ = {};
    };
    /**
     * @param {import("../extent.js").Extent} [opt_extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */
    RBush.prototype.getExtent = function (opt_extent) {
        var data = this.rbush_.toJSON();
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__[/* createOrUpdate */ "k"])(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
    };
    /**
     * @param {RBush} rbush R-Tree.
     */
    RBush.prototype.concat = function (rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for (var i in rbush.items_) {
            this.items_[i] = rbush.items_[i];
        }
    };
    return RBush;
}());
/* harmony default export */ __webpack_exports__["a"] = (RBush);
//# sourceMappingURL=RBush.js.map

/***/ }),

/***/ "4aea":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGU0lEQVR4nIWVa3DU5RXGf2f3zyZkNyEbEnKBLAYSwISEi4IJmQgl1UAv1JEABRHaDsitYq0ITNWRqcqHprRaFBgFbFEoQisUFXDCpbRQwHCRQIxcEiIkIQnsbrLZbDaX3dMPm+1ERXrOnC/ved/nec9lzpFgMAiAiNAjRcDM1vbOhy7W3Ektq2qKqXN6qapvxmSYlZ5rwa6AOBJjGBwfzdi0BE92WvxNuy3yNLAbOAigqoiqhoEXAC9vLa0YtPlAOdcaWkiKjSJtkJ0Uu5Ws++KJs0aACKji9HZQ+dUd6t0+rtW6uOVqIzXexoKibJb8eFStGVkDbAkTlJRVNa0oWrGTAf2i+NWs8TwwdACtvk5uudu4UufmSlMrjU4vajYhgSBJ8TYyEqIZNtBOkt1KrC2CM1ebWPfBaWqbPOxZW0zRaMc6UdWFDc2+t5NnbaBkwcPMfmQkJX89xe6T16ivb4FgEEwmEMAwg0kgqNAdACXkN5tISe7HjLx0Vs7JZUdpBc//4VO+2LUUUdXKxZuOjrhx28OulT9gwKyNtDu9YIuArgAEgiEgEYiyIH0tqCp42kP+cOlEoCtAZJyVlg+f5tGX9+BIiMZQVdvVW826dEo2C986TLurDeKsEFSmPTyc4gnpRFoMLte5eWPPOe642iAQpDA/g3mTRtA3wqCp2cem/eVcutyA39XGko1HWFSUzeZDFRhAU4RhGlTV0KJX6puhjwmH3cqFN+cSa4vE3erH7+tkRl46v5yaQ8rMt3js+yPZ8dwUXF4/rZ52+o8ZzLKpORSs3s3x41c4W32b/PtTsBgmMUTksiMhemxEH7NYDDMYZuqafbz697OUXrhB+alqaGxhzGNjObfup2SPdvCT3KFU1rrInP8OeDvoOzge9/anWDglm+OHv8CREM1tTztZqf2DhqqWjM9IKq53tRljhiRwquw6AcPEui3/An8niSOSWbxsMqtmjKOlvZPPz9Swt380s/Iz0MOraGz2kRgbBcDrH38OIoxLT+TiDScTM1PcJhE5PylrYFVlrUsc8TYBBH+XEB0hm195XBq2PSVrnsiTjz+rlpGL/yKdbR0yPXeoOD3t8sGxL+XA6SrZ91m1+Du7pTgvXQgExRFvk1uuNnlklKPcABiS1O+wr6N7xMA4G1jM4O/i5IZ5ZKbGMf/3B9h28CI0ekIdk5ZA8YR0lm8+xvo1e8FuBbeP97cv4jfTH+SlbScIqmIS4b4BMXuNniZ7b3Ra/DK3109aWgLJdiu5w5Iou9bIQ+mJFL6YRqTFQIJBfveP8/znSgPrfl5AZnIsFTV3yMtMYc7E4azfX874rIFc/MpJYc4ggN2oKqpK7Z3WSzNL9utLO05q7vM7teKmU2saW9Tp9avT0x6y1nadtvYjTZy9UY+W31Svv0tVVV1ev773z0qlYK1uPVShuat26S2Xd5+qYoRn0cD+tvXWSMumnMHxuuGTC2TN2ggR4QB7iTUCFL739PsQG4XZMBPwdYDTy8i8oSCQlRonSXZriapi6vV0y/If5jTuK6uW1TPGh0769YWYb1gfc4jYbgVVAh1dYDHAYvBC8TjeKa2QZ6eNPg/8G8AkIuFR3T06LeG1PoYJR7xNMnJSBV+niNkk9LbQZcEkgmEWsRhCq18mF2ZKg9snaQNiyErtvzy8AkzhGvSkav3aJybUvHukklfm5ikd3aqBoAJ6NxVQ7QqoKdLQF6Y/oO8eqWT9gomHgONhzP9FEF44ibFRc/NHJFNxwynPzM8XbreGfiwIor0MUVWhySObV0yVDQcvypIpI4mLjvxZ+Pci8rUahOXEizPGbTl9tZFJmSlMfTQLGltCA7NHQUJTts7Nb58rwulpx+fvZnFR9lKgrjdY7432tfPGZl/lj177aPj2Xxfx7MYj7D9SGeogwwwd3dAdYPUvCngwI5GV205w+c0ndxpm0+xvAX0HAUDG4fKbl+b9qdSydVkhN5o8HCy7jqvVz9DEfsycfD9XbzpZ++FZzv1xzpnE2KgJQNe3CMJL/65hiORVN7aUPr5mr3VYahxTxg0h2mqhpsHD345WYo+O5JNXp58zmyRfVf13xbgXQQ9JOvD2jmOXCz49c93wdXRpQkyUTC/I8BSOcvwZeOYeWbhnir4pTwKLgEigHlgJfPn/Hv0XIybQk3C44EMAAAAASUVORK5CYII="

/***/ }),

/***/ "4cdf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createStyleFunction */
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("92fa");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1e8d");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Feature
 */




/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */
/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */
/***
 * @template Geometry
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */
/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */
var Feature = /** @class */ (function (_super) {
    __extends(Feature, _super);
    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [opt_geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */
    function Feature(opt_geometryOrProperties) {
        var _this = _super.call(this) || this;
        /***
         * @type {FeatureOnSignature<import("./events").EventsKey>}
         */
        _this.on;
        /***
         * @type {FeatureOnSignature<import("./events").EventsKey>}
         */
        _this.once;
        /***
         * @type {FeatureOnSignature<void>}
         */
        _this.un;
        /**
         * @private
         * @type {number|string|undefined}
         */
        _this.id_ = undefined;
        /**
         * @type {string}
         * @private
         */
        _this.geometryName_ = 'geometry';
        /**
         * User provided style.
         * @private
         * @type {import("./style/Style.js").StyleLike}
         */
        _this.style_ = null;
        /**
         * @private
         * @type {import("./style/Style.js").StyleFunction|undefined}
         */
        _this.styleFunction_ = undefined;
        /**
         * @private
         * @type {?import("./events.js").EventsKey}
         */
        _this.geometryChangeKey_ = null;
        _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
        if (opt_geometryOrProperties) {
            if (typeof (
            /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry) === 'function') {
                var geometry = /** @type {Geometry} */ (opt_geometryOrProperties);
                _this.setGeometry(geometry);
            }
            else {
                /** @type {Object<string, *>} */
                var properties = opt_geometryOrProperties;
                _this.setProperties(properties);
            }
        }
        return _this;
    }
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */
    Feature.prototype.clone = function () {
        var clone = /** @type {Feature<Geometry>} */ (new Feature(this.hasProperties() ? this.getProperties() : null));
        clone.setGeometryName(this.getGeometryName());
        var geometry = this.getGeometry();
        if (geometry) {
            clone.setGeometry(/** @type {Geometry} */ (geometry.clone()));
        }
        var style = this.getStyle();
        if (style) {
            clone.setStyle(style);
        }
        return clone;
    };
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */
    Feature.prototype.getGeometry = function () {
        return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));
    };
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */
    Feature.prototype.getId = function () {
        return this.id_;
    };
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */
    Feature.prototype.getGeometryName = function () {
        return this.geometryName_;
    };
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */
    Feature.prototype.getStyle = function () {
        return this.style_;
    };
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */
    Feature.prototype.getStyleFunction = function () {
        return this.styleFunction_;
    };
    /**
     * @private
     */
    Feature.prototype.handleGeometryChange_ = function () {
        this.changed();
    };
    /**
     * @private
     */
    Feature.prototype.handleGeometryChanged_ = function () {
        if (this.geometryChangeKey_) {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_3__[/* unlistenByKey */ "c"])(this.geometryChangeKey_);
            this.geometryChangeKey_ = null;
        }
        var geometry = this.getGeometry();
        if (geometry) {
            this.geometryChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__[/* listen */ "a"])(geometry, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE, this.handleGeometryChange_, this);
        }
        this.changed();
    };
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */
    Feature.prototype.setGeometry = function (geometry) {
        this.set(this.geometryName_, geometry);
    };
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [opt_style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    Feature.prototype.setStyle = function (opt_style) {
        this.style_ = opt_style;
        this.styleFunction_ = !opt_style
            ? undefined
            : createStyleFunction(opt_style);
        this.changed();
    };
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    Feature.prototype.setId = function (id) {
        this.id_ = id;
        this.changed();
    };
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */
    Feature.prototype.setGeometryName = function (name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
    };
    return Feature;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */
function createStyleFunction(obj) {
    if (typeof obj === 'function') {
        return obj;
    }
    else {
        /**
         * @type {Array<import("./style/Style.js").default>}
         */
        var styles_1;
        if (Array.isArray(obj)) {
            styles_1 = obj;
        }
        else {
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__[/* assert */ "a"])(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
            var style = /** @type {import("./style/Style.js").default} */ (obj);
            styles_1 = [style];
        }
        return function () {
            return styles_1;
        };
    }
}
/* harmony default export */ __webpack_exports__["a"] = (Feature);
//# sourceMappingURL=Feature.js.map

/***/ }),

/***/ "4d64":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "4d98":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ linearRingsAreOriented; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ linearRingssAreOriented; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ orientLinearRings; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ orientLinearRingsArray; });

// UNUSED EXPORTS: linearRingIsClockwise, inflateEnds

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/reverse.js
/**
 * @module ol/geom/flat/reverse
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
    while (offset < end - stride) {
        for (var i = 0; i < stride; ++i) {
            var tmp = flatCoordinates[offset + i];
            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
            flatCoordinates[end - stride + i] = tmp;
        }
        offset += stride;
        end -= stride;
    }
}
//# sourceMappingURL=reverse.js.map
// CONCATENATED MODULE: ./node_modules/ol/geom/flat/orient.js
/**
 * @module ol/geom/flat/orient
 */

/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
    // https://stackoverflow.com/q/1165647/clockwise-method#1165943
    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
    var edge = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];
    for (; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        edge += (x2 - x1) * (y2 + y1);
        x1 = x2;
        y1 = y2;
    }
    return edge === 0 ? undefined : edge > 0;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
    var right = opt_right !== undefined ? opt_right : false;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        if (i === 0) {
            if ((right && isClockwise) || (!right && !isClockwise)) {
                return false;
            }
        }
        else {
            if ((right && !isClockwise) || (!right && isClockwise)) {
                return false;
            }
        }
        offset = end;
    }
    return true;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
            return false;
        }
        if (ends.length) {
            offset = ends[ends.length - 1];
        }
    }
    return true;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
    var right = opt_right !== undefined ? opt_right : false;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        var reverse = i === 0
            ? (right && isClockwise) || (!right && !isClockwise)
            : (right && !isClockwise) || (!right && isClockwise);
        if (reverse) {
            coordinates(flatCoordinates, offset, end, stride);
        }
        offset = end;
    }
    return offset;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
    }
    return offset;
}
/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to contruct a MultiPolygon
 */
function inflateEnds(flatCoordinates, ends) {
    var endss = [];
    var offset = 0;
    var prevEndIndex = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        // classifies an array of rings into polygons with outer rings and holes
        if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
            endss.push(ends.slice(prevEndIndex, i + 1));
        }
        else {
            if (endss.length === 0) {
                continue;
            }
            endss[endss.length - 1].push(ends[prevEndIndex]);
        }
        prevEndIndex = i + 1;
        offset = end;
    }
    return endss;
}
//# sourceMappingURL=orient.js.map

/***/ }),

/***/ "4dae":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "4daee":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");
var createProperty = __webpack_require__("8418");

var Array = global.Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ "4e9e":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "5087":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isConstructor = __webpack_require__("68ee");
var tryToString = __webpack_require__("0d51");

var TypeError = global.TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "509b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7238");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/MapBrowserEvent
 */

/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */
var MapBrowserEvent = /** @class */ (function (_super) {
    __extends(MapBrowserEvent, _super);
    /**
     * @param {string} type Event type.
     * @param {import("./PluggableMap.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [opt_dragging] Is the map currently being dragged?
     * @param {?import("./PluggableMap.js").FrameState} [opt_frameState] Frame state.
     */
    function MapBrowserEvent(type, map, originalEvent, opt_dragging, opt_frameState) {
        var _this = _super.call(this, type, map, opt_frameState) || this;
        /**
         * The original browser event.
         * @const
         * @type {EVENT}
         * @api
         */
        _this.originalEvent = originalEvent;
        /**
         * The map pixel relative to the viewport corresponding to the original browser event.
         * @type {?import("./pixel.js").Pixel}
         */
        _this.pixel_ = null;
        /**
         * The coordinate in the user projection corresponding to the original browser event.
         * @type {?import("./coordinate.js").Coordinate}
         */
        _this.coordinate_ = null;
        /**
         * Indicates if the map is currently being dragged. Only set for
         * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
         *
         * @type {boolean}
         * @api
         */
        _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
        return _this;
    }
    Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
        /**
         * The map pixel relative to the viewport corresponding to the original event.
         * @type {import("./pixel.js").Pixel}
         * @api
         */
        get: function () {
            if (!this.pixel_) {
                this.pixel_ = this.map.getEventPixel(this.originalEvent);
            }
            return this.pixel_;
        },
        set: function (pixel) {
            this.pixel_ = pixel;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
        /**
         * The coordinate corresponding to the original browser event.  This will be in the user
         * projection if one is set.  Otherwise it will be in the view projection.
         * @type {import("./coordinate.js").Coordinate}
         * @api
         */
        get: function () {
            if (!this.coordinate_) {
                this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
            }
            return this.coordinate_;
        },
        set: function (coordinate) {
            this.coordinate_ = coordinate;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     */
    MapBrowserEvent.prototype.preventDefault = function () {
        _super.prototype.preventDefault.call(this);
        if ('preventDefault' in this.originalEvent) {
            /** @type {UIEvent} */ (this.originalEvent).preventDefault();
        }
    };
    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     */
    MapBrowserEvent.prototype.stopPropagation = function () {
        _super.prototype.stopPropagation.call(this);
        if ('stopPropagation' in this.originalEvent) {
            /** @type {UIEvent} */ (this.originalEvent).stopPropagation();
        }
    };
    return MapBrowserEvent;
}(_MapEvent_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (MapBrowserEvent);
//# sourceMappingURL=MapBrowserEvent.js.map

/***/ }),

/***/ "50c4":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "521b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/geom/GeometryLayout
 */
/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    XY: 'XY',
    XYZ: 'XYZ',
    XYM: 'XYM',
    XYZM: 'XYZM',
});
//# sourceMappingURL=GeometryLayout.js.map

/***/ }),

/***/ "528b":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGYElEQVR4nIWVa3DU5RXGf+e/m91NdjfJ5gqEBAIEKOES7gKiHW6hsYAjFJsUtTOG4TJT6QWTWoei2OKHiDOQVqwDhY7WcqkDGS6KCLQCyiWEGRADhERyIXeyye4mu5ts9vTDkhlalZ6Zd94v73me9zlznnMkHA4DICI8iFxgpdffO/P63fb0y9Wtsffu+6hu7MQwm5QHz8J9/ZKRGsuwJCdTMpM9EzKT6l0O20XgIPAJgKoiqjoAXAhs/uvJG0N3fXyNO81dDIqPIXOoiyEuO9nDk0iwW0EEVLnvC1JZ206ju4c7DR00dXSTnuSgMHcC65ZMajAhrwG7BwhKLle3bszduI+UuBh++ewMpo5Mwevv46vaduravNzzBmhp99IvgrvLT0JcNKNTYpk8MpnRaS7i7VbKq1rZtv8iDa0eDm1dQW5OxjZR1dXNnT3vDX72HUoKnyB/4XhK9l3g4Pk7NF5vIGfeD2jzBrh3uwWsZvD3MmP2KDJT4wiHwxy/Ukt3VTNDxqXxk9kjKcp/jA9P3uDlt0/w9YH1iKpWrn33zNi6Ng8HivJIWbkTf7sHHDZef2EOvy+Yxca959i29xwYsLMoj7WLJ/JwLHmjjKOf3gDA5rLTdegXLNp8iIxkJ4aqOqqaOvXFBdm6+s+n1N/RraTEKTEWzRzi0lB/WLv8vYovoAVLp+jaxRO16P0v1LR4myYsL9UTV+v0yKZlmjgsUYmN1kBHt67beVrX5E7Qex3dagCtVrMh1c1d3G7sBKcVDIGw8vyWMty+IA6rGcJK4fxx1Ld7Kdl5ijDgbvOyavsJAJbNGgX+XrBbuFLThr83hMVsiCEitzKSnVijTGIxm4SwCiCICLExIgaiIIAYgtxscAuKEGMRnDZpb/MJIAkOayQvrDIs2SltHr9kpyeGDVUtmZE1qM/r79PJI5KVvn4FFEVBNdLOkbu5y68LczKURIfS5lVaPLr08SwFtLymTTEMpV912sgUvV53X8ekxbsNEbn6w+y06sqGDslIckR+pyoQUeKwRkWUWc2y6YMvBJCKPz0neXNHy5oXHpeyV34sl6pa5F8XawSHVVCVYSmx0tTRLQsnZVwzA4wYFHeqJxgam5bggOgoCGvEUALVLR7c3UGw26iqbOSJogPsf+Upjm1dAcDH5XfJf+s4mAxQxRQfjSFgiDA8JfbwgNFmvr7/4gWX3crfz93m0tU6cNgQHujwBiPVEqDLDxYzruFJmAyhvdENliiwmcHdw7JF2YxKjSMp1sZvn5k2xPyglS8WLsi+8es9Z7ML5o7m0vk74LCiYQWPn7c2LGJYshNE8Pl78QX6GJJgZ+PfztMuRsSAYSDUz8pZoyg9fo1DxXlHgCbzwCxKS3SU2m2WdwfH23VwVipNrR6wmMFu46ML1cRYo3Df9zEhPYG9L/+If3x+i7bmrgg4gD9IzvRM/H0hstMTZJDLXqKqGA8ZcvdLT01sOVL+jfzm6angCYAIYjHxZUUtp8oqGBQXTXHBYyzbUkbB7z7CFwojFlMkuztI8dNT2P3Z1/KrpTlXgbMA5ofGdCgnM/mPFrOxIz3RLlnZaVTVtKJ2K/T0sm3zMnKnDSe3+AD19R2QGgveAGoI+ALMmzeOZncPmSmxZKcnvjSwAgxVZeAApVt/NvvuntOVvLFqlhIMKZ09ur04TyeNSNbxBX/R+haP4rIrgT7Ne3KMOmMsitmkry6fqntOV1Ja+ORnwLkBTEMkYtoBJanxMavmjB3Mjbr7sjp/phAOy5rc8bJg8+HII6tZ8AUlLj5ajr26RLxdPVK6YaG888l1Wbd4PAlO288Hfi8i/7VwHo5duVvKXly9YBw7jl5jxfThTB47mChDCCsYCiGUg5/fRswGaYkOzlxv4PimpeuBnQ8DfR+BtHT2VC7ZenTM+xsWsnr7p5y9UgsOK5hNEAxBb4j1y6cyb8JQij/4kpulq/aZTUb+t4C+hwAg69S1+q+e33HSsmvdPKobOzl2uQa3N8DI1Dh+On8ctU2dvHm4goq388tT42NmA33fIhhY+t8pQ2RWTUvXyWdeO2wfnZ7A4ukjcNot3G328M8zlbicNo79YXmFyZA5qhr4ToxHETwgGQW89+G/b809Uf6NuSfYp8mxMbJ8bpZn/qSMvcCGR1ThkSX633gOWAPYgEagCLj5/5L+A8sa0JgetnBBAAAAAElFTkSuQmCC"

/***/ }),

/***/ "5319":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var apply = __webpack_require__("2ba4");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var fails = __webpack_require__("d039");
var anObject = __webpack_require__("825a");
var isCallable = __webpack_require__("1626");
var toIntegerOrInfinity = __webpack_require__("5926");
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");
var advanceStringIndex = __webpack_require__("8aa5");
var getMethod = __webpack_require__("dc4a");
var getSubstitution = __webpack_require__("0cb2");
var regExpExec = __webpack_require__("14c3");
var wellKnownSymbol = __webpack_require__("b622");

var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var concat = uncurryThis([].concat);
var push = uncurryThis([].push);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);
      return replacer
        ? call(replacer, searchValue, O, replaceValue)
        : call(nativeReplace, toString(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject(this);
      var S = toString(string);

      if (
        typeof replaceValue == 'string' &&
        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
        stringIndexOf(replaceValue, '$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = isCallable(replaceValue);
      if (!functionalReplace) replaceValue = toString(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        push(results, result);
        if (!global) break;

        var matchStr = toString(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString(result[0]);
        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position, S);
          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
          var replacement = toString(apply(replaceValue, undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + stringSlice(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);


/***/ }),

/***/ "5564":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("df4c");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1300");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("92fa");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("38f3");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("7fc9");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/Base
 */






/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */
/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer = /** @class */ (function (_super) {
    __extends(BaseLayer, _super);
    /**
     * @param {Options} options Layer options.
     */
    function BaseLayer(options) {
        var _this = _super.call(this) || this;
        /***
         * @type {BaseLayerOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {BaseLayerOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {BaseLayerOnSignature<void>}
         */
        _this.un;
        /**
         * @type {BackgroundColor|false}
         * @private
         */
        _this.background_ = options.background;
        /**
         * @type {Object<string, *>}
         */
        var properties = Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__[/* assign */ "a"])({}, options);
        if (typeof options.properties === 'object') {
            delete properties.properties;
            Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__[/* assign */ "a"])(properties, options.properties);
        }
        properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].OPACITY] =
            options.opacity !== undefined ? options.opacity : 1;
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__[/* assert */ "a"])(typeof properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].OPACITY] === 'number', 64); // Layer opacity must be a number
        properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].VISIBLE] =
            options.visible !== undefined ? options.visible : true;
        properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Z_INDEX] = options.zIndex;
        properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MAX_RESOLUTION] =
            options.maxResolution !== undefined ? options.maxResolution : Infinity;
        properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MIN_RESOLUTION] =
            options.minResolution !== undefined ? options.minResolution : 0;
        properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MIN_ZOOM] =
            options.minZoom !== undefined ? options.minZoom : -Infinity;
        properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MAX_ZOOM] =
            options.maxZoom !== undefined ? options.maxZoom : Infinity;
        /**
         * @type {string}
         * @private
         */
        _this.className_ =
            properties.className !== undefined ? properties.className : 'ol-layer';
        delete properties.className;
        _this.setProperties(properties);
        /**
         * @type {import("./Layer.js").State}
         * @private
         */
        _this.state_ = null;
        return _this;
    }
    /**
     * Get the background for this layer.
     * @return {BackgroundColor|false} Layer background.
     */
    BaseLayer.prototype.getBackground = function () {
        return this.background_;
    };
    /**
     * @return {string} CSS class name.
     */
    BaseLayer.prototype.getClassName = function () {
        return this.className_;
    };
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [opt_managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */
    BaseLayer.prototype.getLayerState = function (opt_managed) {
        /** @type {import("./Layer.js").State} */
        var state = this.state_ ||
            /** @type {?} */ ({
                layer: this,
                managed: opt_managed === undefined ? true : opt_managed,
            });
        var zIndex = this.getZIndex();
        state.opacity = Object(_math_js__WEBPACK_IMPORTED_MODULE_5__[/* clamp */ "b"])(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
    };
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    BaseLayer.prototype.getLayersArray = function (opt_array) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [opt_states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */
    BaseLayer.prototype.getExtent = function () {
        return /** @type {import("../extent.js").Extent|undefined} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].EXTENT));
    };
    /**
     * Return the maximum resolution of the layer.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.getMaxResolution = function () {
        return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MAX_RESOLUTION));
    };
    /**
     * Return the minimum resolution of the layer.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.getMinResolution = function () {
        return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MIN_RESOLUTION));
    };
    /**
     * Return the minimum zoom level of the layer.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.getMinZoom = function () {
        return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MIN_ZOOM));
    };
    /**
     * Return the maximum zoom level of the layer.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.getMaxZoom = function () {
        return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MAX_ZOOM));
    };
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.getOpacity = function () {
        return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].OPACITY));
    };
    /**
     * @abstract
     * @return {import("../source/State.js").default} Source state.
     */
    BaseLayer.prototype.getSourceState = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Return the visibility of the layer (`true` or `false`).
     * @return {boolean} The visibility of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.getVisible = function () {
        return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].VISIBLE));
    };
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. The default Z-index is 0.
     * @return {number} The Z-index of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.getZIndex = function () {
        return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Z_INDEX));
    };
    /**
     * Sets the background color.
     * @param {BackgroundColor} [opt_background] Background color.
     */
    BaseLayer.prototype.setBackground = function (opt_background) {
        this.background_ = opt_background;
        this.changed();
    };
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setExtent = function (extent) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].EXTENT, extent);
    };
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setMaxResolution = function (maxResolution) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MAX_RESOLUTION, maxResolution);
    };
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setMinResolution = function (minResolution) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MIN_RESOLUTION, minResolution);
    };
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setMaxZoom = function (maxZoom) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MAX_ZOOM, maxZoom);
    };
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setMinZoom = function (minZoom) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MIN_ZOOM, minZoom);
    };
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setOpacity = function (opacity) {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__[/* assert */ "a"])(typeof opacity === 'number', 64); // Layer opacity must be a number
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].OPACITY, opacity);
    };
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setVisible = function (visible) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].VISIBLE, visible);
    };
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */
    BaseLayer.prototype.setZIndex = function (zindex) {
        this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Z_INDEX, zindex);
    };
    /**
     * Clean up.
     */
    BaseLayer.prototype.disposeInternal = function () {
        if (this.state_) {
            this.state_.layer = null;
            this.state_ = null;
        }
        _super.prototype.disposeInternal.call(this);
    };
    return BaseLayer;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (BaseLayer);
//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "5692":
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__("c430");
var store = __webpack_require__("c6cd");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.21.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "56ef":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var uncurryThis = __webpack_require__("e330");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var anObject = __webpack_require__("825a");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "573a":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "575a":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "577e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var classof = __webpack_require__("f5df");

var String = global.String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ "57b3":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon-position.8c5bf7d0.png";

/***/ }),

/***/ "57cb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TRUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FALSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return VOID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return memoizeOne; });
/* unused harmony export toPromise */
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9f5e");
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @return {boolean} true.
 */
function TRUE() {
    return true;
}
/**
 * Always returns false.
 * @return {boolean} false.
 */
function FALSE() {
    return false;
}
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() { }
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */
function memoizeOne(fn) {
    var called = false;
    /** @type {ReturnType} */
    var lastResult;
    /** @type {Array<any>} */
    var lastArgs;
    var lastThis;
    return function () {
        var nextArgs = Array.prototype.slice.call(arguments);
        if (!called || this !== lastThis || !Object(_array_js__WEBPACK_IMPORTED_MODULE_0__[/* equals */ "b"])(nextArgs, lastArgs)) {
            called = true;
            lastThis = this;
            lastArgs = nextArgs;
            lastResult = fn.apply(this, arguments);
        }
        return lastResult;
    };
}
/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */
function toPromise(getter) {
    function promiseGetter() {
        var value;
        try {
            value = getter();
        }
        catch (err) {
            return Promise.reject(err);
        }
        if (value instanceof Promise) {
            return value;
        }
        return Promise.resolve(value);
    }
    return promiseGetter();
}
//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "5831":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: VectorSourceEvent

// EXTERNAL MODULE: ./node_modules/ol/Collection.js
var Collection = __webpack_require__("e300");

// EXTERNAL MODULE: ./node_modules/ol/CollectionEventType.js
var CollectionEventType = __webpack_require__("183a");

// EXTERNAL MODULE: ./node_modules/ol/events/Event.js
var Event = __webpack_require__("cef7");

// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js
var EventType = __webpack_require__("01d4");

// EXTERNAL MODULE: ./node_modules/ol/ObjectEventType.js
var ObjectEventType = __webpack_require__("7b4f");

// EXTERNAL MODULE: ./node_modules/ol/structs/RBush.js
var RBush = __webpack_require__("4a7d");

// EXTERNAL MODULE: ./node_modules/ol/source/Source.js
var Source = __webpack_require__("ff80");

// EXTERNAL MODULE: ./node_modules/ol/source/State.js
var State = __webpack_require__("6d83");

// EXTERNAL MODULE: ./node_modules/ol/source/VectorEventType.js
var VectorEventType = __webpack_require__("a43f");

// EXTERNAL MODULE: ./node_modules/ol/functions.js
var functions = __webpack_require__("57cb");

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules
var proj = __webpack_require__("256f");

// CONCATENATED MODULE: ./node_modules/ol/loadingstrategy.js
/**
 * @module ol/loadingstrategy
 */

/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function loadingstrategy_all(extent, resolution) {
    return [[-Infinity, -Infinity, Infinity, Infinity]];
}
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
    return [extent];
}
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
    return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution, projection) {
        var z = tileGrid.getZForResolution(Object(proj["l" /* fromUserResolution */])(resolution, projection));
        var tileRange = tileGrid.getTileRangeForExtentAndZ(Object(proj["k" /* fromUserExtent */])(extent, projection), z);
        /** @type {Array<import("./extent.js").Extent>} */
        var extents = [];
        /** @type {import("./tilecoord.js").TileCoord} */
        var tileCoord = [z, 0, 0];
        for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
            for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
                extents.push(Object(proj["s" /* toUserExtent */])(tileGrid.getTileCoordExtent(tileCoord), projection));
            }
        }
        return extents;
    });
}
//# sourceMappingURL=loadingstrategy.js.map
// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__("92fa");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var ol_obj = __webpack_require__("38f3");

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__("1e8d");

// EXTERNAL MODULE: ./node_modules/ol/format/FormatType.js
var FormatType = __webpack_require__("1ecb");

// CONCATENATED MODULE: ./node_modules/ol/featureloader.js
/**
 * @module ol/featureloader
 */


/**
 *
 * @type {boolean}
 * @private
 */
var withCredentials = false;
/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */
/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */
/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
    if (format.getType() == FormatType["a" /* default */].ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
    }
    xhr.withCredentials = withCredentials;
    /**
     * @param {Event} event Event.
     * @private
     */
    xhr.onload = function (event) {
        // status will be 0 for file:// urls
        if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
            var type = format.getType();
            /** @type {Document|Node|Object|string|undefined} */
            var source = void 0;
            if (type == FormatType["a" /* default */].JSON || type == FormatType["a" /* default */].TEXT) {
                source = xhr.responseText;
            }
            else if (type == FormatType["a" /* default */].XML) {
                source = xhr.responseXML;
                if (!source) {
                    source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                }
            }
            else if (type == FormatType["a" /* default */].ARRAY_BUFFER) {
                source = /** @type {ArrayBuffer} */ (xhr.response);
            }
            if (source) {
                success(
                /** @type {Array<import("./Feature.js").default>} */
                (format.readFeatures(source, {
                    extent: extent,
                    featureProjection: projection,
                })), format.readProjection(source));
            }
            else {
                failure();
            }
        }
        else {
            failure();
        }
    };
    /**
     * @private
     */
    xhr.onerror = failure;
    xhr.send();
}
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */
function featureloader_xhr(url, format) {
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @param {function(Array<import("./Feature.js").default>): void} [success] Success
     *      Function called when loading succeeded.
     * @param {function(): void} [failure] Failure
     *      Function called when loading failed.
     * @this {import("./source/Vector").default}
     */
    return function (extent, resolution, projection, success, failure) {
        var source = /** @type {import("./source/Vector").default} */ (this);
        loadFeaturesXhr(url, format, extent, resolution, projection, 
        /**
         * @param {Array<import("./Feature.js").default>} features The loaded features.
         * @param {import("./proj/Projection.js").default} dataProjection Data
         * projection.
         */
        function (features, dataProjection) {
            source.addFeatures(features);
            if (success !== undefined) {
                success(features);
            }
        }, 
        /* FIXME handle error */ failure ? failure : functions["c" /* VOID */]);
    };
}
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */
function setWithCredentials(xhrWithCredentials) {
    withCredentials = xhrWithCredentials;
}
//# sourceMappingURL=featureloader.js.map
// CONCATENATED MODULE: ./node_modules/ol/source/Vector.js
/**
 * @module ol/source/Vector
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */
var VectorSourceEvent = /** @class */ (function (_super) {
    __extends(VectorSourceEvent, _super);
    /**
     * @param {string} type Type.
     * @param {import("../Feature.js").default<Geometry>} [opt_feature] Feature.
     * @param {Array<import("../Feature.js").default<Geometry>>} [opt_features] Features.
     */
    function VectorSourceEvent(type, opt_feature, opt_features) {
        var _this = _super.call(this, type) || this;
        /**
         * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
         * @type {import("../Feature.js").default<Geometry>|undefined}
         * @api
         */
        _this.feature = opt_feature;
        /**
         * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
         * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
         * @api
         */
        _this.features = opt_features;
        return _this;
    }
    return VectorSourceEvent;
}(Event["a" /* default */]));

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          var features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */
/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */
var Vector_VectorSource = /** @class */ (function (_super) {
    __extends(VectorSource, _super);
    /**
     * @param {Options} [opt_options] Vector source options.
     */
    function VectorSource(opt_options) {
        var _this = this;
        var options = opt_options || {};
        _this = _super.call(this, {
            attributions: options.attributions,
            interpolate: true,
            projection: undefined,
            state: State["a" /* default */].READY,
            wrapX: options.wrapX !== undefined ? options.wrapX : true,
        }) || this;
        /***
         * @type {VectorSourceOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {VectorSourceOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {VectorSourceOnSignature<void>}
         */
        _this.un;
        /**
         * @private
         * @type {import("../featureloader.js").FeatureLoader}
         */
        _this.loader_ = functions["c" /* VOID */];
        /**
         * @private
         * @type {import("../format/Feature.js").default|undefined}
         */
        _this.format_ = options.format;
        /**
         * @private
         * @type {boolean}
         */
        _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
        /**
         * @private
         * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
         */
        _this.url_ = options.url;
        if (options.loader !== undefined) {
            _this.loader_ = options.loader;
        }
        else if (_this.url_ !== undefined) {
            Object(asserts["a" /* assert */])(_this.format_, 7); // `format` must be set when `url` is set
            // create a XHR feature loader for "url" and "format"
            _this.loader_ = featureloader_xhr(_this.url_, 
            /** @type {import("../format/Feature.js").default} */ (_this.format_));
        }
        /**
         * @private
         * @type {LoadingStrategy}
         */
        _this.strategy_ =
            options.strategy !== undefined ? options.strategy : loadingstrategy_all;
        var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
        /**
         * @private
         * @type {RBush<import("../Feature.js").default<Geometry>>}
         */
        _this.featuresRtree_ = useSpatialIndex ? new RBush["a" /* default */]() : null;
        /**
         * @private
         * @type {RBush<{extent: import("../extent.js").Extent}>}
         */
        _this.loadedExtentsRtree_ = new RBush["a" /* default */]();
        /**
         * @type {number}
         * @private
         */
        _this.loadingExtentsCount_ = 0;
        /**
         * @private
         * @type {!Object<string, import("../Feature.js").default<Geometry>>}
         */
        _this.nullGeometryFeatures_ = {};
        /**
         * A lookup of features by id (the return from feature.getId()).
         * @private
         * @type {!Object<string, import("../Feature.js").default<Geometry>>}
         */
        _this.idIndex_ = {};
        /**
         * A lookup of features by uid (using getUid(feature)).
         * @private
         * @type {!Object<string, import("../Feature.js").default<Geometry>>}
         */
        _this.uidIndex_ = {};
        /**
         * @private
         * @type {Object<string, Array<import("../events.js").EventsKey>>}
         */
        _this.featureChangeKeys_ = {};
        /**
         * @private
         * @type {Collection<import("../Feature.js").default<Geometry>>|null}
         */
        _this.featuresCollection_ = null;
        var collection, features;
        if (Array.isArray(options.features)) {
            features =
                /** @type {Array<import("../Feature.js").default<Geometry>>} */ (options.features);
        }
        else if (options.features) {
            collection =
                /** @type {Collection<import("../Feature.js").default<Geometry>>} */ (options.features);
            features = collection.getArray();
        }
        if (!useSpatialIndex && collection === undefined) {
            collection = new Collection["a" /* default */](features);
        }
        if (features !== undefined) {
            _this.addFeaturesInternal(features);
        }
        if (collection !== undefined) {
            _this.bindFeaturesCollection_(collection);
        }
        return _this;
    }
    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
     * meaning that if a feature with a duplicate id is added in the collection, it will
     * be removed from it right away.
     * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
     * @api
     */
    VectorSource.prototype.addFeature = function (feature) {
        this.addFeatureInternal(feature);
        this.changed();
    };
    /**
     * Add a feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @protected
     */
    VectorSource.prototype.addFeatureInternal = function (feature) {
        var featureKey = Object(util["c" /* getUid */])(feature);
        if (!this.addToIndex_(featureKey, feature)) {
            if (this.featuresCollection_) {
                this.featuresCollection_.remove(feature);
            }
            return;
        }
        this.setupChangeEvents_(featureKey, feature);
        var geometry = feature.getGeometry();
        if (geometry) {
            var extent = geometry.getExtent();
            if (this.featuresRtree_) {
                this.featuresRtree_.insert(extent, feature);
            }
        }
        else {
            this.nullGeometryFeatures_[featureKey] = feature;
        }
        this.dispatchEvent(new VectorSourceEvent(VectorEventType["a" /* default */].ADDFEATURE, feature));
    };
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @private
     */
    VectorSource.prototype.setupChangeEvents_ = function (featureKey, feature) {
        this.featureChangeKeys_[featureKey] = [
            Object(events["a" /* listen */])(feature, EventType["a" /* default */].CHANGE, this.handleFeatureChange_, this),
            Object(events["a" /* listen */])(feature, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.handleFeatureChange_, this),
        ];
    };
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
    VectorSource.prototype.addToIndex_ = function (featureKey, feature) {
        var valid = true;
        var id = feature.getId();
        if (id !== undefined) {
            if (!(id.toString() in this.idIndex_)) {
                this.idIndex_[id.toString()] = feature;
            }
            else {
                valid = false;
            }
        }
        if (valid) {
            Object(asserts["a" /* assert */])(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source
            this.uidIndex_[featureKey] = feature;
        }
        return valid;
    };
    /**
     * Add a batch of features to the source.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
     * @api
     */
    VectorSource.prototype.addFeatures = function (features) {
        this.addFeaturesInternal(features);
        this.changed();
    };
    /**
     * Add features without firing a `change` event.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
     * @protected
     */
    VectorSource.prototype.addFeaturesInternal = function (features) {
        var extents = [];
        var newFeatures = [];
        var geometryFeatures = [];
        for (var i = 0, length_1 = features.length; i < length_1; i++) {
            var feature = features[i];
            var featureKey = Object(util["c" /* getUid */])(feature);
            if (this.addToIndex_(featureKey, feature)) {
                newFeatures.push(feature);
            }
        }
        for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
            var feature = newFeatures[i];
            var featureKey = Object(util["c" /* getUid */])(feature);
            this.setupChangeEvents_(featureKey, feature);
            var geometry = feature.getGeometry();
            if (geometry) {
                var extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature);
            }
            else {
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        }
        if (this.featuresRtree_) {
            this.featuresRtree_.load(extents, geometryFeatures);
        }
        if (this.hasListener(VectorEventType["a" /* default */].ADDFEATURE)) {
            for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
                this.dispatchEvent(new VectorSourceEvent(VectorEventType["a" /* default */].ADDFEATURE, newFeatures[i]));
            }
        }
    };
    /**
     * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
     * @private
     */
    VectorSource.prototype.bindFeaturesCollection_ = function (collection) {
        var modifyingCollection = false;
        this.addEventListener(VectorEventType["a" /* default */].ADDFEATURE, 
        /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */
        function (evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.push(evt.feature);
                modifyingCollection = false;
            }
        });
        this.addEventListener(VectorEventType["a" /* default */].REMOVEFEATURE, 
        /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */
        function (evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.remove(evt.feature);
                modifyingCollection = false;
            }
        });
        collection.addEventListener(CollectionEventType["a" /* default */].ADD, 
        /**
         * @param {import("../Collection.js").CollectionEvent} evt The collection event
         */
        function (evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.addFeature(
                /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                modifyingCollection = false;
            }
        }.bind(this));
        collection.addEventListener(CollectionEventType["a" /* default */].REMOVE, 
        /**
         * @param {import("../Collection.js").CollectionEvent} evt The collection event
         */
        function (evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.removeFeature(
                /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                modifyingCollection = false;
            }
        }.bind(this));
        this.featuresCollection_ = collection;
    };
    /**
     * Remove all features from the source.
     * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature removefeature} events.
     * @api
     */
    VectorSource.prototype.clear = function (opt_fast) {
        if (opt_fast) {
            for (var featureId in this.featureChangeKeys_) {
                var keys = this.featureChangeKeys_[featureId];
                keys.forEach(events["c" /* unlistenByKey */]);
            }
            if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {};
                this.idIndex_ = {};
                this.uidIndex_ = {};
            }
        }
        else {
            if (this.featuresRtree_) {
                var removeAndIgnoreReturn = function (feature) {
                    this.removeFeatureInternal(feature);
                }.bind(this);
                this.featuresRtree_.forEach(removeAndIgnoreReturn);
                for (var id in this.nullGeometryFeatures_) {
                    this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                }
            }
        }
        if (this.featuresCollection_) {
            this.featuresCollection_.clear();
        }
        if (this.featuresRtree_) {
            this.featuresRtree_.clear();
        }
        this.nullGeometryFeatures_ = {};
        var clearEvent = new VectorSourceEvent(VectorEventType["a" /* default */].CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
    };
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    VectorSource.prototype.forEachFeature = function (callback) {
        if (this.featuresRtree_) {
            return this.featuresRtree_.forEach(callback);
        }
        else if (this.featuresCollection_) {
            this.featuresCollection_.forEach(callback);
        }
    };
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    VectorSource.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback) {
        var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
        return this.forEachFeatureInExtent(extent, function (feature) {
            var geometry = feature.getGeometry();
            if (geometry.intersectsCoordinate(coordinate)) {
                return callback(feature);
            }
            else {
                return undefined;
            }
        });
    };
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    VectorSource.prototype.forEachFeatureInExtent = function (extent, callback) {
        if (this.featuresRtree_) {
            return this.featuresRtree_.forEachInExtent(extent, callback);
        }
        else if (this.featuresCollection_) {
            this.featuresCollection_.forEach(callback);
        }
    };
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    VectorSource.prototype.forEachFeatureIntersectingExtent = function (extent, callback) {
        return this.forEachFeatureInExtent(extent, 
        /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         */
        function (feature) {
            var geometry = feature.getGeometry();
            if (geometry.intersectsExtent(extent)) {
                var result = callback(feature);
                if (result) {
                    return result;
                }
            }
        });
    };
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with an {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
     * @api
     */
    VectorSource.prototype.getFeaturesCollection = function () {
        return this.featuresCollection_;
    };
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */
    VectorSource.prototype.getFeatures = function () {
        var features;
        if (this.featuresCollection_) {
            features = this.featuresCollection_.getArray().slice(0);
        }
        else if (this.featuresRtree_) {
            features = this.featuresRtree_.getAll();
            if (!Object(ol_obj["d" /* isEmpty */])(this.nullGeometryFeatures_)) {
                Object(array["c" /* extend */])(features, Object(ol_obj["c" /* getValues */])(this.nullGeometryFeatures_));
            }
        }
        return /** @type {Array<import("../Feature.js").default<Geometry>>} */ (features);
    };
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */
    VectorSource.prototype.getFeaturesAtCoordinate = function (coordinate) {
        var features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
            features.push(feature);
        });
        return features;
    };
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */
    VectorSource.prototype.getFeaturesInExtent = function (extent) {
        if (this.featuresRtree_) {
            return this.featuresRtree_.getInExtent(extent);
        }
        else if (this.featuresCollection_) {
            return this.featuresCollection_.getArray().slice(0);
        }
        else {
            return [];
        }
    };
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>):boolean} [opt_filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {import("../Feature.js").default<Geometry>} Closest feature.
     * @api
     */
    VectorSource.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
        // Find the closest feature using branch and bound.  We start searching an
        // infinite extent, and find the distance from the first feature found.  This
        // becomes the closest feature.  We then compute a smaller extent which any
        // closer feature must intersect.  We continue searching with this smaller
        // extent, trying to find a closer feature.  Every time we find a closer
        // feature, we update the extent being searched so that any even closer
        // feature must intersect it.  We continue until we run out of features.
        var x = coordinate[0];
        var y = coordinate[1];
        var closestFeature = null;
        var closestPoint = [NaN, NaN];
        var minSquaredDistance = Infinity;
        var extent = [-Infinity, -Infinity, Infinity, Infinity];
        var filter = opt_filter ? opt_filter : functions["b" /* TRUE */];
        this.featuresRtree_.forEachInExtent(extent, 
        /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         */
        function (feature) {
            if (filter(feature)) {
                var geometry = feature.getGeometry();
                var previousMinSquaredDistance = minSquaredDistance;
                minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                if (minSquaredDistance < previousMinSquaredDistance) {
                    closestFeature = feature;
                    // This is sneaky.  Reduce the extent that it is currently being
                    // searched while the R-Tree traversal using this same extent object
                    // is still in progress.  This is safe because the new extent is
                    // strictly contained by the old extent.
                    var minDistance = Math.sqrt(minSquaredDistance);
                    extent[0] = x - minDistance;
                    extent[1] = y - minDistance;
                    extent[2] = x + minDistance;
                    extent[3] = y + minDistance;
                }
            }
        });
        return closestFeature;
    };
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [opt_extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    VectorSource.prototype.getExtent = function (opt_extent) {
        return this.featuresRtree_.getExtent(opt_extent);
    };
    /**
     * Get a feature by its identifier (the value returned by feature.getId()).
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
     * @api
     */
    VectorSource.prototype.getFeatureById = function (id) {
        var feature = this.idIndex_[id.toString()];
        return feature !== undefined ? feature : null;
    };
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
     */
    VectorSource.prototype.getFeatureByUid = function (uid) {
        var feature = this.uidIndex_[uid];
        return feature !== undefined ? feature : null;
    };
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default|undefined} The feature format.
     * @api
     */
    VectorSource.prototype.getFormat = function () {
        return this.format_;
    };
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    VectorSource.prototype.getOverlaps = function () {
        return this.overlaps_;
    };
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */
    VectorSource.prototype.getUrl = function () {
        return this.url_;
    };
    /**
     * @param {Event} event Event.
     * @private
     */
    VectorSource.prototype.handleFeatureChange_ = function (event) {
        var feature = /** @type {import("../Feature.js").default<Geometry>} */ (event.target);
        var featureKey = Object(util["c" /* getUid */])(feature);
        var geometry = feature.getGeometry();
        if (!geometry) {
            if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) {
                    this.featuresRtree_.remove(feature);
                }
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        }
        else {
            var extent = geometry.getExtent();
            if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) {
                    this.featuresRtree_.insert(extent, feature);
                }
            }
            else {
                if (this.featuresRtree_) {
                    this.featuresRtree_.update(extent, feature);
                }
            }
        }
        var id = feature.getId();
        if (id !== undefined) {
            var sid = id.toString();
            if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
            }
        }
        else {
            this.removeFromIdIndex_(feature);
            this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(new VectorSourceEvent(VectorEventType["a" /* default */].CHANGEFEATURE, feature));
    };
    /**
     * Returns true if the feature is contained within the source.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
    VectorSource.prototype.hasFeature = function (feature) {
        var id = feature.getId();
        if (id !== undefined) {
            return id in this.idIndex_;
        }
        else {
            return Object(util["c" /* getUid */])(feature) in this.uidIndex_;
        }
    };
    /**
     * @return {boolean} Is empty.
     */
    VectorSource.prototype.isEmpty = function () {
        if (this.featuresRtree_) {
            return (this.featuresRtree_.isEmpty() && Object(ol_obj["d" /* isEmpty */])(this.nullGeometryFeatures_));
        }
        if (this.featuresCollection_) {
            return this.featuresCollection_.getLength() === 0;
        }
        return true;
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    VectorSource.prototype.loadFeatures = function (extent, resolution, projection) {
        var loadedExtentsRtree = this.loadedExtentsRtree_;
        var extentsToLoad = this.strategy_(extent, resolution, projection);
        var _loop_1 = function (i, ii) {
            var extentToLoad = extentsToLoad[i];
            var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, 
            /**
             * @param {{extent: import("../extent.js").Extent}} object Object.
             * @return {boolean} Contains.
             */
            function (object) {
                return Object(ol_extent["g" /* containsExtent */])(object.extent, extentToLoad);
            });
            if (!alreadyLoaded) {
                ++this_1.loadingExtentsCount_;
                this_1.dispatchEvent(new VectorSourceEvent(VectorEventType["a" /* default */].FEATURESLOADSTART));
                this_1.loader_.call(this_1, extentToLoad, resolution, projection, function (features) {
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent(VectorEventType["a" /* default */].FEATURESLOADEND, undefined, features));
                }.bind(this_1), function () {
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent(VectorEventType["a" /* default */].FEATURESLOADERROR));
                }.bind(this_1));
                loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
            }
        };
        var this_1 = this;
        for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
            _loop_1(i, ii);
        }
        this.loading =
            this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    };
    VectorSource.prototype.refresh = function () {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        _super.prototype.refresh.call(this);
    };
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    VectorSource.prototype.removeLoadedExtent = function (extent) {
        var loadedExtentsRtree = this.loadedExtentsRtree_;
        var obj;
        loadedExtentsRtree.forEachInExtent(extent, function (object) {
            if (Object(ol_extent["o" /* equals */])(object.extent, extent)) {
                obj = object;
                return true;
            }
        });
        if (obj) {
            loadedExtentsRtree.remove(obj);
        }
    };
    /**
     * Remove a single feature from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
     * @api
     */
    VectorSource.prototype.removeFeature = function (feature) {
        if (!feature) {
            return;
        }
        var featureKey = Object(util["c" /* getUid */])(feature);
        if (featureKey in this.nullGeometryFeatures_) {
            delete this.nullGeometryFeatures_[featureKey];
        }
        else {
            if (this.featuresRtree_) {
                this.featuresRtree_.remove(feature);
            }
        }
        var result = this.removeFeatureInternal(feature);
        if (result) {
            this.changed();
        }
    };
    /**
     * Remove feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
     *     (or undefined if the feature was not found).
     * @protected
     */
    VectorSource.prototype.removeFeatureInternal = function (feature) {
        var featureKey = Object(util["c" /* getUid */])(feature);
        var featureChangeKeys = this.featureChangeKeys_[featureKey];
        if (!featureChangeKeys) {
            return;
        }
        featureChangeKeys.forEach(events["c" /* unlistenByKey */]);
        delete this.featureChangeKeys_[featureKey];
        var id = feature.getId();
        if (id !== undefined) {
            delete this.idIndex_[id.toString()];
        }
        delete this.uidIndex_[featureKey];
        this.dispatchEvent(new VectorSourceEvent(VectorEventType["a" /* default */].REMOVEFEATURE, feature));
        return feature;
    };
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} Removed the feature from the index.
     * @private
     */
    VectorSource.prototype.removeFromIdIndex_ = function (feature) {
        var removed = false;
        for (var id in this.idIndex_) {
            if (this.idIndex_[id] === feature) {
                delete this.idIndex_[id];
                removed = true;
                break;
            }
        }
        return removed;
    };
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
     * @api
     */
    VectorSource.prototype.setLoader = function (loader) {
        this.loader_ = loader;
    };
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */
    VectorSource.prototype.setUrl = function (url) {
        Object(asserts["a" /* assert */])(this.format_, 7); // `format` must be set when `url` is set
        this.url_ = url;
        this.setLoader(featureloader_xhr(url, this.format_));
    };
    return VectorSource;
}(Source["a" /* default */]));
/* harmony default export */ var Vector = __webpack_exports__["a"] = (Vector_VectorSource);
//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "5899":
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "58a8":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var requireObjectCoercible = __webpack_require__("1d80");
var toString = __webpack_require__("577e");
var whitespaces = __webpack_require__("5899");

var replace = uncurryThis(''.replace);
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "5926":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- safe
  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
};


/***/ }),

/***/ "592d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/MapEventType
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Triggered after a map frame is rendered.
     * @event module:ol/MapEvent~MapEvent#postrender
     * @api
     */
    POSTRENDER: 'postrender',
    /**
     * Triggered when the map starts moving.
     * @event module:ol/MapEvent~MapEvent#movestart
     * @api
     */
    MOVESTART: 'movestart',
    /**
     * Triggered after the map is moved.
     * @event module:ol/MapEvent~MapEvent#moveend
     * @api
     */
    MOVEEND: 'moveend',
});
/***
 * @typedef {'postrender'|'movestart'|'moveend'} Types
 */
//# sourceMappingURL=MapEventType.js.map

/***/ }),

/***/ "5938":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return lineStringLength; });
/* unused harmony export linearRingLength */
/**
 * @module ol/geom/flat/length
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    for (var i = offset + stride; i < end; i += stride) {
        var x2 = flatCoordinates[i];
        var y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        x1 = x2;
        y1 = y2;
    }
    return length;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
function linearRingLength(flatCoordinates, offset, end, stride) {
    var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
    var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
    var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
    perimeter += Math.sqrt(dx * dx + dy * dy);
    return perimeter;
}
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "59ed":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");
var tryToString = __webpack_require__("0d51");

var TypeError = global.TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "5a95":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "5b3d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "5bc3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ fromExtent; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ fromCircle; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ makeRegular; });

// UNUSED EXPORTS: circular

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryLayout.js
var GeometryLayout = __webpack_require__("521b");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js
var GeometryType = __webpack_require__("f623");

// EXTERNAL MODULE: ./node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = __webpack_require__("9abc");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/closest.js
var closest = __webpack_require__("9769");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/deflate.js
var deflate = __webpack_require__("abb7");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js
var simplify = __webpack_require__("1c48");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js
var inflate = __webpack_require__("bb6c");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/area.js
var flat_area = __webpack_require__("b589");

// CONCATENATED MODULE: ./node_modules/ol/geom/LinearRing.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/LinearRing
 */









/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
var LinearRing_LinearRing = /** @class */ (function (_super) {
    __extends(LinearRing, _super);
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */
    function LinearRing(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {number}
         */
        _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.maxDeltaRevision_ = -1;
        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
            _this.setFlatCoordinates(opt_layout, 
            /** @type {Array<number>} */ (coordinates));
        }
        else {
            _this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
        }
        return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     */
    LinearRing.prototype.clone = function () {
        return new LinearRing(this.flatCoordinates.slice(), this.layout);
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < Object(ol_extent["e" /* closestSquaredDistanceXY */])(this.getExtent(), x, y)) {
            return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(Object(closest["e" /* maxSquaredDelta */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return Object(closest["d" /* assignClosestPoint */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    LinearRing.prototype.getArea = function () {
        return Object(flat_area["a" /* linearRing */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
    LinearRing.prototype.getCoordinates = function () {
        return Object(inflate["a" /* inflateCoordinates */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     */
    LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = Object(simplify["a" /* douglasPeucker */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LinearRing(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    LinearRing.prototype.getType = function () {
        return GeometryType["a" /* default */].LINEAR_RING;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    LinearRing.prototype.intersectsExtent = function (extent) {
        return false;
    };
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */
    LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        this.flatCoordinates.length = Object(deflate["b" /* deflateCoordinates */])(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return LinearRing;
}(SimpleGeometry["a" /* default */]));
/* harmony default export */ var geom_LinearRing = (LinearRing_LinearRing);
//# sourceMappingURL=LinearRing.js.map
// EXTERNAL MODULE: ./node_modules/ol/geom/Point.js
var Point = __webpack_require__("f403");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/interiorpoint.js
var interiorpoint = __webpack_require__("0a9d");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/intersectsextent.js
var intersectsextent = __webpack_require__("c560");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/orient.js + 1 modules
var orient = __webpack_require__("4d98");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/contains.js
var contains = __webpack_require__("25f1");

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__("7fc9");

// EXTERNAL MODULE: ./node_modules/ol/sphere.js
var sphere = __webpack_require__("790a");

// CONCATENATED MODULE: ./node_modules/ol/geom/Polygon.js
var Polygon_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/Polygon
 */


















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
var Polygon_Polygon = /** @class */ (function (_super) {
    Polygon_extends(Polygon, _super);
    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `opt_layout` and `opt_ends` are also accepted.)
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).
     */
    function Polygon(coordinates, opt_layout, opt_ends) {
        var _this = _super.call(this) || this;
        /**
         * @type {Array<number>}
         * @private
         */
        _this.ends_ = [];
        /**
         * @private
         * @type {number}
         */
        _this.flatInteriorPointRevision_ = -1;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */
        _this.flatInteriorPoint_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.maxDeltaRevision_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.orientedRevision_ = -1;
        /**
         * @private
         * @type {Array<number>}
         */
        _this.orientedFlatCoordinates_ = null;
        if (opt_layout !== undefined && opt_ends) {
            _this.setFlatCoordinates(opt_layout, 
            /** @type {Array<number>} */ (coordinates));
            _this.ends_ = opt_ends;
        }
        else {
            _this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
        }
        return _this;
    }
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */
    Polygon.prototype.appendLinearRing = function (linearRing) {
        if (!this.flatCoordinates) {
            this.flatCoordinates = linearRing.getFlatCoordinates().slice();
        }
        else {
            Object(array["c" /* extend */])(this.flatCoordinates, linearRing.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     */
    Polygon.prototype.clone = function () {
        var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        polygon.applyProperties(this);
        return polygon;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < Object(ol_extent["e" /* closestSquaredDistanceXY */])(this.getExtent(), x, y)) {
            return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(Object(closest["a" /* arrayMaxSquaredDelta */])(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return Object(closest["b" /* assignClosestArrayPoint */])(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    Polygon.prototype.containsXY = function (x, y) {
        return Object(contains["c" /* linearRingsContainsXY */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    };
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    Polygon.prototype.getArea = function () {
        return Object(flat_area["b" /* linearRings */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    };
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [opt_right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */
    Polygon.prototype.getCoordinates = function (opt_right) {
        var flatCoordinates;
        if (opt_right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            Object(orient["c" /* orientLinearRings */])(flatCoordinates, 0, this.ends_, this.stride, opt_right);
        }
        else {
            flatCoordinates = this.flatCoordinates;
        }
        return Object(inflate["b" /* inflateCoordinatesArray */])(flatCoordinates, 0, this.ends_, this.stride);
    };
    /**
     * @return {Array<number>} Ends.
     */
    Polygon.prototype.getEnds = function () {
        return this.ends_;
    };
    /**
     * @return {Array<number>} Interior point.
     */
    Polygon.prototype.getFlatInteriorPoint = function () {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
            var flatCenter = Object(ol_extent["w" /* getCenter */])(this.getExtent());
            this.flatInteriorPoint_ = Object(interiorpoint["a" /* getInteriorPointOfArray */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
            this.flatInteriorPointRevision_ = this.getRevision();
        }
        return this.flatInteriorPoint_;
    };
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */
    Polygon.prototype.getInteriorPoint = function () {
        return new Point["a" /* default */](this.getFlatInteriorPoint(), GeometryLayout["a" /* default */].XYM);
    };
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */
    Polygon.prototype.getLinearRingCount = function () {
        return this.ends_.length;
    };
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */
    Polygon.prototype.getLinearRing = function (index) {
        if (index < 0 || this.ends_.length <= index) {
            return null;
        }
        return new geom_LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    };
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */
    Polygon.prototype.getLinearRings = function () {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var linearRings = [];
        var offset = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var linearRing = new geom_LinearRing(flatCoordinates.slice(offset, end), layout);
            linearRings.push(linearRing);
            offset = end;
        }
        return linearRings;
    };
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    Polygon.prototype.getOrientedFlatCoordinates = function () {
        if (this.orientedRevision_ != this.getRevision()) {
            var flatCoordinates = this.flatCoordinates;
            if (Object(orient["a" /* linearRingsAreOriented */])(flatCoordinates, 0, this.ends_, this.stride)) {
                this.orientedFlatCoordinates_ = flatCoordinates;
            }
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = Object(orient["c" /* orientLinearRings */])(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     */
    Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = Object(simplify["c" /* quantizeArray */])(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new Polygon(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY, simplifiedEnds);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    Polygon.prototype.getType = function () {
        return GeometryType["a" /* default */].POLYGON;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    Polygon.prototype.intersectsExtent = function (extent) {
        return Object(intersectsextent["c" /* intersectsLinearRingArray */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    };
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */
    Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 2);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        var ends = Object(deflate["c" /* deflateCoordinatesArray */])(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    };
    return Polygon;
}(SimpleGeometry["a" /* default */]));
/* harmony default export */ var geom_Polygon = __webpack_exports__["a"] = (Polygon_Polygon);
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [opt_n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, opt_n, opt_sphereRadius) {
    var n = opt_n ? opt_n : 32;
    /** @type {Array<number>} */
    var flatCoordinates = [];
    for (var i = 0; i < n; ++i) {
        Object(array["c" /* extend */])(flatCoordinates, Object(sphere["b" /* offset */])(center, radius, (2 * Math.PI * i) / n, opt_sphereRadius));
    }
    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
    return new Polygon_Polygon(flatCoordinates, GeometryLayout["a" /* default */].XY, [
        flatCoordinates.length,
    ]);
}
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var flatCoordinates = [
        minX,
        minY,
        minX,
        maxY,
        maxX,
        maxY,
        maxX,
        minY,
        minX,
        minY,
    ];
    return new Polygon_Polygon(flatCoordinates, GeometryLayout["a" /* default */].XY, [
        flatCoordinates.length,
    ]);
}
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.
 * @param {number} [opt_angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, opt_sides, opt_angle) {
    var sides = opt_sides ? opt_sides : 32;
    var stride = circle.getStride();
    var layout = circle.getLayout();
    var center = circle.getCenter();
    var arrayLength = stride * (sides + 1);
    var flatCoordinates = new Array(arrayLength);
    for (var i = 0; i < arrayLength; i += stride) {
        flatCoordinates[i] = 0;
        flatCoordinates[i + 1] = 0;
        for (var j = 2; j < stride; j++) {
            flatCoordinates[i + j] = center[j];
        }
    }
    var ends = [flatCoordinates.length];
    var polygon = new Polygon_Polygon(flatCoordinates, layout, ends);
    makeRegular(polygon, center, circle.getRadius(), opt_angle);
    return polygon;
}
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [opt_angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */
function makeRegular(polygon, center, radius, opt_angle) {
    var flatCoordinates = polygon.getFlatCoordinates();
    var stride = polygon.getStride();
    var sides = flatCoordinates.length / stride - 1;
    var startAngle = opt_angle ? opt_angle : 0;
    for (var i = 0; i <= sides; ++i) {
        var offset = i * stride;
        var angle = startAngle + (Object(math["g" /* modulo */])(i, sides) * 2 * Math.PI) / sides;
        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
    }
    polygon.changed();
}
//# sourceMappingURL=Polygon.js.map

/***/ }),

/***/ "5c38":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return asString; });
/* unused harmony export fromString */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return asArray; });
/* unused harmony export normalize */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return toString; });
/* unused harmony export isStringColor */
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("92fa");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7fc9");
/**
 * @module ol/color
 */


/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */
/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
    if (typeof color === 'string') {
        return color;
    }
    else {
        return toString(color);
    }
}
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
function fromNamed(color) {
    var el = document.createElement('div');
    el.style.color = color;
    if (el.style.color !== '') {
        document.body.appendChild(el);
        var rgb = getComputedStyle(el).color;
        document.body.removeChild(el);
        return rgb;
    }
    else {
        return '';
    }
}
/**
 * @param {string} s String.
 * @return {Color} Color.
 */
var fromString = (function () {
    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.
    /**
     * @const
     * @type {number}
     */
    var MAX_CACHE_SIZE = 1024;
    /**
     * @type {Object<string, Color>}
     */
    var cache = {};
    /**
     * @type {number}
     */
    var cacheSize = 0;
    return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function (s) {
        var color;
        if (cache.hasOwnProperty(s)) {
            color = cache[s];
        }
        else {
            if (cacheSize >= MAX_CACHE_SIZE) {
                var i = 0;
                for (var key in cache) {
                    if ((i++ & 3) === 0) {
                        delete cache[key];
                        --cacheSize;
                    }
                }
            }
            color = fromStringInternal_(s);
            cache[s] = color;
            ++cacheSize;
        }
        return color;
    });
})();
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
function asArray(color) {
    if (Array.isArray(color)) {
        return color;
    }
    else {
        return fromString(color);
    }
}
/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */
function fromStringInternal_(s) {
    var r, g, b, a, color;
    if (NAMED_COLOR_RE_.exec(s)) {
        s = fromNamed(s);
    }
    if (HEX_COLOR_RE_.exec(s)) {
        // hex
        var n = s.length - 1; // number of hex digits
        var d = // number of digits per channel
         void 0; // number of digits per channel
        if (n <= 4) {
            d = 1;
        }
        else {
            d = 2;
        }
        var hasAlpha = n === 4 || n === 8;
        r = parseInt(s.substr(1 + 0 * d, d), 16);
        g = parseInt(s.substr(1 + 1 * d, d), 16);
        b = parseInt(s.substr(1 + 2 * d, d), 16);
        if (hasAlpha) {
            a = parseInt(s.substr(1 + 3 * d, d), 16);
        }
        else {
            a = 255;
        }
        if (d == 1) {
            r = (r << 4) + r;
            g = (g << 4) + g;
            b = (b << 4) + b;
            if (hasAlpha) {
                a = (a << 4) + a;
            }
        }
        color = [r, g, b, a / 255];
    }
    else if (s.indexOf('rgba(') == 0) {
        // rgba()
        color = s.slice(5, -1).split(',').map(Number);
        normalize(color);
    }
    else if (s.indexOf('rgb(') == 0) {
        // rgb()
        color = s.slice(4, -1).split(',').map(Number);
        color.push(1);
        normalize(color);
    }
    else {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(false, 14); // Invalid color
    }
    return color;
}
/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
function normalize(color) {
    color[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ "b"])((color[0] + 0.5) | 0, 0, 255);
    color[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ "b"])((color[1] + 0.5) | 0, 0, 255);
    color[2] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ "b"])((color[2] + 0.5) | 0, 0, 255);
    color[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ "b"])(color[3], 0, 1);
    return color;
}
/**
 * @param {Color} color Color.
 * @return {string} String.
 */
function toString(color) {
    var r = color[0];
    if (r != (r | 0)) {
        r = (r + 0.5) | 0;
    }
    var g = color[1];
    if (g != (g | 0)) {
        g = (g + 0.5) | 0;
    }
    var b = color[2];
    if (b != (b | 0)) {
        b = (b + 0.5) | 0;
    }
    var a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */
function isStringColor(s) {
    if (NAMED_COLOR_RE_.test(s)) {
        s = fromNamed(s);
    }
    return (HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0);
}
//# sourceMappingURL=color.js.map

/***/ }),

/***/ "5c6c":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "5c85":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track10.58e638fc.png";

/***/ }),

/***/ "5e31":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0ec0");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("acc1");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1300");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("ca42");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Tile
 */





/**
 * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */
/**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */
/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */
/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
var Tile = /** @class */ (function (_super) {
    __extends(Tile, _super);
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {Options} [opt_options] Tile options.
     */
    function Tile(tileCoord, state, opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options ? opt_options : {};
        /**
         * @type {import("./tilecoord.js").TileCoord}
         */
        _this.tileCoord = tileCoord;
        /**
         * @protected
         * @type {import("./TileState.js").default}
         */
        _this.state = state;
        /**
         * An "interim" tile for this tile. The interim tile may be used while this
         * one is loading, for "smooth" transitions when changing params/dimensions
         * on the source.
         * @type {Tile}
         */
        _this.interimTile = null;
        /**
         * A key assigned to the tile. This is used by the tile source to determine
         * if this tile can effectively be used, or if a new tile should be created
         * and this one be used as an interim tile for this new tile.
         * @type {string}
         */
        _this.key = '';
        /**
         * The duration for the opacity transition.
         * @type {number}
         */
        _this.transition_ =
            options.transition === undefined ? 250 : options.transition;
        /**
         * Lookup of start times for rendering transitions.  If the start time is
         * equal to -1, the transition is complete.
         * @type {Object<string, number>}
         */
        _this.transitionStarts_ = {};
        /**
         * @type {boolean}
         */
        _this.interpolate = !!options.interpolate;
        return _this;
    }
    /**
     * @protected
     */
    Tile.prototype.changed = function () {
        this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE);
    };
    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */
    Tile.prototype.release = function () { };
    /**
     * @return {string} Key.
     */
    Tile.prototype.getKey = function () {
        return this.key + '/' + this.tileCoord;
    };
    /**
     * Get the interim tile most suitable for rendering using the chain of interim
     * tiles. This corresponds to the  most recent tile that has been loaded, if no
     * such tile exists, the original tile is returned.
     * @return {!Tile} Best tile for rendering.
     */
    Tile.prototype.getInterimTile = function () {
        if (!this.interimTile) {
            //empty chain
            return this;
        }
        var tile = this.interimTile;
        // find the first loaded tile and return it. Since the chain is sorted in
        // decreasing order of creation time, there is no need to search the remainder
        // of the list (all those tiles correspond to older requests and will be
        // cleaned up by refreshInterimChain)
        do {
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOADED) {
                // Show tile immediately instead of fading it in after loading, because
                // the interim tile is in place already
                this.transition_ = 0;
                return tile;
            }
            tile = tile.interimTile;
        } while (tile);
        // we can not find a better tile
        return this;
    };
    /**
     * Goes through the chain of interim tiles and discards sections of the chain
     * that are no longer relevant.
     */
    Tile.prototype.refreshInterimChain = function () {
        if (!this.interimTile) {
            return;
        }
        var tile = this.interimTile;
        /**
         * @type {Tile}
         */
        var prev = this;
        do {
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOADED) {
                //we have a loaded tile, we can discard the rest of the list
                //we would could abort any LOADING tile request
                //older than this tile (i.e. any LOADING tile following this entry in the chain)
                tile.interimTile = null;
                break;
            }
            else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOADING) {
                //keep this LOADING tile any loaded tiles later in the chain are
                //older than this tile, so we're still interested in the request
                prev = tile;
            }
            else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].IDLE) {
                //the head of the list is the most current tile, we don't need
                //to start any other requests for this chain
                prev.interimTile = tile.interimTile;
            }
            else {
                prev = tile;
            }
            tile = prev.interimTile;
        } while (tile);
    };
    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */
    Tile.prototype.getTileCoord = function () {
        return this.tileCoord;
    };
    /**
     * @return {import("./TileState.js").default} State.
     */
    Tile.prototype.getState = function () {
        return this.state;
    };
    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */
    Tile.prototype.setState = function (state) {
        if (this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ERROR && this.state > state) {
            throw new Error('Tile load sequence violation');
        }
        this.state = state;
        this.changed();
    };
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */
    Tile.prototype.load = function () {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_3__[/* abstract */ "b"])();
    };
    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */
    Tile.prototype.getAlpha = function (id, time) {
        if (!this.transition_) {
            return 1;
        }
        var start = this.transitionStarts_[id];
        if (!start) {
            start = time;
            this.transitionStarts_[id] = start;
        }
        else if (start === -1) {
            return 1;
        }
        var delta = time - start + 1000 / 60; // avoid rendering at 0
        if (delta >= this.transition_) {
            return 1;
        }
        return Object(_easing_js__WEBPACK_IMPORTED_MODULE_4__[/* easeIn */ "a"])(delta / this.transition_);
    };
    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */
    Tile.prototype.inTransition = function (id) {
        if (!this.transition_) {
            return false;
        }
        return this.transitionStarts_[id] !== -1;
    };
    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */
    Tile.prototype.endTransition = function (id) {
        if (this.transition_) {
            this.transitionStarts_[id] = -1;
        }
    };
    return Tile;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (Tile);
//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "5e48":
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.5' };
	if (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document) && _isObject(document.createElement);
	var _domCreate = function (it) {
	  return is ? document.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) { return it; }
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) { try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ } }
	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }
	  if ('value' in Attributes) { O[P] = Attributes.value; }
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: _library ? 'pure' : 'global',
	  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _functionToString = _shared('native-function-to-string', Function.toString);

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');

	var TO_STRING = 'toString';
	var TPL = ('' + _functionToString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return _functionToString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }
	  if (O[key] === val) { return; }
	  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) { return fn; }
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) { source = name; }
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) { _redefine(target, key, out, type & $export.U); }
	    // export
	    if (exports[key] != out) { _hide(exports, key, exp); }
	    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) { throw TypeError("Can't call method on  " + it); }
	  return it;
	};

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var $at = _stringAt(false);
	_export(_export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});

	var codePointAt = _core.String.codePointAt;

	var max = Math.max;
	var min = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments$1[i++];
	      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

	var fromCodePoint = _core.String.fromCodePoint;

	// This is a generated file. Do not edit.
	var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
	var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
	var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

	var unicode = {
		Space_Separator: Space_Separator,
		ID_Start: ID_Start,
		ID_Continue: ID_Continue
	};

	var util = {
	    isSpaceSeparator: function isSpaceSeparator (c) {
	        return typeof c === 'string' && unicode.Space_Separator.test(c)
	    },

	    isIdStartChar: function isIdStartChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c === '$') || (c === '_') ||
	        unicode.ID_Start.test(c)
	        )
	    },

	    isIdContinueChar: function isIdContinueChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c >= '0' && c <= '9') ||
	        (c === '$') || (c === '_') ||
	        (c === '\u200C') || (c === '\u200D') ||
	        unicode.ID_Continue.test(c)
	        )
	    },

	    isDigit: function isDigit (c) {
	        return typeof c === 'string' && /[0-9]/.test(c)
	    },

	    isHexDigit: function isHexDigit (c) {
	        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
	    },
	};

	var source;
	var parseState;
	var stack;
	var pos;
	var line;
	var column;
	var token;
	var key;
	var root;

	var parse = function parse (text, reviver) {
	    source = String(text);
	    parseState = 'start';
	    stack = [];
	    pos = 0;
	    line = 1;
	    column = 0;
	    token = undefined;
	    key = undefined;
	    root = undefined;

	    do {
	        token = lex();

	        // This code is unreachable.
	        // if (!parseStates[parseState]) {
	        //     throw invalidParseState()
	        // }

	        parseStates[parseState]();
	    } while (token.type !== 'eof')

	    if (typeof reviver === 'function') {
	        return internalize({'': root}, '', reviver)
	    }

	    return root
	};

	function internalize (holder, name, reviver) {
	    var value = holder[name];
	    if (value != null && typeof value === 'object') {
	        for (var key in value) {
	            var replacement = internalize(value, key, reviver);
	            if (replacement === undefined) {
	                delete value[key];
	            } else {
	                value[key] = replacement;
	            }
	        }
	    }

	    return reviver.call(holder, name, value)
	}

	var lexState;
	var buffer;
	var doubleQuote;
	var sign;
	var c;

	function lex () {
	    lexState = 'default';
	    buffer = '';
	    doubleQuote = false;
	    sign = 1;

	    for (;;) {
	        c = peek();

	        // This code is unreachable.
	        // if (!lexStates[lexState]) {
	        //     throw invalidLexState(lexState)
	        // }

	        var token = lexStates[lexState]();
	        if (token) {
	            return token
	        }
	    }
	}

	function peek () {
	    if (source[pos]) {
	        return String.fromCodePoint(source.codePointAt(pos))
	    }
	}

	function read () {
	    var c = peek();

	    if (c === '\n') {
	        line++;
	        column = 0;
	    } else if (c) {
	        column += c.length;
	    } else {
	        column++;
	    }

	    if (c) {
	        pos += c.length;
	    }

	    return c
	}

	var lexStates = {
	    default: function default$1 () {
	        switch (c) {
	        case '\t':
	        case '\v':
	        case '\f':
	        case ' ':
	        case '\u00A0':
	        case '\uFEFF':
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'comment';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        if (util.isSpaceSeparator(c)) {
	            read();
	            return
	        }

	        // This code is unreachable.
	        // if (!lexStates[parseState]) {
	        //     throw invalidLexState(parseState)
	        // }

	        return lexStates[parseState]()
	    },

	    comment: function comment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineComment';
	            return

	        case '/':
	            read();
	            lexState = 'singleLineComment';
	            return
	        }

	        throw invalidChar(read())
	    },

	    multiLineComment: function multiLineComment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineCommentAsterisk';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	    },

	    multiLineCommentAsterisk: function multiLineCommentAsterisk () {
	        switch (c) {
	        case '*':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	        lexState = 'multiLineComment';
	    },

	    singleLineComment: function singleLineComment () {
	        switch (c) {
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        read();
	    },

	    value: function value () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        case 'n':
	            read();
	            literal('ull');
	            return newToken('null', null)

	        case 't':
	            read();
	            literal('rue');
	            return newToken('boolean', true)

	        case 'f':
	            read();
	            literal('alse');
	            return newToken('boolean', false)

	        case '-':
	        case '+':
	            if (read() === '-') {
	                sign = -1;
	            }

	            lexState = 'sign';
	            return

	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            buffer = '';
	            lexState = 'string';
	            return
	        }

	        throw invalidChar(read())
	    },

	    identifierNameStartEscape: function identifierNameStartEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	            break

	        default:
	            if (!util.isIdStartChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    identifierName: function identifierName () {
	        switch (c) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            buffer += read();
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameEscape';
	            return
	        }

	        if (util.isIdContinueChar(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('identifier', buffer)
	    },

	    identifierNameEscape: function identifierNameEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            break

	        default:
	            if (!util.isIdContinueChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    sign: function sign$1 () {
	        switch (c) {
	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', sign * Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)
	        }

	        throw invalidChar(read())
	    },

	    zero: function zero () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return

	        case 'x':
	        case 'X':
	            buffer += read();
	            lexState = 'hexadecimal';
	            return
	        }

	        return newToken('numeric', sign * 0)
	    },

	    decimalInteger: function decimalInteger () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalPointLeading: function decimalPointLeading () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalPoint: function decimalPoint () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalFraction: function decimalFraction () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalExponent: function decimalExponent () {
	        switch (c) {
	        case '+':
	        case '-':
	            buffer += read();
	            lexState = 'decimalExponentSign';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentSign: function decimalExponentSign () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentInteger: function decimalExponentInteger () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    hexadecimal: function hexadecimal () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            lexState = 'hexadecimalInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    hexadecimalInteger: function hexadecimalInteger () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    string: function string () {
	        switch (c) {
	        case '\\':
	            read();
	            buffer += escape();
	            return

	        case '"':
	            if (doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case "'":
	            if (!doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case '\n':
	        case '\r':
	            throw invalidChar(read())

	        case '\u2028':
	        case '\u2029':
	            separatorChar(c);
	            break

	        case undefined:
	            throw invalidChar(read())
	        }

	        buffer += read();
	    },

	    start: function start () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        // This code is unreachable since the default lexState handles eof.
	        // case undefined:
	        //     return newToken('eof')
	        }

	        lexState = 'value';
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (c) {
	        case '$':
	        case '_':
	            buffer = read();
	            lexState = 'identifierName';
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameStartEscape';
	            return

	        case '}':
	            return newToken('punctuator', read())

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            lexState = 'string';
	            return
	        }

	        if (util.isIdStartChar(c)) {
	            buffer += read();
	            lexState = 'identifierName';
	            return
	        }

	        throw invalidChar(read())
	    },

	    afterPropertyName: function afterPropertyName () {
	        if (c === ':') {
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        lexState = 'value';
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        switch (c) {
	        case ',':
	        case '}':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (c === ']') {
	            return newToken('punctuator', read())
	        }

	        lexState = 'value';
	    },

	    afterArrayValue: function afterArrayValue () {
	        switch (c) {
	        case ',':
	        case ']':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the default lexState.
	        // if (c === undefined) {
	        //     read()
	        //     return newToken('eof')
	        // }

	        throw invalidChar(read())
	    },
	};

	function newToken (type, value) {
	    return {
	        type: type,
	        value: value,
	        line: line,
	        column: column,
	    }
	}

	function literal (s) {
	    for (var i = 0, list = s; i < list.length; i += 1) {
	        var c = list[i];

	        var p = peek();

	        if (p !== c) {
	            throw invalidChar(read())
	        }

	        read();
	    }
	}

	function escape () {
	    var c = peek();
	    switch (c) {
	    case 'b':
	        read();
	        return '\b'

	    case 'f':
	        read();
	        return '\f'

	    case 'n':
	        read();
	        return '\n'

	    case 'r':
	        read();
	        return '\r'

	    case 't':
	        read();
	        return '\t'

	    case 'v':
	        read();
	        return '\v'

	    case '0':
	        read();
	        if (util.isDigit(peek())) {
	            throw invalidChar(read())
	        }

	        return '\0'

	    case 'x':
	        read();
	        return hexEscape()

	    case 'u':
	        read();
	        return unicodeEscape()

	    case '\n':
	    case '\u2028':
	    case '\u2029':
	        read();
	        return ''

	    case '\r':
	        read();
	        if (peek() === '\n') {
	            read();
	        }

	        return ''

	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	        throw invalidChar(read())

	    case undefined:
	        throw invalidChar(read())
	    }

	    return read()
	}

	function hexEscape () {
	    var buffer = '';
	    var c = peek();

	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    c = peek();
	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	function unicodeEscape () {
	    var buffer = '';
	    var count = 4;

	    while (count-- > 0) {
	        var c = peek();
	        if (!util.isHexDigit(c)) {
	            throw invalidChar(read())
	        }

	        buffer += read();
	    }

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	var parseStates = {
	    start: function start () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (token.type) {
	        case 'identifier':
	        case 'string':
	            key = token.value;
	            parseState = 'afterPropertyName';
	            return

	        case 'punctuator':
	            // This code is unreachable since it's handled by the lexState.
	            // if (token.value !== '}') {
	            //     throw invalidToken()
	            // }

	            pop();
	            return

	        case 'eof':
	            throw invalidEOF()
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterPropertyName: function afterPropertyName () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator' || token.value !== ':') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        parseState = 'beforePropertyValue';
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        if (token.type === 'punctuator' && token.value === ']') {
	            pop();
	            return
	        }

	        push();
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforePropertyName';
	            return

	        case '}':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterArrayValue: function afterArrayValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforeArrayValue';
	            return

	        case ']':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'eof') {
	        //     throw invalidToken()
	        // }
	    },
	};

	function push () {
	    var value;

	    switch (token.type) {
	    case 'punctuator':
	        switch (token.value) {
	        case '{':
	            value = {};
	            break

	        case '[':
	            value = [];
	            break
	        }

	        break

	    case 'null':
	    case 'boolean':
	    case 'numeric':
	    case 'string':
	        value = token.value;
	        break

	    // This code is unreachable.
	    // default:
	    //     throw invalidToken()
	    }

	    if (root === undefined) {
	        root = value;
	    } else {
	        var parent = stack[stack.length - 1];
	        if (Array.isArray(parent)) {
	            parent.push(value);
	        } else {
	            parent[key] = value;
	        }
	    }

	    if (value !== null && typeof value === 'object') {
	        stack.push(value);

	        if (Array.isArray(value)) {
	            parseState = 'beforeArrayValue';
	        } else {
	            parseState = 'beforePropertyName';
	        }
	    } else {
	        var current = stack[stack.length - 1];
	        if (current == null) {
	            parseState = 'end';
	        } else if (Array.isArray(current)) {
	            parseState = 'afterArrayValue';
	        } else {
	            parseState = 'afterPropertyValue';
	        }
	    }
	}

	function pop () {
	    stack.pop();

	    var current = stack[stack.length - 1];
	    if (current == null) {
	        parseState = 'end';
	    } else if (Array.isArray(current)) {
	        parseState = 'afterArrayValue';
	    } else {
	        parseState = 'afterPropertyValue';
	    }
	}

	// This code is unreachable.
	// function invalidParseState () {
	//     return new Error(`JSON5: invalid parse state '${parseState}'`)
	// }

	// This code is unreachable.
	// function invalidLexState (state) {
	//     return new Error(`JSON5: invalid lex state '${state}'`)
	// }

	function invalidChar (c) {
	    if (c === undefined) {
	        return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	    }

	    return syntaxError(("JSON5: invalid character '" + (formatChar(c)) + "' at " + line + ":" + column))
	}

	function invalidEOF () {
	    return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	}

	// This code is unreachable.
	// function invalidToken () {
	//     if (token.type === 'eof') {
	//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
	//     }

	//     const c = String.fromCodePoint(token.value.codePointAt(0))
	//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
	// }

	function invalidIdentifier () {
	    column -= 5;
	    return syntaxError(("JSON5: invalid identifier character at " + line + ":" + column))
	}

	function separatorChar (c) {
	    console.warn(("JSON5: '" + (formatChar(c)) + "' in strings is not valid ECMAScript; consider escaping"));
	}

	function formatChar (c) {
	    var replacements = {
	        "'": "\\'",
	        '"': '\\"',
	        '\\': '\\\\',
	        '\b': '\\b',
	        '\f': '\\f',
	        '\n': '\\n',
	        '\r': '\\r',
	        '\t': '\\t',
	        '\v': '\\v',
	        '\0': '\\0',
	        '\u2028': '\\u2028',
	        '\u2029': '\\u2029',
	    };

	    if (replacements[c]) {
	        return replacements[c]
	    }

	    if (c < ' ') {
	        var hexString = c.charCodeAt(0).toString(16);
	        return '\\x' + ('00' + hexString).substring(hexString.length)
	    }

	    return c
	}

	function syntaxError (message) {
	    var err = new SyntaxError(message);
	    err.lineNumber = line;
	    err.columnNumber = column;
	    return err
	}

	var stringify = function stringify (value, replacer, space) {
	    var stack = [];
	    var indent = '';
	    var propertyList;
	    var replacerFunc;
	    var gap = '';
	    var quote;

	    if (
	        replacer != null &&
	        typeof replacer === 'object' &&
	        !Array.isArray(replacer)
	    ) {
	        space = replacer.space;
	        quote = replacer.quote;
	        replacer = replacer.replacer;
	    }

	    if (typeof replacer === 'function') {
	        replacerFunc = replacer;
	    } else if (Array.isArray(replacer)) {
	        propertyList = [];
	        for (var i = 0, list = replacer; i < list.length; i += 1) {
	            var v = list[i];

	            var item = (void 0);

	            if (typeof v === 'string') {
	                item = v;
	            } else if (
	                typeof v === 'number' ||
	                v instanceof String ||
	                v instanceof Number
	            ) {
	                item = String(v);
	            }

	            if (item !== undefined && propertyList.indexOf(item) < 0) {
	                propertyList.push(item);
	            }
	        }
	    }

	    if (space instanceof Number) {
	        space = Number(space);
	    } else if (space instanceof String) {
	        space = String(space);
	    }

	    if (typeof space === 'number') {
	        if (space > 0) {
	            space = Math.min(10, Math.floor(space));
	            gap = '          '.substr(0, space);
	        }
	    } else if (typeof space === 'string') {
	        gap = space.substr(0, 10);
	    }

	    return serializeProperty('', {'': value})

	    function serializeProperty (key, holder) {
	        var value = holder[key];
	        if (value != null) {
	            if (typeof value.toJSON5 === 'function') {
	                value = value.toJSON5(key);
	            } else if (typeof value.toJSON === 'function') {
	                value = value.toJSON(key);
	            }
	        }

	        if (replacerFunc) {
	            value = replacerFunc.call(holder, key, value);
	        }

	        if (value instanceof Number) {
	            value = Number(value);
	        } else if (value instanceof String) {
	            value = String(value);
	        } else if (value instanceof Boolean) {
	            value = value.valueOf();
	        }

	        switch (value) {
	        case null: return 'null'
	        case true: return 'true'
	        case false: return 'false'
	        }

	        if (typeof value === 'string') {
	            return quoteString(value, false)
	        }

	        if (typeof value === 'number') {
	            return String(value)
	        }

	        if (typeof value === 'object') {
	            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)
	        }

	        return undefined
	    }

	    function quoteString (value) {
	        var quotes = {
	            "'": 0.1,
	            '"': 0.2,
	        };

	        var replacements = {
	            "'": "\\'",
	            '"': '\\"',
	            '\\': '\\\\',
	            '\b': '\\b',
	            '\f': '\\f',
	            '\n': '\\n',
	            '\r': '\\r',
	            '\t': '\\t',
	            '\v': '\\v',
	            '\0': '\\0',
	            '\u2028': '\\u2028',
	            '\u2029': '\\u2029',
	        };

	        var product = '';

	        for (var i = 0; i < value.length; i++) {
	            var c = value[i];
	            switch (c) {
	            case "'":
	            case '"':
	                quotes[c]++;
	                product += c;
	                continue

	            case '\0':
	                if (util.isDigit(value[i + 1])) {
	                    product += '\\x00';
	                    continue
	                }
	            }

	            if (replacements[c]) {
	                product += replacements[c];
	                continue
	            }

	            if (c < ' ') {
	                var hexString = c.charCodeAt(0).toString(16);
	                product += '\\x' + ('00' + hexString).substring(hexString.length);
	                continue
	            }

	            product += c;
	        }

	        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });

	        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);

	        return quoteChar + product + quoteChar
	    }

	    function serializeObject (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var keys = propertyList || Object.keys(value);
	        var partial = [];
	        for (var i = 0, list = keys; i < list.length; i += 1) {
	            var key = list[i];

	            var propertyString = serializeProperty(key, value);
	            if (propertyString !== undefined) {
	                var member = serializeKey(key) + ':';
	                if (gap !== '') {
	                    member += ' ';
	                }
	                member += propertyString;
	                partial.push(member);
	            }
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '{}';
	        } else {
	            var properties;
	            if (gap === '') {
	                properties = partial.join(',');
	                final = '{' + properties + '}';
	            } else {
	                var separator = ',\n' + indent;
	                properties = partial.join(separator);
	                final = '{\n' + indent + properties + ',\n' + stepback + '}';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }

	    function serializeKey (key) {
	        if (key.length === 0) {
	            return quoteString(key, true)
	        }

	        var firstChar = String.fromCodePoint(key.codePointAt(0));
	        if (!util.isIdStartChar(firstChar)) {
	            return quoteString(key, true)
	        }

	        for (var i = firstChar.length; i < key.length; i++) {
	            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
	                return quoteString(key, true)
	            }
	        }

	        return key
	    }

	    function serializeArray (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var partial = [];
	        for (var i = 0; i < value.length; i++) {
	            var propertyString = serializeProperty(String(i), value);
	            partial.push((propertyString !== undefined) ? propertyString : 'null');
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '[]';
	        } else {
	            if (gap === '') {
	                var properties = partial.join(',');
	                final = '[' + properties + ']';
	            } else {
	                var separator = ',\n' + indent;
	                var properties$1 = partial.join(separator);
	                final = '[\n' + indent + properties$1 + ',\n' + stepback + ']';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }
	};

	var JSON5 = {
	    parse: parse,
	    stringify: stringify,
	};

	var lib = JSON5;

	var es5 = lib;

	return es5;

})));


/***/ }),

/***/ "5e77":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var hasOwn = __webpack_require__("1a2d");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "5eee":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/Disposable.js
var Disposable = __webpack_require__("da5c");

// EXTERNAL MODULE: ./node_modules/ol/functions.js
var functions = __webpack_require__("57cb");

// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// EXTERNAL MODULE: ./node_modules/ol/transform.js
var transform = __webpack_require__("a896");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/style/IconImageCache.js
var IconImageCache = __webpack_require__("3c22");

// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js
var Layer = __webpack_require__("1af9");

// EXTERNAL MODULE: ./node_modules/ol/coordinate.js
var ol_coordinate = __webpack_require__("a568");

// CONCATENATED MODULE: ./node_modules/ol/renderer/Map.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/renderer/Map
 */








/**
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 * @template T
 */
/**
 * @abstract
 */
var Map_MapRenderer = /** @class */ (function (_super) {
    __extends(MapRenderer, _super);
    /**
     * @param {import("../PluggableMap.js").default} map Map.
     */
    function MapRenderer(map) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {import("../PluggableMap.js").default}
         */
        _this.map_ = map;
        return _this;
    }
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     */
    MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
        Object(util["b" /* abstract */])();
    };
    /**
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @protected
     */
    MapRenderer.prototype.calculateMatrices2D = function (frameState) {
        var viewState = frameState.viewState;
        var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
        var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
        Object(transform["b" /* compose */])(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
        Object(transform["d" /* makeInverse */])(pixelToCoordinateTransform, coordinateToPixelTransform);
    };
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */
    MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
        var result;
        var viewState = frameState.viewState;
        /**
         * @param {boolean} managed Managed layer.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @param {import("../geom/Geometry.js").default} geometry Geometry.
         * @return {T|undefined} Callback result.
         */
        function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
            return callback.call(thisArg, feature, managed ? layer : null, geometry);
        }
        var projection = viewState.projection;
        var translatedCoordinate = Object(ol_coordinate["j" /* wrapX */])(coordinate.slice(), projection);
        var offsets = [[0, 0]];
        if (projection.canWrapX() && checkWrapped) {
            var projectionExtent = projection.getExtent();
            var worldWidth = Object(extent["D" /* getWidth */])(projectionExtent);
            offsets.push([-worldWidth, 0], [worldWidth, 0]);
        }
        var layerStates = frameState.layerStatesArray;
        var numLayers = layerStates.length;
        var matches = /** @type {Array<HitMatch<T>>} */ ([]);
        var tmpCoord = [];
        for (var i = 0; i < offsets.length; i++) {
            for (var j = numLayers - 1; j >= 0; --j) {
                var layerState = layerStates[j];
                var layer = layerState.layer;
                if (layer.hasRenderer() &&
                    Object(Layer["b" /* inView */])(layerState, viewState) &&
                    layerFilter.call(thisArg2, layer)) {
                    var layerRenderer = layer.getRenderer();
                    var source = layer.getSource();
                    if (layerRenderer && source) {
                        var coordinates = source.getWrapX()
                            ? translatedCoordinate
                            : coordinate;
                        var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                        tmpCoord[0] = coordinates[0] + offsets[i][0];
                        tmpCoord[1] = coordinates[1] + offsets[i][1];
                        result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
                    }
                    if (result) {
                        return result;
                    }
                }
            }
        }
        if (matches.length === 0) {
            return undefined;
        }
        var order = 1 / matches.length;
        matches.forEach(function (m, i) { return (m.distanceSq += i * order); });
        matches.sort(function (a, b) { return a.distanceSq - b.distanceSq; });
        matches.some(function (m) {
            return (result = m.callback(m.feature, m.layer, m.geometry));
        });
        return result;
    };
    /**
     * @abstract
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer
     *     callback.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @return {T|undefined} Callback result.
     * @template T
     */
    MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */
    MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, functions["b" /* TRUE */], this, layerFilter, thisArg);
        return hasFeature !== undefined;
    };
    /**
     * @return {import("../PluggableMap.js").default} Map.
     */
    MapRenderer.prototype.getMap = function () {
        return this.map_;
    };
    /**
     * Render.
     * @abstract
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     */
    MapRenderer.prototype.renderFrame = function (frameState) {
        Object(util["b" /* abstract */])();
    };
    /**
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */
    MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
        if (IconImageCache["a" /* shared */].canExpireCache()) {
            frameState.postRenderFunctions.push(expireIconCache);
        }
    };
    return MapRenderer;
}(Disposable["a" /* default */]));
/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
    IconImageCache["a" /* shared */].expire();
}
/* harmony default export */ var renderer_Map = (Map_MapRenderer);
//# sourceMappingURL=Map.js.map
// EXTERNAL MODULE: ./node_modules/ol/ObjectEventType.js
var ObjectEventType = __webpack_require__("7b4f");

// EXTERNAL MODULE: ./node_modules/ol/render/Event.js
var Event = __webpack_require__("3333");

// EXTERNAL MODULE: ./node_modules/ol/render/EventType.js
var EventType = __webpack_require__("070d");

// EXTERNAL MODULE: ./node_modules/ol/source/State.js
var State = __webpack_require__("6d83");

// EXTERNAL MODULE: ./node_modules/ol/css.js
var css = __webpack_require__("cd7e");

// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js
var canvas = __webpack_require__("ddea");

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__("1e8d");

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__("0999");

// CONCATENATED MODULE: ./node_modules/ol/renderer/Composite.js
var Composite_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/renderer/Composite
 */










/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var Composite_CompositeMapRenderer = /** @class */ (function (_super) {
    Composite_extends(CompositeMapRenderer, _super);
    /**
     * @param {import("../PluggableMap.js").default} map Map.
     */
    function CompositeMapRenderer(map) {
        var _this = _super.call(this, map) || this;
        /**
         * @type {import("../events.js").EventsKey}
         */
        _this.fontChangeListenerKey_ = Object(events["a" /* listen */])(canvas["a" /* checkedFonts */], ObjectEventType["a" /* default */].PROPERTYCHANGE, map.redrawText.bind(map));
        /**
         * @private
         * @type {HTMLDivElement}
         */
        _this.element_ = document.createElement('div');
        var style = _this.element_.style;
        style.position = 'absolute';
        style.width = '100%';
        style.height = '100%';
        style.zIndex = '0';
        _this.element_.className = css["e" /* CLASS_UNSELECTABLE */] + ' ol-layers';
        var container = map.getViewport();
        container.insertBefore(_this.element_, container.firstChild || null);
        /**
         * @private
         * @type {Array<HTMLElement>}
         */
        _this.children_ = [];
        /**
         * @private
         * @type {boolean}
         */
        _this.renderedVisible_ = true;
        return _this;
    }
    /**
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     */
    CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
        var map = this.getMap();
        if (map.hasListener(type)) {
            var event_1 = new Event["a" /* default */](type, undefined, frameState);
            map.dispatchEvent(event_1);
        }
    };
    CompositeMapRenderer.prototype.disposeInternal = function () {
        Object(events["c" /* unlistenByKey */])(this.fontChangeListenerKey_);
        this.element_.parentNode.removeChild(this.element_);
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * Render.
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     */
    CompositeMapRenderer.prototype.renderFrame = function (frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element_.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        this.calculateMatrices2D(frameState);
        this.dispatchRenderEvent(EventType["a" /* default */].PRECOMPOSE, frameState);
        var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
            return a.zIndex - b.zIndex;
        });
        var viewState = frameState.viewState;
        this.children_.length = 0;
        /**
         * @type {Array<import("../layer/BaseVector.js").default>}
         */
        var declutterLayers = [];
        var previousElement = null;
        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
            var layerState = layerStatesArray[i];
            frameState.layerIndex = i;
            var layer = layerState.layer;
            var sourceState = layer.getSourceState();
            if (!Object(Layer["b" /* inView */])(layerState, viewState) ||
                (sourceState != State["a" /* default */].READY &&
                    sourceState != State["a" /* default */].UNDEFINED)) {
                layer.unrender();
                continue;
            }
            var element = layer.render(frameState, previousElement);
            if (!element) {
                continue;
            }
            if (element !== previousElement) {
                this.children_.push(element);
                previousElement = element;
            }
            if ('getDeclutter' in layer) {
                declutterLayers.push(
                /** @type {import("../layer/BaseVector.js").default} */ (layer));
            }
        }
        for (var i = declutterLayers.length - 1; i >= 0; --i) {
            declutterLayers[i].renderDeclutter(frameState);
        }
        Object(dom["f" /* replaceChildren */])(this.element_, this.children_);
        this.dispatchRenderEvent(EventType["a" /* default */].POSTCOMPOSE, frameState);
        if (!this.renderedVisible_) {
            this.element_.style.display = '';
            this.renderedVisible_ = true;
        }
        this.scheduleExpireIconCache(frameState);
    };
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer
     *     callback.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @return {T|undefined} Callback result.
     * @template T
     */
    CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
        var viewState = frameState.viewState;
        var layerStates = frameState.layerStatesArray;
        var numLayers = layerStates.length;
        for (var i = numLayers - 1; i >= 0; --i) {
            var layerState = layerStates[i];
            var layer = layerState.layer;
            if (layer.hasRenderer() &&
                Object(Layer["b" /* inView */])(layerState, viewState) &&
                layerFilter(layer)) {
                var layerRenderer = layer.getRenderer();
                var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                if (data) {
                    var result = callback(layer, data);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return undefined;
    };
    return CompositeMapRenderer;
}(renderer_Map));
/* harmony default export */ var Composite = (Composite_CompositeMapRenderer);
//# sourceMappingURL=Composite.js.map
// EXTERNAL MODULE: ./node_modules/ol/Object.js
var ol_Object = __webpack_require__("e269");

// EXTERNAL MODULE: ./node_modules/ol/Collection.js
var Collection = __webpack_require__("e300");

// EXTERNAL MODULE: ./node_modules/ol/CollectionEventType.js
var CollectionEventType = __webpack_require__("183a");

// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js
var events_EventType = __webpack_require__("01d4");

// EXTERNAL MODULE: ./node_modules/ol/layer/Base.js
var Base = __webpack_require__("5564");

// EXTERNAL MODULE: ./node_modules/ol/events/Event.js
var events_Event = __webpack_require__("cef7");

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__("92fa");

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__("38f3");

// CONCATENATED MODULE: ./node_modules/ol/layer/Group.js
var Group_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/Group
 */












/**
 * @typedef {'addlayer'|'removelayer'} EventType
 */
/**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */
var GroupEvent = /** @class */ (function (_super) {
    Group_extends(GroupEvent, _super);
    /**
     * @param {EventType} type The event type.
     * @param {BaseLayer} layer The layer.
     */
    function GroupEvent(type, layer) {
        var _this = _super.call(this, type) || this;
        /**
         * The added or removed layer.
         * @type {BaseLayer}
         * @api
         */
        _this.layer = layer;
        return _this;
    }
    return GroupEvent;
}(events_Event["a" /* default */]));

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @enum {string}
 * @private
 */
var Property = {
    LAYERS: 'layers',
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
var Group_LayerGroup = /** @class */ (function (_super) {
    Group_extends(LayerGroup, _super);
    /**
     * @param {Options} [opt_options] Layer options.
     */
    function LayerGroup(opt_options) {
        var _this = this;
        var options = opt_options || {};
        var baseOptions = /** @type {Options} */ (Object(obj["a" /* assign */])({}, options));
        delete baseOptions.layers;
        var layers = options.layers;
        _this = _super.call(this, baseOptions) || this;
        /***
         * @type {GroupOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {GroupOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {GroupOnSignature<void>}
         */
        _this.un;
        /**
         * @private
         * @type {Array<import("../events.js").EventsKey>}
         */
        _this.layersListenerKeys_ = [];
        /**
         * @private
         * @type {Object<string, Array<import("../events.js").EventsKey>>}
         */
        _this.listenerKeys_ = {};
        _this.addChangeListener(Property.LAYERS, _this.handleLayersChanged_);
        if (layers) {
            if (Array.isArray(layers)) {
                layers = new Collection["a" /* default */](layers.slice(), { unique: true });
            }
            else {
                Object(asserts["a" /* assert */])(typeof ( /** @type {?} */(layers).getArray) === 'function', 43); // Expected `layers` to be an array or a `Collection`
            }
        }
        else {
            layers = new Collection["a" /* default */](undefined, { unique: true });
        }
        _this.setLayers(layers);
        return _this;
    }
    /**
     * @private
     */
    LayerGroup.prototype.handleLayerChange_ = function () {
        this.changed();
    };
    /**
     * @private
     */
    LayerGroup.prototype.handleLayersChanged_ = function () {
        this.layersListenerKeys_.forEach(events["c" /* unlistenByKey */]);
        this.layersListenerKeys_.length = 0;
        var layers = this.getLayers();
        this.layersListenerKeys_.push(Object(events["a" /* listen */])(layers, CollectionEventType["a" /* default */].ADD, this.handleLayersAdd_, this), Object(events["a" /* listen */])(layers, CollectionEventType["a" /* default */].REMOVE, this.handleLayersRemove_, this));
        for (var id in this.listenerKeys_) {
            this.listenerKeys_[id].forEach(events["c" /* unlistenByKey */]);
        }
        Object(obj["b" /* clear */])(this.listenerKeys_);
        var layersArray = layers.getArray();
        for (var i = 0, ii = layersArray.length; i < ii; i++) {
            var layer = layersArray[i];
            this.registerLayerListeners_(layer);
            this.dispatchEvent(new GroupEvent('addlayer', layer));
        }
        this.changed();
    };
    /**
     * @param {BaseLayer} layer The layer.
     */
    LayerGroup.prototype.registerLayerListeners_ = function (layer) {
        var listenerKeys = [
            Object(events["a" /* listen */])(layer, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.handleLayerChange_, this),
            Object(events["a" /* listen */])(layer, events_EventType["a" /* default */].CHANGE, this.handleLayerChange_, this),
        ];
        if (layer instanceof LayerGroup) {
            listenerKeys.push(Object(events["a" /* listen */])(layer, 'addlayer', this.handleLayerGroupAdd_, this), Object(events["a" /* listen */])(layer, 'removelayer', this.handleLayerGroupRemove_, this));
        }
        this.listenerKeys_[Object(util["c" /* getUid */])(layer)] = listenerKeys;
    };
    /**
     * @param {GroupEvent} event The layer group event.
     */
    LayerGroup.prototype.handleLayerGroupAdd_ = function (event) {
        this.dispatchEvent(new GroupEvent('addlayer', event.layer));
    };
    /**
     * @param {GroupEvent} event The layer group event.
     */
    LayerGroup.prototype.handleLayerGroupRemove_ = function (event) {
        this.dispatchEvent(new GroupEvent('removelayer', event.layer));
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
     * @private
     */
    LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
        var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent('addlayer', layer));
        this.changed();
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
     * @private
     */
    LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
        var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
        var key = Object(util["c" /* getUid */])(layer);
        this.listenerKeys_[key].forEach(events["c" /* unlistenByKey */]);
        delete this.listenerKeys_[key];
        this.dispatchEvent(new GroupEvent('removelayer', layer));
        this.changed();
    };
    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    LayerGroup.prototype.getLayers = function () {
        return /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property.LAYERS));
    };
    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    LayerGroup.prototype.setLayers = function (layers) {
        var collection = this.getLayers();
        if (collection) {
            var currentLayers = collection.getArray();
            for (var i = 0, ii = currentLayers.length; i < ii; ++i) {
                this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
            }
        }
        this.set(Property.LAYERS, layers);
    };
    /**
     * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    LayerGroup.prototype.getLayersArray = function (opt_array) {
        var array = opt_array !== undefined ? opt_array : [];
        this.getLayers().forEach(function (layer) {
            layer.getLayersArray(array);
        });
        return array;
    };
    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If opt_states is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [opt_states] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
        var states = opt_states !== undefined ? opt_states : [];
        var pos = states.length;
        this.getLayers().forEach(function (layer) {
            layer.getLayerStatesArray(states);
        });
        var ownLayerState = this.getLayerState();
        var defaultZIndex = ownLayerState.zIndex;
        if (!opt_states && ownLayerState.zIndex === undefined) {
            defaultZIndex = 0;
        }
        for (var i = pos, ii = states.length; i < ii; i++) {
            var layerState = states[i];
            layerState.opacity *= ownLayerState.opacity;
            layerState.visible = layerState.visible && ownLayerState.visible;
            layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
            layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
            layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
            layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
            if (ownLayerState.extent !== undefined) {
                if (layerState.extent !== undefined) {
                    layerState.extent = Object(extent["A" /* getIntersection */])(layerState.extent, ownLayerState.extent);
                }
                else {
                    layerState.extent = ownLayerState.extent;
                }
            }
            if (layerState.zIndex === undefined) {
                layerState.zIndex = defaultZIndex;
            }
        }
        return states;
    };
    /**
     * @return {import("../source/State.js").default} Source state.
     */
    LayerGroup.prototype.getSourceState = function () {
        return State["a" /* default */].READY;
    };
    return LayerGroup;
}(Base["a" /* default */]));
/* harmony default export */ var Group = (Group_LayerGroup);
//# sourceMappingURL=Group.js.map
// EXTERNAL MODULE: ./node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent = __webpack_require__("509b");

// EXTERNAL MODULE: ./node_modules/ol/MapBrowserEventType.js
var MapBrowserEventType = __webpack_require__("0b2d");

// CONCATENATED MODULE: ./node_modules/ol/pointer/EventType.js
/**
 * @module ol/pointer/EventType
 */
/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ var pointer_EventType = ({
    POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel',
});
//# sourceMappingURL=EventType.js.map
// EXTERNAL MODULE: ./node_modules/ol/events/Target.js
var Target = __webpack_require__("0ec0");

// EXTERNAL MODULE: ./node_modules/ol/has.js
var has = __webpack_require__("617d");

// CONCATENATED MODULE: ./node_modules/ol/MapBrowserEventHandler.js
/**
 * @module ol/MapBrowserEventHandler
 */
var MapBrowserEventHandler_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var MapBrowserEventHandler_MapBrowserEventHandler = /** @class */ (function (_super) {
    MapBrowserEventHandler_extends(MapBrowserEventHandler, _super);
    /**
     * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */
    function MapBrowserEventHandler(map, moveTolerance) {
        var _this = _super.call(this, map) || this;
        /**
         * This is the element that we will listen to the real events on.
         * @type {import("./PluggableMap.js").default}
         * @private
         */
        _this.map_ = map;
        /**
         * @type {any}
         * @private
         */
        _this.clickTimeoutId_;
        /**
         * Emulate dblclick and singleclick. Will be true when only one pointer is active.
         * @type {boolean}
         */
        _this.emulateClicks_ = false;
        /**
         * @type {boolean}
         * @private
         */
        _this.dragging_ = false;
        /**
         * @type {!Array<import("./events.js").EventsKey>}
         * @private
         */
        _this.dragListenerKeys_ = [];
        /**
         * @type {number}
         * @private
         */
        _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
        /**
         * The most recent "down" type event (or null if none have occurred).
         * Set on pointerdown.
         * @type {PointerEvent|null}
         * @private
         */
        _this.down_ = null;
        var element = _this.map_.getViewport();
        /**
         * @type {number}
         * @private
         */
        _this.activePointers_ = 0;
        /**
         * @type {!Object<number, boolean>}
         * @private
         */
        _this.trackedTouches_ = {};
        _this.element_ = element;
        /**
         * @type {?import("./events.js").EventsKey}
         * @private
         */
        _this.pointerdownListenerKey_ = Object(events["a" /* listen */])(element, pointer_EventType.POINTERDOWN, _this.handlePointerDown_, _this);
        /**
         * @type {PointerEvent}
         * @private
         */
        _this.originalPointerMoveEvent_;
        /**
         * @type {?import("./events.js").EventsKey}
         * @private
         */
        _this.relayedListenerKey_ = Object(events["a" /* listen */])(element, pointer_EventType.POINTERMOVE, _this.relayEvent_, _this);
        /**
         * @private
         */
        _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
        _this.element_.addEventListener(events_EventType["a" /* default */].TOUCHMOVE, _this.boundHandleTouchMove_, has["e" /* PASSIVE_EVENT_LISTENERS */] ? { passive: false } : false);
        return _this;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
        var newEvent = new MapBrowserEvent["a" /* default */](MapBrowserEventType["a" /* default */].CLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        if (this.clickTimeoutId_ !== undefined) {
            // double-click
            clearTimeout(this.clickTimeoutId_);
            this.clickTimeoutId_ = undefined;
            newEvent = new MapBrowserEvent["a" /* default */](MapBrowserEventType["a" /* default */].DBLCLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
        }
        else {
            // click
            this.clickTimeoutId_ = setTimeout(
            /** @this {MapBrowserEventHandler} */
            function () {
                this.clickTimeoutId_ = undefined;
                var newEvent = new MapBrowserEvent["a" /* default */](MapBrowserEventType["a" /* default */].SINGLECLICK, this.map_, pointerEvent);
                this.dispatchEvent(newEvent);
            }.bind(this), 250);
        }
    };
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
        var event = pointerEvent;
        if (event.type == MapBrowserEventType["a" /* default */].POINTERUP ||
            event.type == MapBrowserEventType["a" /* default */].POINTERCANCEL) {
            delete this.trackedTouches_[event.pointerId];
        }
        else if (event.type == MapBrowserEventType["a" /* default */].POINTERDOWN) {
            this.trackedTouches_[event.pointerId] = true;
        }
        this.activePointers_ = Object.keys(this.trackedTouches_).length;
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        var newEvent = new MapBrowserEvent["a" /* default */](MapBrowserEventType["a" /* default */].POINTERUP, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        // We emulate click events on left mouse button click, touch contact, and pen
        // contact. isMouseActionButton returns true in these cases (evt.button is set
        // to 0).
        // See http://www.w3.org/TR/pointerevents/#button-states
        // We only fire click, singleclick, and doubleclick if nobody has called
        // event.preventDefault().
        if (this.emulateClicks_ &&
            !newEvent.defaultPrevented &&
            !this.dragging_ &&
            this.isMouseActionButton_(pointerEvent)) {
            this.emulateClick_(this.down_);
        }
        if (this.activePointers_ === 0) {
            this.dragListenerKeys_.forEach(events["c" /* unlistenByKey */]);
            this.dragListenerKeys_.length = 0;
            this.dragging_ = false;
            this.down_ = null;
        }
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */
    MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
        return pointerEvent.button === 0;
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
        this.emulateClicks_ = this.activePointers_ === 0;
        this.updateActivePointers_(pointerEvent);
        var newEvent = new MapBrowserEvent["a" /* default */](MapBrowserEventType["a" /* default */].POINTERDOWN, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        // Store a copy of the down event
        this.down_ = /** @type {PointerEvent} */ ({});
        for (var property in pointerEvent) {
            var value = pointerEvent[property];
            this.down_[property] = typeof value === 'function' ? functions["c" /* VOID */] : value;
        }
        if (this.dragListenerKeys_.length === 0) {
            var doc = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(Object(events["a" /* listen */])(doc, MapBrowserEventType["a" /* default */].POINTERMOVE, this.handlePointerMove_, this), Object(events["a" /* listen */])(doc, MapBrowserEventType["a" /* default */].POINTERUP, this.handlePointerUp_, this), 
            /* Note that the listener for `pointercancel is set up on
             * `pointerEventHandler_` and not `documentPointerEventHandler_` like
             * the `pointerup` and `pointermove` listeners.
             *
             * The reason for this is the following: `TouchSource.vacuumTouches_()`
             * issues `pointercancel` events, when there was no `touchend` for a
             * `touchstart`. Now, let's say a first `touchstart` is registered on
             * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
             * But `documentPointerEventHandler_` doesn't know about the first
             * `touchstart`. If there is no `touchend` for the `touchstart`, we can
             * only receive a `touchcancel` from `pointerEventHandler_`, because it is
             * only registered there.
             */
            Object(events["a" /* listen */])(this.element_, MapBrowserEventType["a" /* default */].POINTERCANCEL, this.handlePointerUp_, this));
            if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
                this.dragListenerKeys_.push(Object(events["a" /* listen */])(this.element_.getRootNode(), MapBrowserEventType["a" /* default */].POINTERUP, this.handlePointerUp_, this));
            }
        }
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
        // Between pointerdown and pointerup, pointermove events are triggered.
        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
        // moved a significant distance.
        if (this.isMoving_(pointerEvent)) {
            this.dragging_ = true;
            var newEvent = new MapBrowserEvent["a" /* default */](MapBrowserEventType["a" /* default */].POINTERDRAG, this.map_, pointerEvent, this.dragging_);
            this.dispatchEvent(newEvent);
        }
    };
    /**
     * Wrap and relay a pointer event.  Note that this requires that the type
     * string for the MapBrowserEvent matches the PointerEvent type.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
        this.originalPointerMoveEvent_ = pointerEvent;
        var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
        this.dispatchEvent(new MapBrowserEvent["a" /* default */](pointerEvent.type, this.map_, pointerEvent, dragging));
    };
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */
    MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
        // may not be initialized yet when we get here on a platform without native pointer events.
        var originalEvent = this.originalPointerMoveEvent_;
        if ((!originalEvent || originalEvent.defaultPrevented) &&
            (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {
            event.preventDefault();
        }
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */
    MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
        return (this.dragging_ ||
            Math.abs(pointerEvent.clientX - this.down_.clientX) >
                this.moveTolerance_ ||
            Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_);
    };
    /**
     * Clean up.
     */
    MapBrowserEventHandler.prototype.disposeInternal = function () {
        if (this.relayedListenerKey_) {
            Object(events["c" /* unlistenByKey */])(this.relayedListenerKey_);
            this.relayedListenerKey_ = null;
        }
        this.element_.removeEventListener(events_EventType["a" /* default */].TOUCHMOVE, this.boundHandleTouchMove_);
        if (this.pointerdownListenerKey_) {
            Object(events["c" /* unlistenByKey */])(this.pointerdownListenerKey_);
            this.pointerdownListenerKey_ = null;
        }
        this.dragListenerKeys_.forEach(events["c" /* unlistenByKey */]);
        this.dragListenerKeys_.length = 0;
        this.element_ = null;
        _super.prototype.disposeInternal.call(this);
    };
    return MapBrowserEventHandler;
}(Target["a" /* default */]));
/* harmony default export */ var ol_MapBrowserEventHandler = (MapBrowserEventHandler_MapBrowserEventHandler);
//# sourceMappingURL=MapBrowserEventHandler.js.map
// EXTERNAL MODULE: ./node_modules/ol/MapEvent.js
var MapEvent = __webpack_require__("7238");

// EXTERNAL MODULE: ./node_modules/ol/MapEventType.js
var MapEventType = __webpack_require__("592d");

// EXTERNAL MODULE: ./node_modules/ol/MapProperty.js
var MapProperty = __webpack_require__("e637");

// CONCATENATED MODULE: ./node_modules/ol/structs/PriorityQueue.js
/**
 * @module ol/structs/PriorityQueue
 */


/**
 * @type {number}
 */
var DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
var PriorityQueue_PriorityQueue = /** @class */ (function () {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */
    function PriorityQueue(priorityFunction, keyFunction) {
        /**
         * @type {function(T): number}
         * @private
         */
        this.priorityFunction_ = priorityFunction;
        /**
         * @type {function(T): string}
         * @private
         */
        this.keyFunction_ = keyFunction;
        /**
         * @type {Array<T>}
         * @private
         */
        this.elements_ = [];
        /**
         * @type {Array<number>}
         * @private
         */
        this.priorities_ = [];
        /**
         * @type {!Object<string, boolean>}
         * @private
         */
        this.queuedElements_ = {};
    }
    /**
     * FIXME empty description for jsdoc
     */
    PriorityQueue.prototype.clear = function () {
        this.elements_.length = 0;
        this.priorities_.length = 0;
        Object(obj["b" /* clear */])(this.queuedElements_);
    };
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
    PriorityQueue.prototype.dequeue = function () {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var element = elements[0];
        if (elements.length == 1) {
            elements.length = 0;
            priorities.length = 0;
        }
        else {
            elements[0] = elements.pop();
            priorities[0] = priorities.pop();
            this.siftUp_(0);
        }
        var elementKey = this.keyFunction_(element);
        delete this.queuedElements_[elementKey];
        return element;
    };
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
    PriorityQueue.prototype.enqueue = function (element) {
        Object(asserts["a" /* assert */])(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
        var priority = this.priorityFunction_(element);
        if (priority != DROP) {
            this.elements_.push(element);
            this.priorities_.push(priority);
            this.queuedElements_[this.keyFunction_(element)] = true;
            this.siftDown_(0, this.elements_.length - 1);
            return true;
        }
        return false;
    };
    /**
     * @return {number} Count.
     */
    PriorityQueue.prototype.getCount = function () {
        return this.elements_.length;
    };
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
    PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
        return index * 2 + 1;
    };
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
    PriorityQueue.prototype.getRightChildIndex_ = function (index) {
        return index * 2 + 2;
    };
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
    PriorityQueue.prototype.getParentIndex_ = function (index) {
        return (index - 1) >> 1;
    };
    /**
     * Make this a heap. O(N).
     * @private
     */
    PriorityQueue.prototype.heapify_ = function () {
        var i;
        for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
            this.siftUp_(i);
        }
    };
    /**
     * @return {boolean} Is empty.
     */
    PriorityQueue.prototype.isEmpty = function () {
        return this.elements_.length === 0;
    };
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
    PriorityQueue.prototype.isKeyQueued = function (key) {
        return key in this.queuedElements_;
    };
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
    PriorityQueue.prototype.isQueued = function (element) {
        return this.isKeyQueued(this.keyFunction_(element));
    };
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
    PriorityQueue.prototype.siftUp_ = function (index) {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var count = elements.length;
        var element = elements[index];
        var priority = priorities[index];
        var startIndex = index;
        while (index < count >> 1) {
            var lIndex = this.getLeftChildIndex_(index);
            var rIndex = this.getRightChildIndex_(index);
            var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex]
                ? rIndex
                : lIndex;
            elements[index] = elements[smallerChildIndex];
            priorities[index] = priorities[smallerChildIndex];
            index = smallerChildIndex;
        }
        elements[index] = element;
        priorities[index] = priority;
        this.siftDown_(startIndex, index);
    };
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
    PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var element = elements[index];
        var priority = priorities[index];
        while (index > startIndex) {
            var parentIndex = this.getParentIndex_(index);
            if (priorities[parentIndex] > priority) {
                elements[index] = elements[parentIndex];
                priorities[index] = priorities[parentIndex];
                index = parentIndex;
            }
            else {
                break;
            }
        }
        elements[index] = element;
        priorities[index] = priority;
    };
    /**
     * FIXME empty description for jsdoc
     */
    PriorityQueue.prototype.reprioritize = function () {
        var priorityFunction = this.priorityFunction_;
        var elements = this.elements_;
        var priorities = this.priorities_;
        var index = 0;
        var n = elements.length;
        var element, i, priority;
        for (i = 0; i < n; ++i) {
            element = elements[i];
            priority = priorityFunction(element);
            if (priority == DROP) {
                delete this.queuedElements_[this.keyFunction_(element)];
            }
            else {
                priorities[index] = priority;
                elements[index++] = element;
            }
        }
        elements.length = index;
        priorities.length = index;
        this.heapify_();
    };
    return PriorityQueue;
}());
/* harmony default export */ var structs_PriorityQueue = (PriorityQueue_PriorityQueue);
//# sourceMappingURL=PriorityQueue.js.map
// EXTERNAL MODULE: ./node_modules/ol/TileState.js
var TileState = __webpack_require__("acc1");

// CONCATENATED MODULE: ./node_modules/ol/TileQueue.js
var TileQueue_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/TileQueue
 */



/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */
var TileQueue_TileQueue = /** @class */ (function (_super) {
    TileQueue_extends(TileQueue, _super);
    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */
    function TileQueue(tilePriorityFunction, tileChangeCallback) {
        var _this = _super.call(this, 
        /**
         * @param {Array} element Element.
         * @return {number} Priority.
         */
        function (element) {
            return tilePriorityFunction.apply(null, element);
        }, 
        /**
         * @param {Array} element Element.
         * @return {string} Key.
         */
        function (element) {
            return /** @type {import("./Tile.js").default} */ (element[0]).getKey();
        }) || this;
        /** @private */
        _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
        /**
         * @private
         * @type {function(): ?}
         */
        _this.tileChangeCallback_ = tileChangeCallback;
        /**
         * @private
         * @type {number}
         */
        _this.tilesLoading_ = 0;
        /**
         * @private
         * @type {!Object<string,boolean>}
         */
        _this.tilesLoadingKeys_ = {};
        return _this;
    }
    /**
     * @param {Array} element Element.
     * @return {boolean} The element was added to the queue.
     */
    TileQueue.prototype.enqueue = function (element) {
        var added = _super.prototype.enqueue.call(this, element);
        if (added) {
            var tile = element[0];
            tile.addEventListener(events_EventType["a" /* default */].CHANGE, this.boundHandleTileChange_);
        }
        return added;
    };
    /**
     * @return {number} Number of tiles loading.
     */
    TileQueue.prototype.getTilesLoading = function () {
        return this.tilesLoading_;
    };
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */
    TileQueue.prototype.handleTileChange = function (event) {
        var tile = /** @type {import("./Tile.js").default} */ (event.target);
        var state = tile.getState();
        if (state === TileState["a" /* default */].LOADED ||
            state === TileState["a" /* default */].ERROR ||
            state === TileState["a" /* default */].EMPTY) {
            tile.removeEventListener(events_EventType["a" /* default */].CHANGE, this.boundHandleTileChange_);
            var tileKey = tile.getKey();
            if (tileKey in this.tilesLoadingKeys_) {
                delete this.tilesLoadingKeys_[tileKey];
                --this.tilesLoading_;
            }
            this.tileChangeCallback_();
        }
    };
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */
    TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
        var newLoads = 0;
        var state, tile, tileKey;
        while (this.tilesLoading_ < maxTotalLoading &&
            newLoads < maxNewLoads &&
            this.getCount() > 0) {
            tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
            tileKey = tile.getKey();
            state = tile.getState();
            if (state === TileState["a" /* default */].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                this.tilesLoadingKeys_[tileKey] = true;
                ++this.tilesLoading_;
                ++newLoads;
                tile.load();
            }
        }
    };
    return TileQueue;
}(structs_PriorityQueue));
/* harmony default export */ var ol_TileQueue = (TileQueue_TileQueue);
/**
 * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
        return DROP;
    }
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
        return DROP;
    }
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels between
    // the center of the tile and the center of the viewport.  The factor of 65536
    // means that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    var center = frameState.viewState.center;
    var deltaX = tileCenter[0] - center[0];
    var deltaY = tileCenter[1] - center[1];
    return (65536 * Math.log(tileResolution) +
        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution);
}
//# sourceMappingURL=TileQueue.js.map
// EXTERNAL MODULE: ./node_modules/ol/View.js + 3 modules
var View = __webpack_require__("a2c7");

// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js
var ViewHint = __webpack_require__("496f");

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules
var proj = __webpack_require__("256f");

// EXTERNAL MODULE: ./node_modules/ol/size.js
var ol_size = __webpack_require__("345d");

// CONCATENATED MODULE: ./node_modules/ol/PluggableMap.js
var PluggableMap_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/PluggableMap
 */




























/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent.
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */
/**
 * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
 */
/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */
/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */
/**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} PluggableMapOnSignature
 */
/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */
/**
 * @param {import("./layer/Base.js").default} layer Layer.
 */
function removeLayerMapProperty(layer) {
    if (layer instanceof Layer["a" /* default */]) {
        layer.setMapInternal(null);
        return;
    }
    if (layer instanceof Group) {
        layer.getLayers().forEach(removeLayerMapProperty);
    }
}
/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {PluggableMap} map Map.
 */
function setLayerMapProperty(layer, map) {
    if (layer instanceof Layer["a" /* default */]) {
        layer.setMapInternal(map);
        return;
    }
    if (layer instanceof Group) {
        var layers = layer.getLayers().getArray();
        for (var i = 0, ii = layers.length; i < ii; ++i) {
            setLayerMapProperty(layers[i], map);
        }
    }
}
/**
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */
var PluggableMap_PluggableMap = /** @class */ (function (_super) {
    PluggableMap_extends(PluggableMap, _super);
    /**
     * @param {MapOptions} options Map options.
     */
    function PluggableMap(options) {
        var _this = _super.call(this) || this;
        /***
         * @type {PluggableMapOnSignature<import("./events").EventsKey>}
         */
        _this.on;
        /***
         * @type {PluggableMapOnSignature<import("./events").EventsKey>}
         */
        _this.once;
        /***
         * @type {PluggableMapOnSignature<void>}
         */
        _this.un;
        var optionsInternal = createOptionsInternal(options);
        /**
         * @private
         * @type {boolean}
         */
        _this.renderComplete_;
        /** @private */
        _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
        /**
         * @type {number}
         * @private
         */
        _this.maxTilesLoading_ =
            options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
        /**
         * @private
         * @type {number}
         */
        _this.pixelRatio_ =
            options.pixelRatio !== undefined
                ? options.pixelRatio
                : has["a" /* DEVICE_PIXEL_RATIO */];
        /**
         * @private
         * @type {*}
         */
        _this.postRenderTimeoutHandle_;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.animationDelayKey_;
        /**
         * @private
         */
        _this.animationDelay_ = /** @this {PluggableMap} */ function () {
            this.animationDelayKey_ = undefined;
            this.renderFrame_(Date.now());
        }.bind(_this);
        /**
         * @private
         * @type {import("./transform.js").Transform}
         */
        _this.coordinateToPixelTransform_ = Object(transform["c" /* create */])();
        /**
         * @private
         * @type {import("./transform.js").Transform}
         */
        _this.pixelToCoordinateTransform_ = Object(transform["c" /* create */])();
        /**
         * @private
         * @type {number}
         */
        _this.frameIndex_ = 0;
        /**
         * @private
         * @type {?FrameState}
         */
        _this.frameState_ = null;
        /**
         * The extent at the previous 'moveend' event.
         * @private
         * @type {import("./extent.js").Extent}
         */
        _this.previousExtent_ = null;
        /**
         * @private
         * @type {?import("./events.js").EventsKey}
         */
        _this.viewPropertyListenerKey_ = null;
        /**
         * @private
         * @type {?import("./events.js").EventsKey}
         */
        _this.viewChangeListenerKey_ = null;
        /**
         * @private
         * @type {?Array<import("./events.js").EventsKey>}
         */
        _this.layerGroupPropertyListenerKeys_ = null;
        /**
         * @private
         * @type {!HTMLElement}
         */
        _this.viewport_ = document.createElement('div');
        _this.viewport_.className =
            'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
        _this.viewport_.style.position = 'relative';
        _this.viewport_.style.overflow = 'hidden';
        _this.viewport_.style.width = '100%';
        _this.viewport_.style.height = '100%';
        /**
         * @private
         * @type {!HTMLElement}
         */
        _this.overlayContainer_ = document.createElement('div');
        _this.overlayContainer_.style.position = 'absolute';
        _this.overlayContainer_.style.zIndex = '0';
        _this.overlayContainer_.style.width = '100%';
        _this.overlayContainer_.style.height = '100%';
        _this.overlayContainer_.style.pointerEvents = 'none';
        _this.overlayContainer_.className = 'ol-overlaycontainer';
        _this.viewport_.appendChild(_this.overlayContainer_);
        /**
         * @private
         * @type {!HTMLElement}
         */
        _this.overlayContainerStopEvent_ = document.createElement('div');
        _this.overlayContainerStopEvent_.style.position = 'absolute';
        _this.overlayContainerStopEvent_.style.zIndex = '0';
        _this.overlayContainerStopEvent_.style.width = '100%';
        _this.overlayContainerStopEvent_.style.height = '100%';
        _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
        _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
        _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
        /**
         * @private
         * @type {MapBrowserEventHandler}
         */
        _this.mapBrowserEventHandler_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.moveTolerance_ = options.moveTolerance;
        /**
         * @private
         * @type {HTMLElement|Document}
         */
        _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
        /**
         * @private
         * @type {?Array<import("./events.js").EventsKey>}
         */
        _this.targetChangeHandlerKeys_ = null;
        /**
         * @type {Collection<import("./control/Control.js").default>}
         * @protected
         */
        _this.controls = optionsInternal.controls || new Collection["a" /* default */]();
        /**
         * @type {Collection<import("./interaction/Interaction.js").default>}
         * @protected
         */
        _this.interactions = optionsInternal.interactions || new Collection["a" /* default */]();
        /**
         * @type {Collection<import("./Overlay.js").default>}
         * @private
         */
        _this.overlays_ = optionsInternal.overlays;
        /**
         * A lookup of overlays by id.
         * @private
         * @type {Object<string, import("./Overlay.js").default>}
         */
        _this.overlayIdIndex_ = {};
        /**
         * @type {import("./renderer/Map.js").default}
         * @private
         */
        _this.renderer_ = null;
        /**
         * @private
         * @type {!Array<PostRenderFunction>}
         */
        _this.postRenderFunctions_ = [];
        /**
         * @private
         * @type {TileQueue}
         */
        _this.tileQueue_ = new ol_TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
        _this.addChangeListener(MapProperty["a" /* default */].LAYERGROUP, _this.handleLayerGroupChanged_);
        _this.addChangeListener(MapProperty["a" /* default */].VIEW, _this.handleViewChanged_);
        _this.addChangeListener(MapProperty["a" /* default */].SIZE, _this.handleSizeChanged_);
        _this.addChangeListener(MapProperty["a" /* default */].TARGET, _this.handleTargetChanged_);
        // setProperties will trigger the rendering of the map if the map
        // is "defined" already.
        _this.setProperties(optionsInternal.values);
        var map = _this;
        if (options.view && !(options.view instanceof View["a" /* default */])) {
            options.view.then(function (viewOptions) {
                map.setView(new View["a" /* default */](viewOptions));
            });
        }
        _this.controls.addEventListener(CollectionEventType["a" /* default */].ADD, 
        /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */
        function (event) {
            event.element.setMap(this);
        }.bind(_this));
        _this.controls.addEventListener(CollectionEventType["a" /* default */].REMOVE, 
        /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */
        function (event) {
            event.element.setMap(null);
        }.bind(_this));
        _this.interactions.addEventListener(CollectionEventType["a" /* default */].ADD, 
        /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */
        function (event) {
            event.element.setMap(this);
        }.bind(_this));
        _this.interactions.addEventListener(CollectionEventType["a" /* default */].REMOVE, 
        /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */
        function (event) {
            event.element.setMap(null);
        }.bind(_this));
        _this.overlays_.addEventListener(CollectionEventType["a" /* default */].ADD, 
        /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */
        function (event) {
            this.addOverlayInternal_(
            /** @type {import("./Overlay.js").default} */ (event.element));
        }.bind(_this));
        _this.overlays_.addEventListener(CollectionEventType["a" /* default */].REMOVE, 
        /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */
        function (event) {
            var overlay = /** @type {import("./Overlay.js").default} */ (event.element);
            var id = overlay.getId();
            if (id !== undefined) {
                delete this.overlayIdIndex_[id.toString()];
            }
            event.element.setMap(null);
        }.bind(_this));
        _this.controls.forEach(
        /**
         * @param {import("./control/Control.js").default} control Control.
         * @this {PluggableMap}
         */
        function (control) {
            control.setMap(this);
        }.bind(_this));
        _this.interactions.forEach(
        /**
         * @param {import("./interaction/Interaction.js").default} interaction Interaction.
         * @this {PluggableMap}
         */
        function (interaction) {
            interaction.setMap(this);
        }.bind(_this));
        _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
        return _this;
    }
    /**
     * @abstract
     * @return {import("./renderer/Map.js").default} The map renderer
     */
    PluggableMap.prototype.createRenderer = function () {
        throw new Error('Use a map type that has a createRenderer method');
    };
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */
    PluggableMap.prototype.addControl = function (control) {
        this.getControls().push(control);
    };
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteraction()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */
    PluggableMap.prototype.addInteraction = function (interaction) {
        this.getInteractions().push(interaction);
    };
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */
    PluggableMap.prototype.addLayer = function (layer) {
        var layers = this.getLayerGroup().getLayers();
        layers.push(layer);
    };
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */
    PluggableMap.prototype.handleLayerAdd_ = function (event) {
        setLayerMapProperty(event.layer, this);
    };
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */
    PluggableMap.prototype.addOverlay = function (overlay) {
        this.getOverlays().push(overlay);
    };
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */
    PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
        var id = overlay.getId();
        if (id !== undefined) {
            this.overlayIdIndex_[id.toString()] = overlay;
        }
        overlay.setMap(this);
    };
    /**
     *
     * Clean up.
     */
    PluggableMap.prototype.disposeInternal = function () {
        this.setTarget(null);
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `opt_options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [opt_options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */
    PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
        if (!this.frameState_) {
            return;
        }
        var coordinate = this.getCoordinateFromPixelInternal(pixel);
        opt_options = opt_options !== undefined ? opt_options : {};
        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : functions["b" /* TRUE */];
        var checkWrapped = opt_options.checkWrapped !== false;
        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
    };
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [opt_options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */
    PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
        var features = [];
        this.forEachFeatureAtPixel(pixel, function (feature) {
            features.push(feature);
        }, opt_options);
        return features;
    };
    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */
    PluggableMap.prototype.getAllLayers = function () {
        var layers = [];
        function addLayersFrom(layerGroup) {
            layerGroup.forEach(function (layer) {
                if (layer instanceof Group) {
                    addLayersFrom(layer.getLayers());
                }
                else {
                    layers.push(layer);
                }
            });
        }
        addLayersFrom(this.getLayers());
        return layers;
    };
    /**
     * Please the `layer.getData()` method for {@link module:ol/layer/Tile~TileLayer#getData tile layers} or
     * {@link module:ol/layer/Image~ImageLayer#getData image layers} instead of using this method.
     *
     * Detect layers that have a color value at a pixel on the viewport, and
     * execute a callback with each matching layer. Layers included in the
     * detection can be configured through `opt_layerFilter`.
     *
     * Note: In maps with more than one layer, this method will typically return pixel data
     * representing the composed image of all layers visible at the given pixel – because layers
     * will generally share the same rendering context.  To force layers to render separately, and
     * to get pixel data representing only one layer at a time, you can assign each layer a unique
     * `className` in its constructor.
     *
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
     *     Layer callback. This callback will receive two arguments: first is the
     *     {@link module:ol/layer/Layer~Layer layer}, second argument is an array representing
     *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
     *     that do not currently support this argument. To stop detection, callback
     *     functions can return a truthy value.
     * @param {AtPixelOptions} [opt_options] Configuration options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template S,T
     * @api
     * @deprecated
     */
    PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
        if (!this.frameState_) {
            return;
        }
        var options = opt_options || {};
        var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        var layerFilter = options.layerFilter || functions["b" /* TRUE */];
        return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
    };
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through `opt_layerFilter`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [opt_options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */
    PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
        if (!this.frameState_) {
            return false;
        }
        var coordinate = this.getCoordinateFromPixelInternal(pixel);
        opt_options = opt_options !== undefined ? opt_options : {};
        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : functions["b" /* TRUE */];
        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
        var checkWrapped = opt_options.checkWrapped !== false;
        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
    };
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
    PluggableMap.prototype.getEventCoordinate = function (event) {
        return this.getCoordinateFromPixel(this.getEventPixel(event));
    };
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */
    PluggableMap.prototype.getEventCoordinateInternal = function (event) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    };
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */
    PluggableMap.prototype.getEventPixel = function (event) {
        var viewportPosition = this.viewport_.getBoundingClientRect();
        var eventPosition = 
        //FIXME Are we really calling this with a TouchEvent anywhere?
        'changedTouches' in event
            ? /** @type {TouchEvent} */ (event).changedTouches[0]
            : /** @type {MouseEvent} */ (event);
        return [
            eventPosition.clientX - viewportPosition.left,
            eventPosition.clientY - viewportPosition.top,
        ];
    };
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */
    PluggableMap.prototype.getTarget = function () {
        return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty["a" /* default */].TARGET));
    };
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */
    PluggableMap.prototype.getTargetElement = function () {
        var target = this.getTarget();
        if (target !== undefined) {
            return typeof target === 'string'
                ? document.getElementById(target)
                : target;
        }
        else {
            return null;
        }
    };
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */
    PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
        return Object(proj["r" /* toUserCoordinate */])(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
    };
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */
    PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
        var frameState = this.frameState_;
        if (!frameState) {
            return null;
        }
        else {
            return Object(transform["a" /* apply */])(frameState.pixelToCoordinateTransform, pixel.slice());
        }
    };
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */
    PluggableMap.prototype.getControls = function () {
        return this.controls;
    };
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */
    PluggableMap.prototype.getOverlays = function () {
        return this.overlays_;
    };
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default} Overlay.
     * @api
     */
    PluggableMap.prototype.getOverlayById = function (id) {
        var overlay = this.overlayIdIndex_[id.toString()];
        return overlay !== undefined ? overlay : null;
    };
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */
    PluggableMap.prototype.getInteractions = function () {
        return this.interactions;
    };
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */
    PluggableMap.prototype.getLayerGroup = function () {
        return /** @type {LayerGroup} */ (this.get(MapProperty["a" /* default */].LAYERGROUP));
    };
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */
    PluggableMap.prototype.setLayers = function (layers) {
        var group = this.getLayerGroup();
        if (layers instanceof Collection["a" /* default */]) {
            group.setLayers(layers);
            return;
        }
        var collection = group.getLayers();
        collection.clear();
        collection.extend(layers);
    };
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */
    PluggableMap.prototype.getLayers = function () {
        var layers = this.getLayerGroup().getLayers();
        return layers;
    };
    /**
     * @return {boolean} Layers have sources that are still loading.
     */
    PluggableMap.prototype.getLoadingOrNotReady = function () {
        var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
            var layer = layerStatesArray[i].layer;
            if (!layer.getRenderer().ready) {
                return true;
            }
            var source = /** @type {import("./layer/Layer.js").default} */ (layer).getSource();
            if (source && source.loading) {
                return true;
            }
        }
        return false;
    };
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */
    PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
        var viewCoordinate = Object(proj["j" /* fromUserCoordinate */])(coordinate, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(viewCoordinate);
    };
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */
    PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
        var frameState = this.frameState_;
        if (!frameState) {
            return null;
        }
        else {
            return Object(transform["a" /* apply */])(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
        }
    };
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default} Renderer
     */
    PluggableMap.prototype.getRenderer = function () {
        return this.renderer_;
    };
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    PluggableMap.prototype.getSize = function () {
        return /** @type {import("./size.js").Size|undefined} */ (this.get(MapProperty["a" /* default */].SIZE));
    };
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */
    PluggableMap.prototype.getView = function () {
        return /** @type {View} */ (this.get(MapProperty["a" /* default */].VIEW));
    };
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */
    PluggableMap.prototype.getViewport = function () {
        return this.viewport_;
    };
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */
    PluggableMap.prototype.getOverlayContainer = function () {
        return this.overlayContainer_;
    };
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */
    PluggableMap.prototype.getOverlayContainerStopEvent = function () {
        return this.overlayContainerStopEvent_;
    };
    /**
     * @return {!Document} The document where the map is displayed.
     */
    PluggableMap.prototype.getOwnerDocument = function () {
        var targetElement = this.getTargetElement();
        return targetElement ? targetElement.ownerDocument : document;
    };
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
    PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
        return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
    };
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [opt_type] Type.
     */
    PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
        var type = opt_type || browserEvent.type;
        var mapBrowserEvent = new MapBrowserEvent["a" /* default */](type, this, browserEvent);
        this.handleMapBrowserEvent(mapBrowserEvent);
    };
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */
    PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
        if (!this.frameState_) {
            // With no view defined, we cannot translate pixels into geographical
            // coordinates so interactions cannot be used.
            return;
        }
        var originalEvent = /** @type {PointerEvent} */ (mapBrowserEvent.originalEvent);
        var eventType = originalEvent.type;
        if (eventType === pointer_EventType.POINTERDOWN ||
            eventType === events_EventType["a" /* default */].WHEEL ||
            eventType === events_EventType["a" /* default */].KEYDOWN) {
            var doc = this.getOwnerDocument();
            var rootNode = this.viewport_.getRootNode
                ? this.viewport_.getRootNode()
                : doc;
            var target = /** @type {Node} */ (originalEvent.target);
            if (
            // Abort if the target is a child of the container for elements whose events are not meant
            // to be handled by map interactions.
            this.overlayContainerStopEvent_.contains(target) ||
                // Abort if the event target is a child of the container that is no longer in the page.
                // It's possible for the target to no longer be in the page if it has been removed in an
                // event listener, this might happen in a Control that recreates it's content based on
                // user interaction either manually or via a render in something like https://reactjs.org/
                !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
                return;
            }
        }
        mapBrowserEvent.frameState = this.frameState_;
        if (this.dispatchEvent(mapBrowserEvent) !== false) {
            var interactionsArray = this.getInteractions().getArray().slice();
            for (var i = interactionsArray.length - 1; i >= 0; i--) {
                var interaction = interactionsArray[i];
                if (interaction.getMap() !== this ||
                    !interaction.getActive() ||
                    !this.getTargetElement()) {
                    continue;
                }
                var cont = interaction.handleEvent(mapBrowserEvent);
                if (!cont || mapBrowserEvent.propagationStopped) {
                    break;
                }
            }
        }
    };
    /**
     * @protected
     */
    PluggableMap.prototype.handlePostRender = function () {
        var frameState = this.frameState_;
        // Manage the tile queue
        // Image loads are expensive and a limited resource, so try to use them
        // efficiently:
        // * When the view is static we allow a large number of parallel tile loads
        //   to complete the frame as quickly as possible.
        // * When animating or interacting, image loads can cause janks, so we reduce
        //   the maximum number of loads per frame and limit the number of parallel
        //   tile loads to remain reactive to view changes and to reduce the chance of
        //   loading tiles that will quickly disappear from view.
        var tileQueue = this.tileQueue_;
        if (!tileQueue.isEmpty()) {
            var maxTotalLoading = this.maxTilesLoading_;
            var maxNewLoads = maxTotalLoading;
            if (frameState) {
                var hints = frameState.viewHints;
                if (hints[ViewHint["a" /* default */].ANIMATING] || hints[ViewHint["a" /* default */].INTERACTING]) {
                    var lowOnFrameBudget = Date.now() - frameState.time > 8;
                    maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                    maxNewLoads = lowOnFrameBudget ? 0 : 2;
                }
            }
            if (tileQueue.getTilesLoading() < maxTotalLoading) {
                tileQueue.reprioritize(); // FIXME only call if view has changed
                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
            }
        }
        if (frameState &&
            this.hasListener(EventType["a" /* default */].RENDERCOMPLETE) &&
            !frameState.animate &&
            this.renderComplete_) {
            this.renderer_.dispatchRenderEvent(EventType["a" /* default */].RENDERCOMPLETE, frameState);
        }
        var postRenderFunctions = this.postRenderFunctions_;
        for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
            postRenderFunctions[i](this, frameState);
        }
        postRenderFunctions.length = 0;
    };
    /**
     * @private
     */
    PluggableMap.prototype.handleSizeChanged_ = function () {
        if (this.getView() && !this.getView().getAnimating()) {
            this.getView().resolveConstraints(0);
        }
        this.render();
    };
    /**
     * @private
     */
    PluggableMap.prototype.handleTargetChanged_ = function () {
        if (this.mapBrowserEventHandler_) {
            for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
                Object(events["c" /* unlistenByKey */])(this.targetChangeHandlerKeys_[i]);
            }
            this.targetChangeHandlerKeys_ = null;
            this.viewport_.removeEventListener(events_EventType["a" /* default */].CONTEXTMENU, this.boundHandleBrowserEvent_);
            this.viewport_.removeEventListener(events_EventType["a" /* default */].WHEEL, this.boundHandleBrowserEvent_);
            this.mapBrowserEventHandler_.dispose();
            this.mapBrowserEventHandler_ = null;
            Object(dom["e" /* removeNode */])(this.viewport_);
        }
        // target may be undefined, null, a string or an Element.
        // If it's a string we convert it to an Element before proceeding.
        // If it's not now an Element we remove the viewport from the DOM.
        // If it's an Element we append the viewport element to it.
        var targetElement = this.getTargetElement();
        if (!targetElement) {
            if (this.renderer_) {
                clearTimeout(this.postRenderTimeoutHandle_);
                this.postRenderTimeoutHandle_ = undefined;
                this.postRenderFunctions_.length = 0;
                this.renderer_.dispose();
                this.renderer_ = null;
            }
            if (this.animationDelayKey_) {
                cancelAnimationFrame(this.animationDelayKey_);
                this.animationDelayKey_ = undefined;
            }
        }
        else {
            targetElement.appendChild(this.viewport_);
            if (!this.renderer_) {
                this.renderer_ = this.createRenderer();
            }
            this.mapBrowserEventHandler_ = new ol_MapBrowserEventHandler(this, this.moveTolerance_);
            for (var key in MapBrowserEventType["a" /* default */]) {
                this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType["a" /* default */][key], this.handleMapBrowserEvent.bind(this));
            }
            this.viewport_.addEventListener(events_EventType["a" /* default */].CONTEXTMENU, this.boundHandleBrowserEvent_, false);
            this.viewport_.addEventListener(events_EventType["a" /* default */].WHEEL, this.boundHandleBrowserEvent_, has["e" /* PASSIVE_EVENT_LISTENERS */] ? { passive: false } : false);
            var defaultView = this.getOwnerDocument().defaultView;
            var keyboardEventTarget = !this.keyboardEventTarget_
                ? targetElement
                : this.keyboardEventTarget_;
            this.targetChangeHandlerKeys_ = [
                Object(events["a" /* listen */])(keyboardEventTarget, events_EventType["a" /* default */].KEYDOWN, this.handleBrowserEvent, this),
                Object(events["a" /* listen */])(keyboardEventTarget, events_EventType["a" /* default */].KEYPRESS, this.handleBrowserEvent, this),
                Object(events["a" /* listen */])(defaultView, events_EventType["a" /* default */].RESIZE, this.updateSize, this),
            ];
        }
        this.updateSize();
        // updateSize calls setSize, so no need to call this.render
        // ourselves here.
    };
    /**
     * @private
     */
    PluggableMap.prototype.handleTileChange_ = function () {
        this.render();
    };
    /**
     * @private
     */
    PluggableMap.prototype.handleViewPropertyChanged_ = function () {
        this.render();
    };
    /**
     * @private
     */
    PluggableMap.prototype.handleViewChanged_ = function () {
        if (this.viewPropertyListenerKey_) {
            Object(events["c" /* unlistenByKey */])(this.viewPropertyListenerKey_);
            this.viewPropertyListenerKey_ = null;
        }
        if (this.viewChangeListenerKey_) {
            Object(events["c" /* unlistenByKey */])(this.viewChangeListenerKey_);
            this.viewChangeListenerKey_ = null;
        }
        var view = this.getView();
        if (view) {
            this.updateViewportSize_();
            this.viewPropertyListenerKey_ = Object(events["a" /* listen */])(view, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
            this.viewChangeListenerKey_ = Object(events["a" /* listen */])(view, events_EventType["a" /* default */].CHANGE, this.handleViewPropertyChanged_, this);
            view.resolveConstraints(0);
        }
        this.render();
    };
    /**
     * @private
     */
    PluggableMap.prototype.handleLayerGroupChanged_ = function () {
        if (this.layerGroupPropertyListenerKeys_) {
            this.layerGroupPropertyListenerKeys_.forEach(events["c" /* unlistenByKey */]);
            this.layerGroupPropertyListenerKeys_ = null;
        }
        var layerGroup = this.getLayerGroup();
        if (layerGroup) {
            this.handleLayerAdd_(new GroupEvent('addlayer', layerGroup));
            this.layerGroupPropertyListenerKeys_ = [
                Object(events["a" /* listen */])(layerGroup, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.render, this),
                Object(events["a" /* listen */])(layerGroup, events_EventType["a" /* default */].CHANGE, this.render, this),
                Object(events["a" /* listen */])(layerGroup, 'addlayer', this.handleLayerAdd_, this),
                Object(events["a" /* listen */])(layerGroup, 'removelayer', this.handleLayerRemove_, this),
            ];
        }
        this.render();
    };
    /**
     * @return {boolean} Is rendered.
     */
    PluggableMap.prototype.isRendered = function () {
        return !!this.frameState_;
    };
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */
    PluggableMap.prototype.renderSync = function () {
        if (this.animationDelayKey_) {
            cancelAnimationFrame(this.animationDelayKey_);
        }
        this.animationDelay_();
    };
    /**
     * Redraws all text after new fonts have loaded
     */
    PluggableMap.prototype.redrawText = function () {
        var layerStates = this.getLayerGroup().getLayerStatesArray();
        for (var i = 0, ii = layerStates.length; i < ii; ++i) {
            var layer = layerStates[i].layer;
            if (layer.hasRenderer()) {
                layer.getRenderer().handleFontsChanged();
            }
        }
    };
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */
    PluggableMap.prototype.render = function () {
        if (this.renderer_ && this.animationDelayKey_ === undefined) {
            this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
        }
    };
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */
    PluggableMap.prototype.removeControl = function (control) {
        return this.getControls().remove(control);
    };
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */
    PluggableMap.prototype.removeInteraction = function (interaction) {
        return this.getInteractions().remove(interaction);
    };
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */
    PluggableMap.prototype.removeLayer = function (layer) {
        var layers = this.getLayerGroup().getLayers();
        return layers.remove(layer);
    };
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */
    PluggableMap.prototype.handleLayerRemove_ = function (event) {
        removeLayerMapProperty(event.layer);
    };
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */
    PluggableMap.prototype.removeOverlay = function (overlay) {
        return this.getOverlays().remove(overlay);
    };
    /**
     * @param {number} time Time.
     * @private
     */
    PluggableMap.prototype.renderFrame_ = function (time) {
        var _this = this;
        var size = this.getSize();
        var view = this.getView();
        var previousFrameState = this.frameState_;
        /** @type {?FrameState} */
        var frameState = null;
        if (size !== undefined && Object(ol_size["a" /* hasArea */])(size) && view && view.isDef()) {
            var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
            var viewState = view.getState();
            frameState = {
                animate: false,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: Object(extent["y" /* getForViewAndSize */])(viewState.center, viewState.resolution, viewState.rotation, size),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: size,
                tileQueue: this.tileQueue_,
                time: time,
                usedTiles: {},
                viewState: viewState,
                viewHints: viewHints,
                wantedTiles: {},
                mapId: Object(util["c" /* getUid */])(this),
                renderTargets: {},
            };
            if (viewState.nextCenter && viewState.nextResolution) {
                var rotation = isNaN(viewState.nextRotation)
                    ? viewState.rotation
                    : viewState.nextRotation;
                frameState.nextExtent = Object(extent["y" /* getForViewAndSize */])(viewState.nextCenter, viewState.nextResolution, rotation, size);
            }
        }
        this.frameState_ = frameState;
        this.renderer_.renderFrame(frameState);
        if (frameState) {
            if (frameState.animate) {
                this.render();
            }
            Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
            if (previousFrameState) {
                var moveStart = !this.previousExtent_ ||
                    (!Object(extent["G" /* isEmpty */])(this.previousExtent_) &&
                        !Object(extent["o" /* equals */])(frameState.extent, this.previousExtent_));
                if (moveStart) {
                    this.dispatchEvent(new MapEvent["a" /* default */](MapEventType["a" /* default */].MOVESTART, this, previousFrameState));
                    this.previousExtent_ = Object(extent["l" /* createOrUpdateEmpty */])(this.previousExtent_);
                }
            }
            var idle = this.previousExtent_ &&
                !frameState.viewHints[ViewHint["a" /* default */].ANIMATING] &&
                !frameState.viewHints[ViewHint["a" /* default */].INTERACTING] &&
                !Object(extent["o" /* equals */])(frameState.extent, this.previousExtent_);
            if (idle) {
                this.dispatchEvent(new MapEvent["a" /* default */](MapEventType["a" /* default */].MOVEEND, this, frameState));
                Object(extent["d" /* clone */])(frameState.extent, this.previousExtent_);
            }
        }
        this.dispatchEvent(new MapEvent["a" /* default */](MapEventType["a" /* default */].POSTRENDER, this, frameState));
        this.renderComplete_ =
            !this.tileQueue_.getTilesLoading() &&
                !this.tileQueue_.getCount() &&
                !this.getLoadingOrNotReady();
        if (!this.postRenderTimeoutHandle_) {
            this.postRenderTimeoutHandle_ = setTimeout(function () {
                _this.postRenderTimeoutHandle_ = undefined;
                _this.handlePostRender();
            }, 0);
        }
    };
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */
    PluggableMap.prototype.setLayerGroup = function (layerGroup) {
        var oldLayerGroup = this.getLayerGroup();
        if (oldLayerGroup) {
            this.handleLayerRemove_(new GroupEvent('removelayer', oldLayerGroup));
        }
        this.set(MapProperty["a" /* default */].LAYERGROUP, layerGroup);
    };
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    PluggableMap.prototype.setSize = function (size) {
        this.set(MapProperty["a" /* default */].SIZE, size);
    };
    /**
     * Set the target element to render this map into.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */
    PluggableMap.prototype.setTarget = function (target) {
        this.set(MapProperty["a" /* default */].TARGET, target);
    };
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */
    PluggableMap.prototype.setView = function (view) {
        if (!view || view instanceof View["a" /* default */]) {
            this.set(MapProperty["a" /* default */].VIEW, view);
            return;
        }
        this.set(MapProperty["a" /* default */].VIEW, new View["a" /* default */]());
        var map = this;
        view.then(function (viewOptions) {
            map.setView(new View["a" /* default */](viewOptions));
        });
    };
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */
    PluggableMap.prototype.updateSize = function () {
        var targetElement = this.getTargetElement();
        var size = undefined;
        if (targetElement) {
            var computedStyle = getComputedStyle(targetElement);
            var width = targetElement.offsetWidth -
                parseFloat(computedStyle['borderLeftWidth']) -
                parseFloat(computedStyle['paddingLeft']) -
                parseFloat(computedStyle['paddingRight']) -
                parseFloat(computedStyle['borderRightWidth']);
            var height = targetElement.offsetHeight -
                parseFloat(computedStyle['borderTopWidth']) -
                parseFloat(computedStyle['paddingTop']) -
                parseFloat(computedStyle['paddingBottom']) -
                parseFloat(computedStyle['borderBottomWidth']);
            if (!isNaN(width) && !isNaN(height)) {
                size = [width, height];
                if (!Object(ol_size["a" /* hasArea */])(size) &&
                    !!(targetElement.offsetWidth ||
                        targetElement.offsetHeight ||
                        targetElement.getClientRects().length)) {
                    // eslint-disable-next-line
                    console.warn("No map visible because the map container's width or height are 0.");
                }
            }
        }
        this.setSize(size);
        this.updateViewportSize_();
    };
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @private
     */
    PluggableMap.prototype.updateViewportSize_ = function () {
        var view = this.getView();
        if (view) {
            var size = undefined;
            var computedStyle = getComputedStyle(this.viewport_);
            if (computedStyle.width && computedStyle.height) {
                size = [
                    parseInt(computedStyle.width, 10),
                    parseInt(computedStyle.height, 10),
                ];
            }
            view.setViewportSize(size);
        }
    };
    return PluggableMap;
}(ol_Object["a" /* default */]));
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */
function createOptionsInternal(options) {
    /**
     * @type {HTMLElement|Document}
     */
    var keyboardEventTarget = null;
    if (options.keyboardEventTarget !== undefined) {
        keyboardEventTarget =
            typeof options.keyboardEventTarget === 'string'
                ? document.getElementById(options.keyboardEventTarget)
                : options.keyboardEventTarget;
    }
    /**
     * @type {Object<string, *>}
     */
    var values = {};
    var layerGroup = options.layers &&
        typeof ( /** @type {?} */(options.layers).getLayers) === 'function'
        ? /** @type {LayerGroup} */ (options.layers)
        : new Group({ layers: /** @type {Collection} */ (options.layers) });
    values[MapProperty["a" /* default */].LAYERGROUP] = layerGroup;
    values[MapProperty["a" /* default */].TARGET] = options.target;
    values[MapProperty["a" /* default */].VIEW] =
        options.view instanceof View["a" /* default */] ? options.view : new View["a" /* default */]();
    var controls;
    if (options.controls !== undefined) {
        if (Array.isArray(options.controls)) {
            controls = new Collection["a" /* default */](options.controls.slice());
        }
        else {
            Object(asserts["a" /* assert */])(typeof ( /** @type {?} */(options.controls).getArray) === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
            controls = /** @type {Collection} */ (options.controls);
        }
    }
    var interactions;
    if (options.interactions !== undefined) {
        if (Array.isArray(options.interactions)) {
            interactions = new Collection["a" /* default */](options.interactions.slice());
        }
        else {
            Object(asserts["a" /* assert */])(typeof ( /** @type {?} */(options.interactions).getArray) ===
                'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
            interactions = /** @type {Collection} */ (options.interactions);
        }
    }
    var overlays;
    if (options.overlays !== undefined) {
        if (Array.isArray(options.overlays)) {
            overlays = new Collection["a" /* default */](options.overlays.slice());
        }
        else {
            Object(asserts["a" /* assert */])(typeof ( /** @type {?} */(options.overlays).getArray) === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
            overlays = options.overlays;
        }
    }
    else {
        overlays = new Collection["a" /* default */]();
    }
    return {
        controls: controls,
        interactions: interactions,
        keyboardEventTarget: keyboardEventTarget,
        overlays: overlays,
        values: values,
    };
}
/* harmony default export */ var ol_PluggableMap = (PluggableMap_PluggableMap);
//# sourceMappingURL=PluggableMap.js.map
// EXTERNAL MODULE: ./node_modules/ol/control.js + 3 modules
var control = __webpack_require__("21bc");

// EXTERNAL MODULE: ./node_modules/ol/interaction.js + 13 modules
var ol_interaction = __webpack_require__("3a39");

// CONCATENATED MODULE: ./node_modules/ol/Map.js
var Map_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Map
 */





/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @api
 */
var Map_Map = /** @class */ (function (_super) {
    Map_extends(Map, _super);
    /**
     * @param {import("./PluggableMap.js").MapOptions} options Map options.
     */
    function Map(options) {
        options = Object(obj["a" /* assign */])({}, options);
        if (!options.controls) {
            options.controls = Object(control["a" /* defaults */])();
        }
        if (!options.interactions) {
            options.interactions = Object(ol_interaction["a" /* defaults */])({
                onFocusOnly: true,
            });
        }
        return _super.call(this, options) || this;
    }
    Map.prototype.createRenderer = function () {
        return new Composite(this);
    };
    return Map;
}(ol_PluggableMap));
/* harmony default export */ var ol_Map = __webpack_exports__["a"] = (Map_Map);
//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "605d":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");
var global = __webpack_require__("da84");

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ "6069":
/***/ (function(module, exports) {

module.exports = typeof window == 'object';


/***/ }),

/***/ "617d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FIREFOX; });
/* unused harmony export SAFARI */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return WEBKIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return MAC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEVICE_PIXEL_RATIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return WORKER_OFFSCREEN_CANVAS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return IMAGE_DECODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return PASSIVE_EVENT_LISTENERS; });
/**
 * @module ol/has
 */
var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
    ? navigator.userAgent.toLowerCase()
    : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
var FIREFOX = ua.indexOf('firefox') !== -1;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
var MAC = ua.indexOf('macintosh') !== -1;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' &&
    typeof OffscreenCanvas !== 'undefined' &&
    self instanceof WorkerGlobalScope; //eslint-disable-line
/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */
var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
/**
 * @type {boolean}
 */
var PASSIVE_EVENT_LISTENERS = (function () {
    var passive = false;
    try {
        var options = Object.defineProperty({}, 'passive', {
            get: function () {
                passive = true;
            },
        });
        window.addEventListener('_', null, options);
        window.removeEventListener('_', null, options);
    }
    catch (error) {
        // passive not supported
    }
    return passive;
})();
//# sourceMappingURL=has.js.map

/***/ }),

/***/ "6547":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toIntegerOrInfinity = __webpack_require__("5926");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "65f0":
/***/ (function(module, exports, __webpack_require__) {

var arraySpeciesConstructor = __webpack_require__("0b42");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "6611":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return listenImage; });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("01d4");
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8778");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("869f");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("617d");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0af5");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("1e8d");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Image
 */






/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */
var ImageWrapper = /** @class */ (function (_super) {
    __extends(ImageWrapper, _super);
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number|undefined} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {LoadFunction} imageLoadFunction Image load function.
     */
    function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
        var _this = _super.call(this, extent, resolution, pixelRatio, _ImageState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].IDLE) || this;
        /**
         * @private
         * @type {string}
         */
        _this.src_ = src;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
         */
        _this.image_ = new Image();
        if (crossOrigin !== null) {
            _this.image_.crossOrigin = crossOrigin;
        }
        /**
         * @private
         * @type {?function():void}
         */
        _this.unlisten_ = null;
        /**
         * @protected
         * @type {import("./ImageState.js").default}
         */
        _this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].IDLE;
        /**
         * @private
         * @type {LoadFunction}
         */
        _this.imageLoadFunction_ = imageLoadFunction;
        return _this;
    }
    /**
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */
    ImageWrapper.prototype.getImage = function () {
        return this.image_;
    };
    /**
     * Tracks loading or read errors.
     *
     * @private
     */
    ImageWrapper.prototype.handleImageError_ = function () {
        this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ERROR;
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Tracks successful image load.
     *
     * @private
     */
    ImageWrapper.prototype.handleImageLoad_ = function () {
        if (this.resolution === undefined) {
            this.resolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* getHeight */ "z"])(this.extent) / this.image_.height;
        }
        this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOADED;
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @api
     */
    ImageWrapper.prototype.load = function () {
        if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].IDLE || this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ERROR) {
            this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOADING;
            this.changed();
            this.imageLoadFunction_(this, this.src_);
            this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    };
    /**
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
     */
    ImageWrapper.prototype.setImage = function (image) {
        this.image_ = image;
        this.resolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* getHeight */ "z"])(this.extent) / this.image_.height;
    };
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
    ImageWrapper.prototype.unlistenImage_ = function () {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    };
    return ImageWrapper;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]));
/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */
function listenImage(image, loadHandler, errorHandler) {
    var img = /** @type {HTMLImageElement} */ (image);
    var listening = true;
    var decoding = false;
    var loaded = false;
    var listenerKeys = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_5__[/* listenOnce */ "b"])(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LOAD, function () {
            loaded = true;
            if (!decoding) {
                loadHandler();
            }
        }),
    ];
    if (img.src && _has_js__WEBPACK_IMPORTED_MODULE_3__[/* IMAGE_DECODE */ "c"]) {
        decoding = true;
        img
            .decode()
            .then(function () {
            if (listening) {
                loadHandler();
            }
        })
            .catch(function (error) {
            if (listening) {
                if (loaded) {
                    loadHandler();
                }
                else {
                    errorHandler();
                }
            }
        });
    }
    else {
        listenerKeys.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_5__[/* listenOnce */ "b"])(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].ERROR, errorHandler));
    }
    return function unlisten() {
        listening = false;
        listenerKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_5__[/* unlistenByKey */ "c"]);
    };
}
/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);
//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "68ee":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");
var classof = __webpack_require__("f5df");
var getBuiltIn = __webpack_require__("d066");
var inspectSource = __webpack_require__("8925");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "69b7":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "69f3":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var isObject = __webpack_require__("861d");
var createNonEnumerableProperty = __webpack_require__("9112");
var hasOwn = __webpack_require__("1a2d");
var shared = __webpack_require__("c6cd");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "6b08":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "6c77":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return toFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createDefaultStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createEditingStyle; });
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ce2c");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("83a6");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("f623");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("8682");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("92fa");
/**
 * @module ol/style/Style
 */





/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */
/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */
/**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */
/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
 * RenderFunction
 */
/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */
/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import GeometryType from 'ol/geom/GeometryType';
 *  import {Circle, Fill, Stroke, Style} from 'ol/style';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
 *
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
 *
 *  styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(
 *    styles[GeometryType.LINE_STRING]
 *  );
 *
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
 *
 *  styles[GeometryType.GEOMETRY_COLLECTION] = styles[
 *    GeometryType.POLYGON
 *  ].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
 * ```
 *
 * @api
 */
var Style = /** @class */ (function () {
    /**
     * @param {Options} [opt_options] Style options.
     */
    function Style(opt_options) {
        var options = opt_options || {};
        /**
         * @private
         * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
         */
        this.geometry_ = null;
        /**
         * @private
         * @type {!GeometryFunction}
         */
        this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== undefined) {
            this.setGeometry(options.geometry);
        }
        /**
         * @private
         * @type {import("./Fill.js").default}
         */
        this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
         * @private
         * @type {import("./Image.js").default}
         */
        this.image_ = options.image !== undefined ? options.image : null;
        /**
         * @private
         * @type {RenderFunction|null}
         */
        this.renderer_ = options.renderer !== undefined ? options.renderer : null;
        /**
         * @private
         * @type {RenderFunction|null}
         */
        this.hitDetectionRenderer_ =
            options.hitDetectionRenderer !== undefined
                ? options.hitDetectionRenderer
                : null;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */
        this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
         * @private
         * @type {import("./Text.js").default}
         */
        this.text_ = options.text !== undefined ? options.text : null;
        /**
         * @private
         * @type {number|undefined}
         */
        this.zIndex_ = options.zIndex;
    }
    /**
     * Clones the style.
     * @return {Style} The cloned style.
     * @api
     */
    Style.prototype.clone = function () {
        var geometry = this.getGeometry();
        if (geometry && typeof geometry === 'object') {
            geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
        }
        return new Style({
            geometry: geometry,
            fill: this.getFill() ? this.getFill().clone() : undefined,
            image: this.getImage() ? this.getImage().clone() : undefined,
            renderer: this.getRenderer(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            text: this.getText() ? this.getText().clone() : undefined,
            zIndex: this.getZIndex(),
        });
    };
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    Style.prototype.getRenderer = function () {
        return this.renderer_;
    };
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    Style.prototype.setRenderer = function (renderer) {
        this.renderer_ = renderer;
    };
    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    Style.prototype.setHitDetectionRenderer = function (renderer) {
        this.hitDetectionRenderer_ = renderer;
    };
    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    Style.prototype.getHitDetectionRenderer = function () {
        return this.hitDetectionRenderer_;
    };
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
    Style.prototype.getGeometry = function () {
        return this.geometry_;
    };
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
    Style.prototype.getGeometryFunction = function () {
        return this.geometryFunction_;
    };
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    Style.prototype.getFill = function () {
        return this.fill_;
    };
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */
    Style.prototype.setFill = function (fill) {
        this.fill_ = fill;
    };
    /**
     * Get the image style.
     * @return {import("./Image.js").default} Image style.
     * @api
     */
    Style.prototype.getImage = function () {
        return this.image_;
    };
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */
    Style.prototype.setImage = function (image) {
        this.image_ = image;
    };
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    Style.prototype.getStroke = function () {
        return this.stroke_;
    };
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */
    Style.prototype.setStroke = function (stroke) {
        this.stroke_ = stroke;
    };
    /**
     * Get the text style.
     * @return {import("./Text.js").default} Text style.
     * @api
     */
    Style.prototype.getText = function () {
        return this.text_;
    };
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */
    Style.prototype.setText = function (text) {
        this.text_ = text;
    };
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
    Style.prototype.getZIndex = function () {
        return this.zIndex_;
    };
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */
    Style.prototype.setGeometry = function (geometry) {
        if (typeof geometry === 'function') {
            this.geometryFunction_ = geometry;
        }
        else if (typeof geometry === 'string') {
            this.geometryFunction_ = function (feature) {
                return /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry));
            };
        }
        else if (!geometry) {
            this.geometryFunction_ = defaultGeometryFunction;
        }
        else if (geometry !== undefined) {
            this.geometryFunction_ = function () {
                return /** @type {import("../geom/Geometry.js").default} */ (geometry);
            };
        }
        this.geometry_ = geometry;
    };
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
    Style.prototype.setZIndex = function (zIndex) {
        this.zIndex_ = zIndex;
    };
    return Style;
}());
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
    var styleFunction;
    if (typeof obj === 'function') {
        styleFunction = obj;
    }
    else {
        /**
         * @type {Array<Style>}
         */
        var styles_1;
        if (Array.isArray(obj)) {
            styles_1 = obj;
        }
        else {
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_4__[/* assert */ "a"])(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `Style` or an array of `Style`
            var style = /** @type {Style} */ (obj);
            styles_1 = [style];
        }
        styleFunction = function () {
            return styles_1;
        };
    }
    return styleFunction;
}
/**
 * @type {Array<Style>|null}
 */
var defaultStyles = null;
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
    // We don't use an immediately-invoked function
    // and a closure so we don't get an error at script evaluation time in
    // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
    // canvas.getContext('2d') at construction time, which will cause an.error
    // in such browsers.)
    if (!defaultStyles) {
        var fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]({
            color: 'rgba(255,255,255,0.4)',
        });
        var stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({
            color: '#3399CC',
            width: 1.25,
        });
        defaultStyles = [
            new Style({
                image: new _Circle_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]({
                    fill: fill,
                    stroke: stroke,
                    radius: 5,
                }),
                fill: fill,
                stroke: stroke,
            }),
        ];
    }
    return defaultStyles;
}
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */
function createEditingStyle() {
    /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
    var styles = {};
    var white = [255, 255, 255, 1];
    var blue = [0, 153, 255, 1];
    var width = 3;
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].POLYGON] = [
        new Style({
            fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]({
                color: [255, 255, 255, 0.5],
            }),
        }),
    ];
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MULTI_POLYGON] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].POLYGON];
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LINE_STRING] = [
        new Style({
            stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({
                color: white,
                width: width + 2,
            }),
        }),
        new Style({
            stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({
                color: blue,
                width: width,
            }),
        }),
    ];
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MULTI_LINE_STRING] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LINE_STRING];
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].CIRCLE] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].POLYGON].concat(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LINE_STRING]);
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].POINT] = [
        new Style({
            image: new _Circle_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]({
                radius: width * 2,
                fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]({
                    color: blue,
                }),
                stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({
                    color: white,
                    width: width / 2,
                }),
            }),
            zIndex: Infinity,
        }),
    ];
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MULTI_POINT] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].POINT];
    styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].GEOMETRY_COLLECTION] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].POLYGON].concat(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LINE_STRING], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].POINT]);
    return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
    return feature.getGeometry();
}
/* harmony default export */ __webpack_exports__["c"] = (Style);
//# sourceMappingURL=Style.js.map

/***/ }),

/***/ "6cbf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js
var EventType = __webpack_require__("01d4");

// EXTERNAL MODULE: ./node_modules/ol/style/IconAnchorUnits.js
var IconAnchorUnits = __webpack_require__("82b0");

// EXTERNAL MODULE: ./node_modules/ol/style/IconOrigin.js
var IconOrigin = __webpack_require__("d202");

// EXTERNAL MODULE: ./node_modules/ol/ImageState.js
var ImageState = __webpack_require__("869f");

// EXTERNAL MODULE: ./node_modules/ol/style/Image.js
var style_Image = __webpack_require__("ab35");

// EXTERNAL MODULE: ./node_modules/ol/color.js
var ol_color = __webpack_require__("5c38");

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__("92fa");

// EXTERNAL MODULE: ./node_modules/ol/events/Target.js
var Target = __webpack_require__("0ec0");

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__("0999");

// EXTERNAL MODULE: ./node_modules/ol/style/IconImageCache.js
var IconImageCache = __webpack_require__("3c22");

// EXTERNAL MODULE: ./node_modules/ol/Image.js
var ol_Image = __webpack_require__("6611");

// CONCATENATED MODULE: ./node_modules/ol/style/IconImage.js
/**
 * @module ol/style/IconImage
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







/**
 * @type {CanvasRenderingContext2D}
 */
var taintedTestContext = null;
var IconImage_IconImage = /** @class */ (function (_super) {
    __extends(IconImage, _super);
    /**
     * @param {HTMLImageElement|HTMLCanvasElement} image Image.
     * @param {string|undefined} src Src.
     * @param {import("../size.js").Size} size Size.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default} imageState Image state.
     * @param {import("../color.js").Color} color Color.
     */
    function IconImage(image, src, size, crossOrigin, imageState, color) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {HTMLImageElement|HTMLCanvasElement}
         */
        _this.hitDetectionImage_ = null;
        /**
         * @private
         * @type {HTMLImageElement|HTMLCanvasElement}
         */
        _this.image_ = !image ? new Image() : image;
        if (crossOrigin !== null) {
            /** @type {HTMLImageElement} */ (_this.image_).crossOrigin = crossOrigin;
        }
        /**
         * @private
         * @type {Object<number, HTMLCanvasElement>}
         */
        _this.canvas_ = {};
        /**
         * @private
         * @type {import("../color.js").Color}
         */
        _this.color_ = color;
        /**
         * @private
         * @type {?function():void}
         */
        _this.unlisten_ = null;
        /**
         * @private
         * @type {import("../ImageState.js").default}
         */
        _this.imageState_ = imageState;
        /**
         * @private
         * @type {import("../size.js").Size}
         */
        _this.size_ = size;
        /**
         * @private
         * @type {string|undefined}
         */
        _this.src_ = src;
        /**
         * @private
         */
        _this.tainted_;
        return _this;
    }
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */
    IconImage.prototype.isTainted_ = function () {
        if (this.tainted_ === undefined && this.imageState_ === ImageState["a" /* default */].LOADED) {
            if (!taintedTestContext) {
                taintedTestContext = Object(dom["a" /* createCanvasContext2D */])(1, 1);
            }
            taintedTestContext.drawImage(this.image_, 0, 0);
            try {
                taintedTestContext.getImageData(0, 0, 1, 1);
                this.tainted_ = false;
            }
            catch (e) {
                taintedTestContext = null;
                this.tainted_ = true;
            }
        }
        return this.tainted_ === true;
    };
    /**
     * @private
     */
    IconImage.prototype.dispatchChangeEvent_ = function () {
        this.dispatchEvent(EventType["a" /* default */].CHANGE);
    };
    /**
     * @private
     */
    IconImage.prototype.handleImageError_ = function () {
        this.imageState_ = ImageState["a" /* default */].ERROR;
        this.unlistenImage_();
        this.dispatchChangeEvent_();
    };
    /**
     * @private
     */
    IconImage.prototype.handleImageLoad_ = function () {
        this.imageState_ = ImageState["a" /* default */].LOADED;
        if (this.size_) {
            this.image_.width = this.size_[0];
            this.image_.height = this.size_[1];
        }
        else {
            this.size_ = [this.image_.width, this.image_.height];
        }
        this.unlistenImage_();
        this.dispatchChangeEvent_();
    };
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
     */
    IconImage.prototype.getImage = function (pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    };
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */
    IconImage.prototype.getPixelRatio = function (pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
    };
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    IconImage.prototype.getImageState = function () {
        return this.imageState_;
    };
    /**
     * @return {HTMLImageElement|HTMLCanvasElement} Image element.
     */
    IconImage.prototype.getHitDetectionImage = function () {
        if (!this.hitDetectionImage_) {
            if (this.isTainted_()) {
                var width = this.size_[0];
                var height = this.size_[1];
                var context = Object(dom["a" /* createCanvasContext2D */])(width, height);
                context.fillRect(0, 0, width, height);
                this.hitDetectionImage_ = context.canvas;
            }
            else {
                this.hitDetectionImage_ = this.image_;
            }
        }
        return this.hitDetectionImage_;
    };
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */
    IconImage.prototype.getSize = function () {
        return this.size_;
    };
    /**
     * @return {string|undefined} Image src.
     */
    IconImage.prototype.getSrc = function () {
        return this.src_;
    };
    /**
     * Load not yet loaded URI.
     */
    IconImage.prototype.load = function () {
        if (this.imageState_ == ImageState["a" /* default */].IDLE) {
            this.imageState_ = ImageState["a" /* default */].LOADING;
            try {
                /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
            }
            catch (e) {
                this.handleImageError_();
            }
            this.unlisten_ = Object(ol_Image["b" /* listenImage */])(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    };
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */
    IconImage.prototype.replaceColor_ = function (pixelRatio) {
        if (!this.color_ ||
            this.canvas_[pixelRatio] ||
            this.imageState_ !== ImageState["a" /* default */].LOADED) {
            return;
        }
        var canvas = document.createElement('canvas');
        this.canvas_[pixelRatio] = canvas;
        canvas.width = Math.ceil(this.image_.width * pixelRatio);
        canvas.height = Math.ceil(this.image_.height * pixelRatio);
        var ctx = canvas.getContext('2d');
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(this.image_, 0, 0);
        ctx.globalCompositeOperation = 'multiply';
        // Internet Explorer 11 does not support the multiply operation.
        // If the canvas is tainted in Internet Explorer this still produces
        // a solid color image with the shape of the icon.
        if (ctx.globalCompositeOperation === 'multiply' || this.isTainted_()) {
            ctx.fillStyle = Object(ol_color["b" /* asString */])(this.color_);
            ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
            ctx.globalCompositeOperation = 'destination-in';
            ctx.drawImage(this.image_, 0, 0);
        }
        else {
            var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imgData.data;
            var r = this.color_[0] / 255.0;
            var g = this.color_[1] / 255.0;
            var b = this.color_[2] / 255.0;
            var a = this.color_[3];
            for (var i = 0, ii = data.length; i < ii; i += 4) {
                data[i] *= r;
                data[i + 1] *= g;
                data[i + 2] *= b;
                data[i + 3] *= a;
            }
            ctx.putImageData(imgData, 0, 0);
        }
    };
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
    IconImage.prototype.unlistenImage_ = function () {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    };
    return IconImage;
}(Target["a" /* default */]));
/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */
function get(image, src, size, crossOrigin, imageState, color) {
    var iconImage = IconImageCache["a" /* shared */].get(src, crossOrigin, color);
    if (!iconImage) {
        iconImage = new IconImage_IconImage(image, src, size, crossOrigin, imageState, color);
        IconImageCache["a" /* shared */].set(src, crossOrigin, color, iconImage);
    }
    return iconImage;
}
/* harmony default export */ var style_IconImage = (IconImage_IconImage);
//# sourceMappingURL=IconImage.js.map
// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// CONCATENATED MODULE: ./node_modules/ol/style/Icon.js
var Icon_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/style/Icon
 */









/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [displacement=[0,0]] Displacement of the icon.
 * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
 * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
 * @property {string} [src] Image source URI.
 */
/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
var Icon_Icon = /** @class */ (function (_super) {
    Icon_extends(Icon, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function Icon(opt_options) {
        var _this = this;
        var options = opt_options || {};
        /**
         * @type {number}
         */
        var opacity = options.opacity !== undefined ? options.opacity : 1;
        /**
         * @type {number}
         */
        var rotation = options.rotation !== undefined ? options.rotation : 0;
        /**
         * @type {number|import("../size.js").Size}
         */
        var scale = options.scale !== undefined ? options.scale : 1;
        /**
         * @type {boolean}
         */
        var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        _this = _super.call(this, {
            opacity: opacity,
            rotation: rotation,
            scale: scale,
            displacement: options.displacement !== undefined ? options.displacement : [0, 0],
            rotateWithView: rotateWithView,
        }) || this;
        /**
         * @private
         * @type {Array<number>}
         */
        _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
        /**
         * @private
         * @type {Array<number>}
         */
        _this.normalizedAnchor_ = null;
        /**
         * @private
         * @type {import("./IconOrigin.js").default}
         */
        _this.anchorOrigin_ =
            options.anchorOrigin !== undefined
                ? options.anchorOrigin
                : IconOrigin["a" /* default */].TOP_LEFT;
        /**
         * @private
         * @type {import("./IconAnchorUnits.js").default}
         */
        _this.anchorXUnits_ =
            options.anchorXUnits !== undefined
                ? options.anchorXUnits
                : IconAnchorUnits["a" /* default */].FRACTION;
        /**
         * @private
         * @type {import("./IconAnchorUnits.js").default}
         */
        _this.anchorYUnits_ =
            options.anchorYUnits !== undefined
                ? options.anchorYUnits
                : IconAnchorUnits["a" /* default */].FRACTION;
        /**
         * @private
         * @type {?string}
         */
        _this.crossOrigin_ =
            options.crossOrigin !== undefined ? options.crossOrigin : null;
        /**
         * @type {HTMLImageElement|HTMLCanvasElement}
         */
        var image = options.img !== undefined ? options.img : null;
        /**
         * @private
         * @type {import("../size.js").Size|undefined}
         */
        _this.imgSize_ = options.imgSize;
        /**
         * @type {string|undefined}
         */
        var src = options.src;
        Object(asserts["a" /* assert */])(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
        Object(asserts["a" /* assert */])(!image || (image && _this.imgSize_), 5); // `imgSize` must be set when `image` is provided
        if ((src === undefined || src.length === 0) && image) {
            src = /** @type {HTMLImageElement} */ (image).src || Object(util["c" /* getUid */])(image);
        }
        Object(asserts["a" /* assert */])(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided
        /**
         * @type {import("../ImageState.js").default}
         */
        var imageState = options.src !== undefined ? ImageState["a" /* default */].IDLE : ImageState["a" /* default */].LOADED;
        /**
         * @private
         * @type {import("../color.js").Color}
         */
        _this.color_ = options.color !== undefined ? Object(ol_color["a" /* asArray */])(options.color) : null;
        /**
         * @private
         * @type {import("./IconImage.js").default}
         */
        _this.iconImage_ = get(image, 
        /** @type {string} */ (src), _this.imgSize_ !== undefined ? _this.imgSize_ : null, _this.crossOrigin_, imageState, _this.color_);
        /**
         * @private
         * @type {Array<number>}
         */
        _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
        /**
         * @private
         * @type {import("./IconOrigin.js").default}
         */
        _this.offsetOrigin_ =
            options.offsetOrigin !== undefined
                ? options.offsetOrigin
                : IconOrigin["a" /* default */].TOP_LEFT;
        /**
         * @private
         * @type {Array<number>}
         */
        _this.origin_ = null;
        /**
         * @private
         * @type {import("../size.js").Size}
         */
        _this.size_ = options.size !== undefined ? options.size : null;
        return _this;
    }
    /**
     * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
     * @return {Icon} The cloned style.
     * @api
     */
    Icon.prototype.clone = function () {
        var scale = this.getScale();
        return new Icon({
            anchor: this.anchor_.slice(),
            anchorOrigin: this.anchorOrigin_,
            anchorXUnits: this.anchorXUnits_,
            anchorYUnits: this.anchorYUnits_,
            color: this.color_ && this.color_.slice
                ? this.color_.slice()
                : this.color_ || undefined,
            crossOrigin: this.crossOrigin_,
            imgSize: this.imgSize_,
            offset: this.offset_.slice(),
            offsetOrigin: this.offsetOrigin_,
            opacity: this.getOpacity(),
            rotateWithView: this.getRotateWithView(),
            rotation: this.getRotation(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            size: this.size_ !== null ? this.size_.slice() : undefined,
            src: this.getSrc(),
        });
    };
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */
    Icon.prototype.getAnchor = function () {
        var anchor = this.normalizedAnchor_;
        if (!anchor) {
            anchor = this.anchor_;
            var size = this.getSize();
            if (this.anchorXUnits_ == IconAnchorUnits["a" /* default */].FRACTION ||
                this.anchorYUnits_ == IconAnchorUnits["a" /* default */].FRACTION) {
                if (!size) {
                    return null;
                }
                anchor = this.anchor_.slice();
                if (this.anchorXUnits_ == IconAnchorUnits["a" /* default */].FRACTION) {
                    anchor[0] *= size[0];
                }
                if (this.anchorYUnits_ == IconAnchorUnits["a" /* default */].FRACTION) {
                    anchor[1] *= size[1];
                }
            }
            if (this.anchorOrigin_ != IconOrigin["a" /* default */].TOP_LEFT) {
                if (!size) {
                    return null;
                }
                if (anchor === this.anchor_) {
                    anchor = this.anchor_.slice();
                }
                if (this.anchorOrigin_ == IconOrigin["a" /* default */].TOP_RIGHT ||
                    this.anchorOrigin_ == IconOrigin["a" /* default */].BOTTOM_RIGHT) {
                    anchor[0] = -anchor[0] + size[0];
                }
                if (this.anchorOrigin_ == IconOrigin["a" /* default */].BOTTOM_LEFT ||
                    this.anchorOrigin_ == IconOrigin["a" /* default */].BOTTOM_RIGHT) {
                    anchor[1] = -anchor[1] + size[1];
                }
            }
            this.normalizedAnchor_ = anchor;
        }
        var displacement = this.getDisplacement();
        return [anchor[0] - displacement[0], anchor[1] + displacement[1]];
    };
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */
    Icon.prototype.setAnchor = function (anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
    };
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */
    Icon.prototype.getColor = function () {
        return this.color_;
    };
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
     * @api
     */
    Icon.prototype.getImage = function (pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
    };
    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     */
    Icon.prototype.getPixelRatio = function (pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
    };
    /**
     * @return {import("../size.js").Size} Image size.
     */
    Icon.prototype.getImageSize = function () {
        return this.iconImage_.getSize();
    };
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    Icon.prototype.getImageState = function () {
        return this.iconImage_.getImageState();
    };
    /**
     * @return {HTMLImageElement|HTMLCanvasElement} Image element.
     */
    Icon.prototype.getHitDetectionImage = function () {
        return this.iconImage_.getHitDetectionImage();
    };
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */
    Icon.prototype.getOrigin = function () {
        if (this.origin_) {
            return this.origin_;
        }
        var offset = this.offset_;
        if (this.offsetOrigin_ != IconOrigin["a" /* default */].TOP_LEFT) {
            var size = this.getSize();
            var iconImageSize = this.iconImage_.getSize();
            if (!size || !iconImageSize) {
                return null;
            }
            offset = offset.slice();
            if (this.offsetOrigin_ == IconOrigin["a" /* default */].TOP_RIGHT ||
                this.offsetOrigin_ == IconOrigin["a" /* default */].BOTTOM_RIGHT) {
                offset[0] = iconImageSize[0] - size[0] - offset[0];
            }
            if (this.offsetOrigin_ == IconOrigin["a" /* default */].BOTTOM_LEFT ||
                this.offsetOrigin_ == IconOrigin["a" /* default */].BOTTOM_RIGHT) {
                offset[1] = iconImageSize[1] - size[1] - offset[1];
            }
        }
        this.origin_ = offset;
        return this.origin_;
    };
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */
    Icon.prototype.getSrc = function () {
        return this.iconImage_.getSrc();
    };
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     */
    Icon.prototype.getSize = function () {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
    };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    Icon.prototype.listenImageChange = function (listener) {
        this.iconImage_.addEventListener(EventType["a" /* default */].CHANGE, listener);
    };
    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     */
    Icon.prototype.load = function () {
        this.iconImage_.load();
    };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    Icon.prototype.unlistenImageChange = function (listener) {
        this.iconImage_.removeEventListener(EventType["a" /* default */].CHANGE, listener);
    };
    return Icon;
}(style_Image["a" /* default */]));
/* harmony default export */ var style_Icon = __webpack_exports__["a"] = (Icon_Icon);
//# sourceMappingURL=Icon.js.map

/***/ }),

/***/ "6cdc":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track05.3cb4925b.png";

/***/ }),

/***/ "6d83":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/source/State
 */
/**
 * @enum {string}
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    UNDEFINED: 'undefined',
    LOADING: 'loading',
    READY: 'ready',
    ERROR: 'error',
});
//# sourceMappingURL=State.js.map

/***/ }),

/***/ "6eeb":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");
var hasOwn = __webpack_require__("1a2d");
var createNonEnumerableProperty = __webpack_require__("9112");
var setGlobal = __webpack_require__("ce4e");
var inspectSource = __webpack_require__("8925");
var InternalStateModule = __webpack_require__("69f3");
var CONFIGURABLE_FUNCTION_NAME = __webpack_require__("5e77").CONFIGURABLE;

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== undefined ? options.name : key;
  var state;
  if (isCallable(value)) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      createNonEnumerableProperty(value, 'name', name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "6f53":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var uncurryThis = __webpack_require__("e330");
var objectKeys = __webpack_require__("df75");
var toIndexedObject = __webpack_require__("fc6a");
var $propertyIsEnumerable = __webpack_require__("d1e7").f;

var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
var push = uncurryThis([].push);

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {
        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ "702a":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "7156":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var setPrototypeOf = __webpack_require__("d2bb");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "7238":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cef7");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/MapEvent
 */

/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
 */
var MapEvent = /** @class */ (function (_super) {
    __extends(MapEvent, _super);
    /**
     * @param {string} type Event type.
     * @param {import("./PluggableMap.js").default} map Map.
     * @param {?import("./PluggableMap.js").FrameState} [opt_frameState] Frame state.
     */
    function MapEvent(type, map, opt_frameState) {
        var _this = _super.call(this, type) || this;
        /**
         * The map where the event occurred.
         * @type {import("./PluggableMap.js").default}
         * @api
         */
        _this.map = map;
        /**
         * The frame state at the time of the event.
         * @type {?import("./PluggableMap.js").FrameState}
         * @api
         */
        _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
        return _this;
    }
    return MapEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (MapEvent);
//# sourceMappingURL=MapEvent.js.map

/***/ }),

/***/ "7340":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track08.2a3a1012.png";

/***/ }),

/***/ "734f":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "7371":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "7418":
/***/ (function(module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "74b5":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./P0010.png": "0f01",
	"./P0011.png": "e83d",
	"./P0012.png": "ed8b",
	"./P0013.png": "e46e",
	"./P0014.png": "3c87",
	"./P0015.png": "ce78",
	"./P0016.png": "575a",
	"./P0020.png": "8505",
	"./P0021.png": "2144",
	"./P0022.png": "d8e0",
	"./P0023.png": "7d49",
	"./P0024.png": "84aa",
	"./P0025.png": "13ca",
	"./P0026.png": "3c16",
	"./P0027.png": "8220",
	"./P0030.png": "a6ee",
	"./P0031.png": "fde4",
	"./P0032.png": "2240",
	"./P0033.png": "c140",
	"./P0040.png": "7c0d",
	"./P0050.png": "06db",
	"./P0051.png": "490c",
	"./P0052.png": "a715",
	"./P0060.png": "fb4f",
	"./P0070.png": "69b7",
	"./P0071.png": "1c32",
	"./P0072.png": "ccc0",
	"./P0073.png": "31ac",
	"./P0074.png": "cace",
	"./P0080.png": "bb21",
	"./P0081.png": "183c",
	"./P0090.png": "1159",
	"./P0091.png": "8fc6",
	"./P0092.png": "33de",
	"./P0093.png": "01f7",
	"./P0094.png": "96dc",
	"./P0095.png": "0aae",
	"./P0100.png": "ed88",
	"./P0102.png": "528b",
	"./P0110.png": "573a",
	"./P0111.png": "9ffa",
	"./P0112.png": "465d",
	"./P0113.png": "b142",
	"./P0120.png": "f721",
	"./P0130.png": "c7cc",
	"./P0131.png": "44a9",
	"./P0140.png": "06a0",
	"./P0141.png": "cc88",
	"./P0142.png": "392c",
	"./P0143.png": "6b08",
	"./P0144.png": "702a",
	"./P0150.png": "75e1",
	"./P0151.png": "182f",
	"./P0160.png": "a7dd",
	"./P0170.png": "c4e1",
	"./P0171.png": "2ea2",
	"./P0172.png": "3419",
	"./P0180.png": "97c6",
	"./P0190.png": "0b9c",
	"./P0191.png": "b4de",
	"./P0200.png": "c19a",
	"./P0201.png": "a37a",
	"./P0202.png": "7d09",
	"./P0210.png": "aabb",
	"./P0211.png": "42f5",
	"./P0220.png": "ce0f",
	"./P0230.png": "db05",
	"./P0240.png": "f534",
	"./P0250.png": "f6f4",
	"./P0260.png": "1d61",
	"./P0270.png": "ec50",
	"./P0271.png": "5b3d",
	"./P0280.png": "4aea",
	"./P0290.png": "843f",
	"./P0300.png": "76c7",
	"./P0310.png": "2909",
	"./P0370.png": "1238",
	"./P0390.png": "d9aa",
	"./P0610.png": "e25d",
	"./P0611.png": "b52d",
	"./P0612.png": "bf3d",
	"./P0620.png": "c26f",
	"./P0621.png": "b811",
	"./P0630.png": "091f",
	"./P0631.png": "9c6a",
	"./P0640.png": "d4b4",
	"./P0650.png": "2815",
	"./P0660.png": "2ede",
	"./P0680.png": "01db",
	"./P0681.png": "bc52",
	"./P0720.png": "33a7",
	"./P0740.png": "30e6",
	"./P0741.png": "29e8",
	"./P0760.png": "1287",
	"./P0780.png": "afd9",
	"./P0820.png": "9670",
	"./P0840.png": "4dae",
	"./P0860.png": "a4c4",
	"./P0880.png": "7371"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "74b5";

/***/ }),

/***/ "74f8":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAeRJREFUeNpiZCARPMgVMwBSAmjCHxQmv7pAijmMRFrmAKTigTgAi6Vwy4F4AxAvBDriAEUWQ33XD8QOJAYMyOJCfKHAiMfSBCA1n4EykAi0fAHRFgMtBVmYwEAdsABoeSK6IBMWSwuoaCkIJEDNxO1jaCLaz0Ab4Iic6NB93M9AO9CPNaihicmAHBOZOPkZJMv3MnCoWuFTZgC1AwxYkCTicelgk9ZhYOLiw2kir30aWI147nqGt0vzGL6cXIlLKciOBfA4BroEVCi8J9diZPDv2yeGX0+v4FMiCIzrDzAf4w1iAgaRCkB2HYDFsQMD/YAD1nxMLzByLX5ARzsfIFt8gRomcul5MoimLAAXKHjABZSyGpiX7wMpBWQVLEKyDCzCskSXXsLRE8E0KPu9np3A8OfdYwzfAvOwInrJtRCI61EKg++fiPbtv+8fGV7PIVipLcSonaCl1308TRtKAahppAgqtVBSNVSgkYaJqhFmKdYWCNDn+2lQkh0AWupIKB8HUiuVI6XiQGLbXALQlogBFSx1RA5iYpu3DegpncQ4bSC7QQ+0XAFqeQARKR7WqAdZ+oDingSSIwKgwW+PlABBwbkRRAMt20DVLgwOR+yHhgDWOCQEWChIOKCUKkCOpSAAEGAA8VaU8w2uT9oAAAAASUVORK5CYII="

/***/ }),

/***/ "75e1":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "766c":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "76c7":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGW0lEQVR4nIWVe3CU5RXGf+fbzeayuW3u14UA4dIYEkxELlIZKAQFtHIdrRTGiXJxxKIIrTiDYyvtkJE6IiAKWKyggohDWwuF4FTlkhJhCqYhkBguIZsLySabZLOb7O7pH5ttsVI875x/vvf9nuc953zf80ggEABARBiIEmBBV2/fvReu3Mw+U9cSe6Otm7rGDgyzSRk4Fuj3iz01lkFJMdydk+zKz0m6bouOqAD2A4cBVBVR1RBwKbB+19GqrB1/PU9tUydp8VHkZNnIsFnJG5xEgjUcRECVtm4v1Vdv0uh0U9vQjqO9h+ykaEpL8lk+u6DBhLwM7AwRlJ2pa1ldsvpDUuKi+MXCsRQNTaHL3YfD2cOlG04utXTR3NaNmgzEHyAtKZrc5BiGZ9pIs1mJjw6n8nILr31UQUOLi4Mb5lFSaH9NVPXJpg732+kLt1JW+mMenXYXZR+cZv+pWhobOyEQAMMAAcwmMAQCCj4/KMF9k0FGehzzxw9jzWPj2Hu0ihc2HeFf+1Ygqlq97K3PR15rdbFvzYOkLNxGb1s3WMxBIDQIZDIgNhIxBAXo8kCfj9BMMJvA209EvJXOg88wff1B7MkxmFU1+rKjQ1fMyOfJLeVB8AQrw9LiKZ2ex9iR6XT39rG7vJoD5VVodAR0uCkoyOa5h+/GnhJLxUUHGw9U0n6zC4+zh+XbjrO0JJ8dx6owAy3hZiOrrqlTLzV2gMVMYpSFy9sXA3DN0YHZEsfstTk8nxLDpq3l/PSRIg6+OBuA6w1OJs8p4pmZo7Ev2Umbx8nZb1uZOCoDi9kQQ0Rq7MkxhIeZxGI2CRaTtPV45b51ByRlyQ4ZNH+rZM56XU7XOGTJlFGCJUx2ryqRUzUOkZ9sFPucNyRj8TtiMgzZ/cIMoccrWUkx0urqlbzsxIChqmVjc9P6u3r7dcyQZKXPr4SZ9URlvbbWNuvwQrvqqZd03Ih0XbfntMYNTdbYSIuufe+k4ulXshLUUe3QD768pDMK7EpspI7JSdIL19p0RGa80xCRc5PzMuuqG9rFnhQtgNDnExQhJkI63F5558//lMq6Flm/cKwMTY0TQLo8fUKYSTAMwWyI1+cXRQWQQSmx4mjvkWkF9vMGwJC0uHK310dmQjSYDRITrDx4/wjwBWi51MRTy3ez6PW/UTQ0BUuYCVXlV3OKweWB621gszKraDBf1TSDKmEmA0OEwSmxn5oHPrI/FuYkPe3s9mAfnMSsosFseWoyFfOKOVx5hWiLmdKZBbS6ejl9spYX3z/FbxdNwLbrCb74Rz3L5xWTYbNy78o9TLpvOOev3mTq6CyA/agqqkrDza5vFpR9ppsOnVPGvaJL3zymlbXN6uz2aHuPR4+cu6ojlu1Wpm1UJv9Ol24p1/qWTnW6vXryYqMWr9qr5K/TvV/U6Li1+9TR3n1IVTGHtCgzMXqzNcLyVlaCVdNGprP9owq2f3wGwsOCNXr7IdKCxEah/gDbD1Sy/ZOvITIMur3g81NYko+7z0dedoKk2axlqorBf2Pnypmjmw9V1svqR4oBAZsVIsKCabMikZYB6RCIj4Lo8OAfbosCEdY+PIadx6pk1UOF54AvAQwRCUm1rzAn+VWL2SA70Sq5eZlCj1fEZAgmQxARBdHg4WCajOB+Z69MmTJKmpxuyUmJJS87cWXIAozQDAZatXnDzyZcefd4Nb9+fLzi9an6BwTpNktAtd+vRoRZ180t0nePV7O59P5jwFchzP9UEDKc1PioxyeOTKfqWps8u3ii0NoVvK0giN6SiKoKLS7ZsfoB2Xr4giyfcRcJMRFLQrcXke/MIBQnXpp/z86Ky81M/lEGD0zPg+bOoOsNLBDwB+CGk1eeL6HN1Yvb42NZSf4K4MatYLc62neeN3e4q2e9+qcRe54rYdW243x2vBqs4QOy7AOfn18+MYni3FTWvHeCmjcXfWg2GY9+D+j/EADklp+//s3P3zhq2fX0VK61uDh8pp72Lg9DU+NYMGUUl6+3seGTrzn7+8cqU+OjJgD93yMImf5tyxAZ/21z59E5L39qHZ6dwIx7hhBjtXClycXHn1dji4ngL7+Ze9ZkyERV9dwW404EAyTDgLf3/r1m0pHKerPb26/JsVEyd1Kua2qB/Q/As3fowh1b9L+xCFgKRACNwBrg4g+99G/e7M8lJnMpxQAAAABJRU5ErkJggg=="

/***/ }),

/***/ "7839":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "785a":
/***/ (function(module, exports, __webpack_require__) {

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__("cc12");

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ "78db":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("dc07");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0414");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("92fa");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("7fc9");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0af5");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("2c30");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("9f5e");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("345d");
/**
 * @module ol/tilegrid/TileGrid
 */








/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
var tmpTileCoord = [0, 0, 0];
/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */
var DECIMALS = 5;
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */
/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
var TileGrid = /** @class */ (function () {
    /**
     * @param {Options} options Tile grid options.
     */
    function TileGrid(options) {
        /**
         * @protected
         * @type {number}
         */
        this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
        /**
         * @private
         * @type {!Array<number>}
         */
        this.resolutions_ = options.resolutions;
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__[/* assert */ "a"])(Object(_array_js__WEBPACK_IMPORTED_MODULE_6__[/* isSorted */ "e"])(this.resolutions_, function (a, b) {
            return b - a;
        }, true), 17); // `resolutions` must be sorted in descending order
        // check if we've got a consistent zoom factor and origin
        var zoomFactor;
        if (!options.origins) {
            for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
                if (!zoomFactor) {
                    zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
                }
                else {
                    if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                        zoomFactor = undefined;
                        break;
                    }
                }
            }
        }
        /**
         * @private
         * @type {number|undefined}
         */
        this.zoomFactor_ = zoomFactor;
        /**
         * @protected
         * @type {number}
         */
        this.maxZoom = this.resolutions_.length - 1;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate|null}
         */
        this.origin_ = options.origin !== undefined ? options.origin : null;
        /**
         * @private
         * @type {Array<import("../coordinate.js").Coordinate>}
         */
        this.origins_ = null;
        if (options.origins !== undefined) {
            this.origins_ = options.origins;
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__[/* assert */ "a"])(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
        }
        var extent = options.extent;
        if (extent !== undefined && !this.origin_ && !this.origins_) {
            this.origin_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* getTopLeft */ "B"])(extent);
        }
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__[/* assert */ "a"])((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both
        /**
         * @private
         * @type {Array<number|import("../size.js").Size>}
         */
        this.tileSizes_ = null;
        if (options.tileSizes !== undefined) {
            this.tileSizes_ = options.tileSizes;
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__[/* assert */ "a"])(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
        }
        /**
         * @private
         * @type {number|import("../size.js").Size}
         */
        this.tileSize_ =
            options.tileSize !== undefined
                ? options.tileSize
                : !this.tileSizes_
                    ? _common_js__WEBPACK_IMPORTED_MODULE_1__[/* DEFAULT_TILE_SIZE */ "b"]
                    : null;
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_2__[/* assert */ "a"])((!this.tileSize_ && this.tileSizes_) ||
            (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */
        this.extent_ = extent !== undefined ? extent : null;
        /**
         * @private
         * @type {Array<import("../TileRange.js").default>}
         */
        this.fullTileRanges_ = null;
        /**
         * @private
         * @type {import("../size.js").Size}
         */
        this.tmpSize_ = [0, 0];
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */
        this.tmpExtent_ = [0, 0, 0, 0];
        if (options.sizes !== undefined) {
            this.fullTileRanges_ = options.sizes.map(function (size, z) {
                var tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"](Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
                if (extent) {
                    var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
                    tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
                    tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
                    tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
                    tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
                }
                return tileRange;
            }, this);
        }
        else if (extent) {
            this.calculateTileRanges_(extent);
        }
    }
    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
     * @api
     */
    TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
            for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
                callback([zoom, i, j]);
            }
        }
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */
    TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {
        var tileRange, x, y;
        var tileCoordExtent = null;
        var z = tileCoord[0] - 1;
        if (this.zoomFactor_ === 2) {
            x = tileCoord[1];
            y = tileCoord[2];
        }
        else {
            tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
        }
        while (z >= this.minZoom) {
            if (this.zoomFactor_ === 2) {
                x = Math.floor(x / 2);
                y = Math.floor(y / 2);
                tileRange = Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_0__[/* createOrUpdate */ "a"])(x, x, y, y, opt_tileRange);
            }
            else {
                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
            }
            if (callback(z, tileRange)) {
                return true;
            }
            --z;
        }
        return false;
    };
    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    TileGrid.prototype.getExtent = function () {
        return this.extent_;
    };
    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */
    TileGrid.prototype.getMaxZoom = function () {
        return this.maxZoom;
    };
    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */
    TileGrid.prototype.getMinZoom = function () {
        return this.minZoom;
    };
    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */
    TileGrid.prototype.getOrigin = function (z) {
        if (this.origin_) {
            return this.origin_;
        }
        else {
            return this.origins_[z];
        }
    };
    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */
    TileGrid.prototype.getResolution = function (z) {
        return this.resolutions_[z];
    };
    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */
    TileGrid.prototype.getResolutions = function () {
        return this.resolutions_;
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default} Tile range.
     */
    TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
        if (tileCoord[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
                var minX = tileCoord[1] * 2;
                var minY = tileCoord[2] * 2;
                return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_0__[/* createOrUpdate */ "a"])(minX, minX + 1, minY, minY + 1, opt_tileRange);
            }
            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
        }
        return null;
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default} Tile range.
     */
    TileGrid.prototype.getTileRangeForTileCoordAndZ = function (tileCoord, z, opt_tileRange) {
        if (z > this.maxZoom || z < this.minZoom) {
            return null;
        }
        var tileCoordZ = tileCoord[0];
        var tileCoordX = tileCoord[1];
        var tileCoordY = tileCoord[2];
        if (z === tileCoordZ) {
            return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_0__[/* createOrUpdate */ "a"])(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);
        }
        if (this.zoomFactor_) {
            var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
            var minX = Math.floor(tileCoordX * factor);
            var minY = Math.floor(tileCoordY * factor);
            if (z < tileCoordZ) {
                return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_0__[/* createOrUpdate */ "a"])(minX, minX, minY, minY, opt_tileRange);
            }
            var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
            var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
            return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_0__[/* createOrUpdate */ "a"])(minX, maxX, minY, maxY, opt_tileRange);
        }
        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    };
    /**
     * Get the extent for a tile range.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} tileRange Tile range.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
     * @return {import("../extent.js").Extent} Extent.
     */
    TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
        var origin = this.getOrigin(z);
        var resolution = this.getResolution(z);
        var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__[/* toSize */ "c"])(this.getTileSize(z), this.tmpSize_);
        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* createOrUpdate */ "k"])(minX, minY, maxX, maxY, opt_extent);
    };
    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */
    TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
        var tileCoord = tmpTileCoord;
        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
        var minX = tileCoord[1];
        var minY = tileCoord[2];
        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
        return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_0__[/* createOrUpdate */ "a"])(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */
    TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
        var origin = this.getOrigin(tileCoord[0]);
        var resolution = this.getResolution(tileCoord[0]);
        var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__[/* toSize */ "c"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
        return [
            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,
        ];
    };
    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
        var origin = this.getOrigin(tileCoord[0]);
        var resolution = this.getResolution(tileCoord[0]);
        var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__[/* toSize */ "c"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
        var maxX = minX + tileSize[0] * resolution;
        var maxY = minY + tileSize[1] * resolution;
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* createOrUpdate */ "k"])(minX, minY, maxX, maxY, opt_extent);
    };
    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    };
    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
        var z = this.getZForResolution(resolution);
        var scale = resolution / this.getResolution(z);
        var origin = this.getOrigin(z);
        var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__[/* toSize */ "c"])(this.getTileSize(z), this.tmpSize_);
        var tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];
        var tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* ceil */ "a"])(tileCoordX, DECIMALS) - 1;
            tileCoordY = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* ceil */ "a"])(tileCoordY, DECIMALS) - 1;
        }
        else {
            tileCoordX = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* floor */ "d"])(tileCoordX, DECIMALS);
            tileCoordY = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* floor */ "d"])(tileCoordY, DECIMALS);
        }
        return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__[/* createOrUpdate */ "a"])(z, tileCoordX, tileCoordY, opt_tileCoord);
    };
    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
        var origin = this.getOrigin(z);
        var resolution = this.getResolution(z);
        var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_7__[/* toSize */ "c"])(this.getTileSize(z), this.tmpSize_);
        var tileCoordX = (x - origin[0]) / resolution / tileSize[0];
        var tileCoordY = (origin[1] - y) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* ceil */ "a"])(tileCoordX, DECIMALS) - 1;
            tileCoordY = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* ceil */ "a"])(tileCoordY, DECIMALS) - 1;
        }
        else {
            tileCoordX = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* floor */ "d"])(tileCoordX, DECIMALS);
            tileCoordY = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* floor */ "d"])(tileCoordY, DECIMALS);
        }
        return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__[/* createOrUpdate */ "a"])(z, tileCoordX, tileCoordY, opt_tileCoord);
    };
    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Zoom level.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */
    TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
        return this.resolutions_[tileCoord[0]];
    };
    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */
    TileGrid.prototype.getTileSize = function (z) {
        if (this.tileSize_) {
            return this.tileSize_;
        }
        else {
            return this.tileSizes_[z];
        }
    };
    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
     */
    TileGrid.prototype.getFullTileRange = function (z) {
        if (!this.fullTileRanges_) {
            return this.extent_
                ? this.getTileRangeForExtentAndZ(this.extent_, z)
                : null;
        }
        else {
            return this.fullTileRanges_[z];
        }
    };
    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */
    TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
        var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_6__[/* linearFindNearest */ "f"])(this.resolutions_, resolution, opt_direction || 0);
        return Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* clamp */ "b"])(z, this.minZoom, this.maxZoom);
    };
    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */
    TileGrid.prototype.calculateTileRanges_ = function (extent) {
        var length = this.resolutions_.length;
        var fullTileRanges = new Array(length);
        for (var z = this.minZoom; z < length; ++z) {
            fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
        }
        this.fullTileRanges_ = fullTileRanges;
    };
    return TileGrid;
}());
/* harmony default export */ __webpack_exports__["a"] = (TileGrid);
//# sourceMappingURL=TileGrid.js.map

/***/ }),

/***/ "790a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DEFAULT_RADIUS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getDistance; });
/* unused harmony export getLength */
/* unused harmony export getArea */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return offset; });
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f623");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7fc9");
/**
 * @module ol/sphere
 */


/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */
/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
    var radius = opt_radius || DEFAULT_RADIUS;
    var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(c1[1]);
    var lat2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(c2[1]);
    var deltaLatBy2 = (lat2 - lat1) / 2;
    var deltaLonBy2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(c2[0] - c1[0]) / 2;
    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
        Math.sin(deltaLonBy2) *
            Math.sin(deltaLonBy2) *
            Math.cos(lat1) *
            Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
    var length = 0;
    for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
        length += getDistance(coordinates[i], coordinates[i + 1], radius);
    }
    return length;
}
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
    var options = opt_options || {};
    var radius = options.radius || DEFAULT_RADIUS;
    var projection = options.projection || 'EPSG:3857';
    var type = geometry.getType();
    if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].GEOMETRY_COLLECTION) {
        geometry = geometry.clone().transform(projection, 'EPSG:4326');
    }
    var length = 0;
    var coordinates, coords, i, ii, j, jj;
    switch (type) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].MULTI_POINT: {
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LINEAR_RING: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            length = getLengthInternal(coordinates, radius);
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].MULTI_LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POLYGON: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            for (i = 0, ii = coordinates.length; i < ii; ++i) {
                length += getLengthInternal(coordinates[i], radius);
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].MULTI_POLYGON: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            for (i = 0, ii = coordinates.length; i < ii; ++i) {
                coords = coordinates[i];
                for (j = 0, jj = coords.length; j < jj; ++j) {
                    length += getLengthInternal(coords[j], radius);
                }
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].GEOMETRY_COLLECTION: {
            var geometries = 
            /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
            for (i = 0, ii = geometries.length; i < ii; ++i) {
                length += getLength(geometries[i], opt_options);
            }
            break;
        }
        default: {
            throw new Error('Unsupported geometry type: ' + type);
        }
    }
    return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
    var area = 0;
    var len = coordinates.length;
    var x1 = coordinates[len - 1][0];
    var y1 = coordinates[len - 1][1];
    for (var i = 0; i < len; i++) {
        var x2 = coordinates[i][0];
        var y2 = coordinates[i][1];
        area +=
            Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(x2 - x1) *
                (2 + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(y1)) + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(y2)));
        x1 = x2;
        y1 = y2;
    }
    return (area * radius * radius) / 2.0;
}
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
    var options = opt_options || {};
    var radius = options.radius || DEFAULT_RADIUS;
    var projection = options.projection || 'EPSG:3857';
    var type = geometry.getType();
    if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].GEOMETRY_COLLECTION) {
        geometry = geometry.clone().transform(projection, 'EPSG:4326');
    }
    var area = 0;
    var coordinates, coords, i, ii, j, jj;
    switch (type) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].MULTI_POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].MULTI_LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LINEAR_RING: {
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POLYGON: {
            coordinates = /** @type {import("./geom/Polygon.js").default} */ (geometry).getCoordinates();
            area = Math.abs(getAreaInternal(coordinates[0], radius));
            for (i = 1, ii = coordinates.length; i < ii; ++i) {
                area -= Math.abs(getAreaInternal(coordinates[i], radius));
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].MULTI_POLYGON: {
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
            for (i = 0, ii = coordinates.length; i < ii; ++i) {
                coords = coordinates[i];
                area += Math.abs(getAreaInternal(coords[0], radius));
                for (j = 1, jj = coords.length; j < jj; ++j) {
                    area -= Math.abs(getAreaInternal(coords[j], radius));
                }
            }
            break;
        }
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].GEOMETRY_COLLECTION: {
            var geometries = 
            /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
            for (i = 0, ii = geometries.length; i < ii; ++i) {
                area += getArea(geometries[i], opt_options);
            }
            break;
        }
        default: {
            throw new Error('Unsupported geometry type: ' + type);
        }
    }
    return area;
}
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
    var radius = opt_radius || DEFAULT_RADIUS;
    var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(c1[1]);
    var lon1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toRadians */ "l"])(c1[0]);
    var dByR = distance / radius;
    var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) +
        Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
    var lon = lon1 +
        Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
    return [Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toDegrees */ "k"])(lon), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* toDegrees */ "k"])(lat)];
}
//# sourceMappingURL=sphere.js.map

/***/ }),

/***/ "7a09":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("521b");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("f623");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("9abc");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("9769");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0af5");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("abb7");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("1c48");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("9f5e");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("fd4d");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("bb6c");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("b1a2");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("c560");
/* harmony import */ var _flat_length_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("5938");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/LineString
 */













/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
var LineString = /** @class */ (function (_super) {
    __extends(LineString, _super);
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */
    function LineString(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */
        _this.flatMidpoint_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.flatMidpointRevision_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.maxDeltaRevision_ = -1;
        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
            _this.setFlatCoordinates(opt_layout, 
            /** @type {Array<number>} */ (coordinates));
        }
        else {
            _this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
        }
        return _this;
    }
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */
    LineString.prototype.appendCoordinate = function (coordinate) {
        if (!this.flatCoordinates) {
            this.flatCoordinates = coordinate.slice();
        }
        else {
            Object(_array_js__WEBPACK_IMPORTED_MODULE_7__[/* extend */ "c"])(this.flatCoordinates, coordinate);
        }
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     */
    LineString.prototype.clone = function () {
        var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
        lineString.applyProperties(this);
        return lineString;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* closestSquaredDistanceXY */ "e"])(this.getExtent(), x, y)) {
            return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__[/* maxSquaredDelta */ "e"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__[/* assignClosestPoint */ "d"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */
    LineString.prototype.forEachSegment = function (callback) {
        return Object(_flat_segments_js__WEBPACK_IMPORTED_MODULE_8__[/* forEach */ "a"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
    };
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
        if (this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].XYM &&
            this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].XYZM) {
            return null;
        }
        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
        return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__[/* lineStringCoordinateAtM */ "b"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
    };
    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
    LineString.prototype.getCoordinates = function () {
        return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_9__[/* inflateCoordinates */ "a"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [opt_dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */
    LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
        return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_10__[/* interpolatePoint */ "a"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
    };
    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */
    LineString.prototype.getLength = function () {
        return Object(_flat_length_js__WEBPACK_IMPORTED_MODULE_12__[/* lineStringLength */ "a"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * @return {Array<number>} Flat midpoint.
     */
    LineString.prototype.getFlatMidpoint = function () {
        if (this.flatMidpointRevision_ != this.getRevision()) {
            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
            this.flatMidpointRevision_ = this.getRevision();
        }
        return this.flatMidpoint_;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     */
    LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_6__[/* douglasPeucker */ "a"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].XY);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    LineString.prototype.getType = function () {
        return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINE_STRING;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    LineString.prototype.intersectsExtent = function (extent) {
        return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_11__[/* intersectsLineString */ "a"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    };
    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */
    LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__[/* deflateCoordinates */ "b"])(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return LineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (LineString);
//# sourceMappingURL=LineString.js.map

/***/ }),

/***/ "7b0b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var requireObjectCoercible = __webpack_require__("1d80");

var Object = global.Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "7b4f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/ObjectEventType
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Triggered when a property is changed.
     * @event module:ol/Object.ObjectEvent#propertychange
     * @api
     */
    PROPERTYCHANGE: 'propertychange',
});
/**
 * @typedef {'propertychange'} Types
 */
//# sourceMappingURL=ObjectEventType.js.map

/***/ }),

/***/ "7c0d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "7c73":
/***/ (function(module, exports, __webpack_require__) {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__("825a");
var definePropertiesModule = __webpack_require__("37e8");
var enumBugKeys = __webpack_require__("7839");
var hiddenKeys = __webpack_require__("d012");
var html = __webpack_require__("1be4");
var documentCreateElement = __webpack_require__("cc12");
var sharedKey = __webpack_require__("f772");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "7d09":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "7d49":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGZ0lEQVR4nIWVe3CU5RXGf+fbze4mu5tkc7+QkIQE0CVCuSiIiMMthBm0FcSBQnW4lIsFBYEyvWFt5Q9TGKa0YmkQO1VR6TRQpJhBIlqo3BFiCAiRACEh92ST7CbZ7J7+sVmKxer55pt555vnnOc953vOORIMBgEQEfqtAJjT4et9qLy6KeNUVUP0reZOqmrbMMwmpR8W9AckMzmagQlORmYnevKzE266HLYTwB7gQwBVRVQ1HHgxsPGNQxUDig9e4OrtdlJio8ge4CLNZcedlUCc3QoioEpzZw+V15uobfVytaaFupYuMhIcLC7IZ/nM4TUm5CVgZ5ig6FRVw9qCte+SFBPFC08/yKhBSXR4e6lr6+LSzVbOXG+iuq6dgIAJGJoZT366i8FpsaS47MQ6rJy+0sDm905Q0+ChZNNsCkZkbhZVXXK7zbsj9enXKFr8KHOnDqNo93H2fHaV2rp26AtAZw/OISk8MSaHiAgTbZ3dlJRVQkc3REaACGmpMTw1Lpf188byzqEK1m0p5eL7KxBVrVz2+sdDbzR6eH/9DJLmbMfX3AEuO4gQaQglv3qcgpFZALR39RBjt1Ld4GHs6t3Ut3aBLQL8AWjzYnPZaS9ZybSNJWQmOjFU1XGlrk0XTXHrkj8eVl9Ll5ISo1jMikm0NxDUqoYOXb7jiJpmbtXYKa9q2qI3NCspWhdMz1d8fgVRLGaV5GjtbunS5dvLdGlBvt5q6VIz0GA1GwOqbrfrl7Vt4LSCAqqIYRCwGDxXdBDavRAdyWMTBrNh3lgAjn1RAxYToP0+gN3Cma8aGX9fGhazIWYRuZyZ6BxpjTCJxWyCYL+qwrINKvgDLPzReLYumYgz0kJtUwfTf/l3Pjt1DWKj7mC1Hz8w0Umjx4c7Iz5oqGrRg3kp/g6fX7+Xk6j4A6G7KKqqSrtXX10zTXeumqp/OXxRBy3cqemFW7S0tFxx2FQMQ+l/BJSA6uhBSVp+o1mHpMe2GiJy7jF3elVlTYtkJjgERVAVRAVvr6TnJMq674+S89WNcuZirUwenSWrfzJZ1q+aKu7sRFFfbwgrKkrId2BStNS1dMnU4ZkXzAA5KTGHvT19Q9PjHCHZBRVMBvQFyEhwUtPcSXJMFH96cXqokTVUlep6DxXlN0MqAugLYIqNxBAwRMhKit4bbrSHfv3eieMuu5W3j37JyXM3wGELOalCIPi1/4HVzB0zm/57bvPyxDQ3uckxJETb2PDk6LQw8sTiKe6KNbv+5Z43YTAnj10FhxU6uil8dAjPFT5AIBjEYjaREB1JbXMnhiFEWsxMfXkf6vODNQL6AswZl8u2f16g5Kcz9gN15vAsSo93bLPbLK+nxto1NS+ZugYPRFkpK6+hw+fHZTGTkxHH8oJhFH9wnm5DuNXahfYFQxn5ehgxJhufvw93RpykuOxFqorcNU3Nn19rrNn8j3PJI7KTdO3vDoZ6wmrG8/YyTl+pJ9IWQWaCg7MVtQzNS+LTiloWvbI/JNWmDnZvms3vD5yXP6+YdM6dET9SVTFEJDyq+0ZkJ75iMRtkxNslz50udPaIM9IiTZ5umfRssfz1yCWJcdhk5oY9smbXUclKcgqGCO1emTTpfrnd6pXspGjcGfGrwivAUFXCL7Bt0w8frt5VVslv5o9TevzaF1Bt6+rWx2eN1qUFw/SFbR/pybd+rKMGJWpbV6/SF1DDGqE/nzVKd5VVsm3xxI+Ao+GYdzIIL5zk2Kj544emUnGjWRY+84j46j1iNhny4g9GyvPFn0rxm0dl+76zMiwzQQxBaOiQ4nWF8tqH5bJ8+jDinLZnw7cXEQzutWO/eGrMzhNX6pl4XxqzCvMxRJi0cS9Hjl+FjDgqb7SQmxrDJxW1rFw9jWaPD293H8sK8lcAt+4OdvdG+9r3+jZvZcHL+4aUbJjBgTPXWbnpg1BDmQxMDiuDYqOYPfl+HsiM52dv/ZvLf1jwrtlkzL0n0P8hAMgrK6/5Yv7WUsuWZx7B4+2l9PQ1Wjp7GOCKonBcLo3NnRTt/5wzW+aeTo6Nehjw30MQluk3piEy7qv69kNPvrTXPjgjjuljcnDaLVTf9vC3jytxOW0c+O2ssyZDxqtq9zfG+DaCfpJcYMc7n1yeUHr6mtnb49fE6CiZNSHPM3l45pvA899ShW8t0f/aAmApYANqgfXApe9y+g+xmNNoZC5cSwAAAABJRU5ErkJggg=="

/***/ }),

/***/ "7e6d":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "7f98":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5e31");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("acc1");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0999");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("6611");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/ImageTile
 */




var ImageTile = /** @class */ (function (_super) {
    __extends(ImageTile, _super);
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [opt_options] Tile options.
     */
    function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
        var _this = _super.call(this, tileCoord, state, opt_options) || this;
        /**
         * @private
         * @type {?string}
         */
        _this.crossOrigin_ = crossOrigin;
        /**
         * Image URI
         *
         * @private
         * @type {string}
         */
        _this.src_ = src;
        _this.key = src;
        /**
         * @private
         * @type {HTMLImageElement|HTMLCanvasElement}
         */
        _this.image_ = new Image();
        if (crossOrigin !== null) {
            _this.image_.crossOrigin = crossOrigin;
        }
        /**
         * @private
         * @type {?function():void}
         */
        _this.unlisten_ = null;
        /**
         * @private
         * @type {import("./Tile.js").LoadFunction}
         */
        _this.tileLoadFunction_ = tileLoadFunction;
        return _this;
    }
    /**
     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */
    ImageTile.prototype.getImage = function () {
        return this.image_;
    };
    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */
    ImageTile.prototype.setImage = function (element) {
        this.image_ = element;
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOADED;
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Tracks loading or read errors.
     *
     * @private
     */
    ImageTile.prototype.handleImageError_ = function () {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
    };
    /**
     * Tracks successful image load.
     *
     * @private
     */
    ImageTile.prototype.handleImageLoad_ = function () {
        var image = /** @type {HTMLImageElement} */ (this.image_);
        if (image.naturalWidth && image.naturalHeight) {
            this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOADED;
        }
        else {
            this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].EMPTY;
        }
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Load not yet loaded URI.
     * @api
     */
    ImageTile.prototype.load = function () {
        if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ERROR) {
            this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].IDLE;
            this.image_ = new Image();
            if (this.crossOrigin_ !== null) {
                this.image_.crossOrigin = this.crossOrigin_;
            }
        }
        if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].IDLE) {
            this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOADING;
            this.changed();
            this.tileLoadFunction_(this, this.src_);
            this.unlisten_ = Object(_Image_js__WEBPACK_IMPORTED_MODULE_3__[/* listenImage */ "b"])(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    };
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
    ImageTile.prototype.unlistenImage_ = function () {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    };
    return ImageTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
    var ctx = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__[/* createCanvasContext2D */ "a"])(1, 1);
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, 1, 1);
    return ctx.canvas;
}
/* harmony default export */ __webpack_exports__["a"] = (ImageTile);
//# sourceMappingURL=ImageTile.js.map

/***/ }),

/***/ "7f9a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");
var inspectSource = __webpack_require__("8925");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "7fc9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return log2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return squaredSegmentDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return solveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return modulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return lerp; });
/* unused harmony export toFixed */
/* unused harmony export round */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ceil; });
/**
 * @module ol/math
 */
/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
var cosh = (function () {
    // Wrapped in a iife, to save the overhead of checking for the native
    // implementation on every invocation.
    var cosh;
    if ('cosh' in Math) {
        // The environment supports the native Math.cosh function, use it…
        cosh = Math.cosh;
    }
    else {
        // … else, use the reference implementation of MDN:
        cosh = function (x) {
            var y = /** @type {Math} */ (Math).exp(x);
            return (y + 1 / y) / 2;
        };
    }
    return cosh;
})();
/**
 * Return the base 2 logarithm of a given number. The method will use the
 * native `Math.log2` function if it is available, otherwise the base 2
 * logarithm will be calculated via the reference implementation of the
 * Mozilla developer network.
 *
 * @param {number} x X.
 * @return {number} Base 2 logarithm of x.
 */
var log2 = (function () {
    // Wrapped in a iife, to save the overhead of checking for the native
    // implementation on every invocation.
    var log2;
    if ('log2' in Math) {
        // The environment supports the native Math.log2 function, use it…
        log2 = Math.log2;
    }
    else {
        // … else, use the reference implementation of MDN:
        log2 = function (x) {
            return Math.log(x) * Math.LOG2E;
        };
    }
    return log2;
})();
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x1 = x2;
            y1 = y2;
        }
        else if (t > 0) {
            x1 += dx * t;
            y1 += dy * t;
        }
    }
    return squaredDistance(x, y, x1, y1);
}
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
}
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
    var n = mat.length;
    for (var i = 0; i < n; i++) {
        // Find max in the i-th column (ignoring i - 1 first rows)
        var maxRow = i;
        var maxEl = Math.abs(mat[i][i]);
        for (var r = i + 1; r < n; r++) {
            var absValue = Math.abs(mat[r][i]);
            if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
            }
        }
        if (maxEl === 0) {
            return null; // matrix is singular
        }
        // Swap max row with i-th (current) row
        var tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;
        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for (var j = i + 1; j < n; j++) {
            var coef = -mat[j][i] / mat[i][i];
            for (var k = i; k < n + 1; k++) {
                if (i == k) {
                    mat[j][k] = 0;
                }
                else {
                    mat[j][k] += coef * mat[i][k];
                }
            }
        }
    }
    // Solve Ax=b for upper triangular matrix A (mat)
    var x = new Array(n);
    for (var l = n - 1; l >= 0; l--) {
        x[l] = mat[l][n] / mat[l][l];
        for (var m = l - 1; m >= 0; m--) {
            mat[m][n] -= mat[m][l] * x[l];
        }
    }
    return x;
}
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
    return (angleInRadians * 180) / Math.PI;
}
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
    return (angleInDegrees * Math.PI) / 180;
}
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
    var r = a % b;
    return r * b < 0 ? r + b : r;
}
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
    return a + x * (b - a);
}
/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */
function toFixed(n, decimals) {
    var factor = Math.pow(10, decimals);
    return Math.round(n * factor) / factor;
}
/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */
function round(n, decimals) {
    return Math.round(toFixed(n, decimals));
}
/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */
function floor(n, decimals) {
    return Math.floor(toFixed(n, decimals));
}
/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */
function ceil(n, decimals) {
    return Math.ceil(toFixed(n, decimals));
}
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "8220":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "825a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var String = global.String;
var TypeError = global.TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ "8295":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("83a6");
/* harmony import */ var _TextPlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("29f6");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("345d");
/**
 * @module ol/style/Text
 */



/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */
var DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS 'font' value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is '10px sans-serif'
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./TextPlacement.js").default|string} [placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for the immediate rendering API.
 * @property {string} [textAlign] Text alignment. Possible values: 'left', 'right', 'center', 'end' or 'start'.
 * Default is 'center' for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {string} [textBaseline='middle'] Text base line. Possible values: 'bottom', 'top', 'middle', 'alphabetic',
 * 'hanging', 'ideographic'.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */
/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */
var Text = /** @class */ (function () {
    /**
     * @param {Options} [opt_options] Options.
     */
    function Text(opt_options) {
        var options = opt_options || {};
        /**
         * @private
         * @type {string|undefined}
         */
        this.font_ = options.font;
        /**
         * @private
         * @type {number|undefined}
         */
        this.rotation_ = options.rotation;
        /**
         * @private
         * @type {boolean|undefined}
         */
        this.rotateWithView_ = options.rotateWithView;
        /**
         * @private
         * @type {number|import("../size.js").Size|undefined}
         */
        this.scale_ = options.scale;
        /**
         * @private
         * @type {import("../size.js").Size}
         */
        this.scaleArray_ = Object(_size_js__WEBPACK_IMPORTED_MODULE_2__[/* toSize */ "c"])(options.scale !== undefined ? options.scale : 1);
        /**
         * @private
         * @type {string|Array<string>|undefined}
         */
        this.text_ = options.text;
        /**
         * @private
         * @type {string|undefined}
         */
        this.textAlign_ = options.textAlign;
        /**
         * @private
         * @type {string|undefined}
         */
        this.textBaseline_ = options.textBaseline;
        /**
         * @private
         * @type {import("./Fill.js").default}
         */
        this.fill_ =
            options.fill !== undefined
                ? options.fill
                : new _Fill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]({ color: DEFAULT_FILL_COLOR });
        /**
         * @private
         * @type {number}
         */
        this.maxAngle_ =
            options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
        /**
         * @private
         * @type {import("./TextPlacement.js").default|string}
         */
        this.placement_ =
            options.placement !== undefined ? options.placement : _TextPlacement_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINT;
        /**
         * @private
         * @type {boolean}
         */
        this.overflow_ = !!options.overflow;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */
        this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
         * @private
         * @type {number}
         */
        this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
        /**
         * @private
         * @type {number}
         */
        this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
        /**
         * @private
         * @type {import("./Fill.js").default}
         */
        this.backgroundFill_ = options.backgroundFill
            ? options.backgroundFill
            : null;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */
        this.backgroundStroke_ = options.backgroundStroke
            ? options.backgroundStroke
            : null;
        /**
         * @private
         * @type {Array<number>|null}
         */
        this.padding_ = options.padding === undefined ? null : options.padding;
    }
    /**
     * Clones the style.
     * @return {Text} The cloned style.
     * @api
     */
    Text.prototype.clone = function () {
        var scale = this.getScale();
        return new Text({
            font: this.getFont(),
            placement: this.getPlacement(),
            maxAngle: this.getMaxAngle(),
            overflow: this.getOverflow(),
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            text: this.getText(),
            textAlign: this.getTextAlign(),
            textBaseline: this.getTextBaseline(),
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            offsetX: this.getOffsetX(),
            offsetY: this.getOffsetY(),
            backgroundFill: this.getBackgroundFill()
                ? this.getBackgroundFill().clone()
                : undefined,
            backgroundStroke: this.getBackgroundStroke()
                ? this.getBackgroundStroke().clone()
                : undefined,
            padding: this.getPadding() || undefined,
        });
    };
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */
    Text.prototype.getOverflow = function () {
        return this.overflow_;
    };
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */
    Text.prototype.getFont = function () {
        return this.font_;
    };
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */
    Text.prototype.getMaxAngle = function () {
        return this.maxAngle_;
    };
    /**
     * Get the label placement.
     * @return {import("./TextPlacement.js").default|string} Text placement.
     * @api
     */
    Text.prototype.getPlacement = function () {
        return this.placement_;
    };
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */
    Text.prototype.getOffsetX = function () {
        return this.offsetX_;
    };
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */
    Text.prototype.getOffsetY = function () {
        return this.offsetY_;
    };
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    Text.prototype.getFill = function () {
        return this.fill_;
    };
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */
    Text.prototype.getRotateWithView = function () {
        return this.rotateWithView_;
    };
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */
    Text.prototype.getRotation = function () {
        return this.rotation_;
    };
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */
    Text.prototype.getScale = function () {
        return this.scale_;
    };
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    Text.prototype.getScaleArray = function () {
        return this.scaleArray_;
    };
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    Text.prototype.getStroke = function () {
        return this.stroke_;
    };
    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */
    Text.prototype.getText = function () {
        return this.text_;
    };
    /**
     * Get the text alignment.
     * @return {string|undefined} Text align.
     * @api
     */
    Text.prototype.getTextAlign = function () {
        return this.textAlign_;
    };
    /**
     * Get the text baseline.
     * @return {string|undefined} Text baseline.
     * @api
     */
    Text.prototype.getTextBaseline = function () {
        return this.textBaseline_;
    };
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    Text.prototype.getBackgroundFill = function () {
        return this.backgroundFill_;
    };
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    Text.prototype.getBackgroundStroke = function () {
        return this.backgroundStroke_;
    };
    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */
    Text.prototype.getPadding = function () {
        return this.padding_;
    };
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */
    Text.prototype.setOverflow = function (overflow) {
        this.overflow_ = overflow;
    };
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */
    Text.prototype.setFont = function (font) {
        this.font_ = font;
    };
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */
    Text.prototype.setMaxAngle = function (maxAngle) {
        this.maxAngle_ = maxAngle;
    };
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */
    Text.prototype.setOffsetX = function (offsetX) {
        this.offsetX_ = offsetX;
    };
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */
    Text.prototype.setOffsetY = function (offsetY) {
        this.offsetY_ = offsetY;
    };
    /**
     * Set the text placement.
     *
     * @param {import("./TextPlacement.js").default|string} placement Placement.
     * @api
     */
    Text.prototype.setPlacement = function (placement) {
        this.placement_ = placement;
    };
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    Text.prototype.setRotateWithView = function (rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    };
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */
    Text.prototype.setFill = function (fill) {
        this.fill_ = fill;
    };
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */
    Text.prototype.setRotation = function (rotation) {
        this.rotation_ = rotation;
    };
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */
    Text.prototype.setScale = function (scale) {
        this.scale_ = scale;
        this.scaleArray_ = Object(_size_js__WEBPACK_IMPORTED_MODULE_2__[/* toSize */ "c"])(scale !== undefined ? scale : 1);
    };
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */
    Text.prototype.setStroke = function (stroke) {
        this.stroke_ = stroke;
    };
    /**
     * Set the text.
     *
     * @param {string|undefined} text Text.
     * @api
     */
    Text.prototype.setText = function (text) {
        this.text_ = text;
    };
    /**
     * Set the text alignment.
     *
     * @param {string|undefined} textAlign Text align.
     * @api
     */
    Text.prototype.setTextAlign = function (textAlign) {
        this.textAlign_ = textAlign;
    };
    /**
     * Set the text baseline.
     *
     * @param {string|undefined} textBaseline Text baseline.
     * @api
     */
    Text.prototype.setTextBaseline = function (textBaseline) {
        this.textBaseline_ = textBaseline;
    };
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */
    Text.prototype.setBackgroundFill = function (fill) {
        this.backgroundFill_ = fill;
    };
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */
    Text.prototype.setBackgroundStroke = function (stroke) {
        this.backgroundStroke_ = stroke;
    };
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */
    Text.prototype.setPadding = function (padding) {
        this.padding_ = padding;
    };
    return Text;
}());
/* harmony default export */ __webpack_exports__["a"] = (Text);
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ "82b0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/style/IconAnchorUnits
 */
/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Anchor is a fraction
     * @api
     */
    FRACTION: 'fraction',
    /**
     * Anchor is in pixels
     * @api
     */
    PIXELS: 'pixels',
});
//# sourceMappingURL=IconAnchorUnits.js.map

/***/ }),

/***/ "8322":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABNJJREFUeNqsl3tMW1Ucx7/QFijlUXAgbPgIgc6yxHRsKvwjXWTTbBpmnENJdJAZTTSbosniHyZg9td8bGriIonLgEzNlvFYJgYdk4eGbQlzTAIILsigUBmvMvqg9972es7l3sttuZQC/tJfzu1pez7n9zjn92sE1iiZF/MsZDAGTTuGDlzvXss6EWHCrGQ4RHS/ClSGE20kWkM20bYhsGjdKaJW5fxTKbkB3+t3DOI+61ROUXB5KC9EhICWkuGs9P6lR/YR3bsMugT/G3V3mwRVbKKMwKvDBhMoBZZK1n2y8yNkxKaHFTsKPdZ1HFfGO6SpagIvCyee7xHlqX7Z9y2/Xrk4/CMvrUPXDOZoVJLoB/r8bs4bOGo+jPVKjtGEDEO6ZPlzSQcz2mcv2IZVweTDBjKk7d78NI5vP4bykxU4Ufu18JnFtA0XWi7jZyFhI3Ct5yZOfl8FL8NgW+bWFeHzxPXdM73CEgRctSzGUjIl6OJwubAWd/4aRnltBQoPFuD86UakaVOgT9XDvCMbt37tQWR8JLbmZ6GvcwCv7CjC+yVvrRjzF1peh81tD0i2SMV36DnF7s0FciIZkg3w63woOvIsJrUzSMl6AGmmVDxZnIsniiyI22LAQzu3oPPPmyu6nBpSml0cwJDBxFqjdFbLsuQvgfWxcHFuOInm7DHht6s3UH+uCX69D14tQ+adcMzMwXZvHAc+fBPN19TvDXoURbGKLNlii7Q7szFb/gHjp2AXXKwbuk0aPP6aGbZRO642/I5/BkbIvAuxj+kRszca49vt+OB0Je675lWtVqxrUYIFa80kGZTC+olVBCrAidVejReZxQ9jyjmDrpbbmHBOkc+dYGMY8Do/uAc59A4Nqlqdt0m+eKzBMV4mssXU3cIG3Fgg8ORnEsEn8ej8rAsTU5Pg3D74PD5Ep+pQfqpCPdZR8QHvQ4JZ/2KMqUsXXe6Cx+sB62GRmGtAnDkWo83jGLtlx3y/EzpDJCbYe9hz5FXhuIWSMCxetNRNgIyHgZ9YRpUnmmDWIypZg+meWUzPTIN1MkgwkXjHj+Dz76rCAgs3ypjLHgj2MXAxxL0LXvgWOPgXfILyIpxqTIqWuFgL178ejPbbwbgZaBN1GHfYAxLt+uQfULIksFC+6CEXD7ogHOcD5+FkiKBu6dmvgGugJW5m5jiMDE4B2VrMJs0FJNqNJXC3DBbrprCT+rs/LYFn2UAohYlWC+6m1nM8QF76dB3is6PBOVkMnBtCpE2DjNTFi4iWSslaqUZrFZ6tIVpRN9yEUnKJWHPzUZhWgCutbdDoyf78PHgfL44QRjWJStRANxeD3vpWea5uyZga6UEJ/oIWJeJqY/Wd80Jlavj0DBrbm3F7sG9NlenQ8y/Lz2fJWqKbHSIjdC3+Zayd36j0zQ7ylkuFqjU5QgVOfWSl19w3+SdWbHVWE9oKlXS8LbVBbSS2u1Y7xy/SzKM/KOl4B1/1n1kzlLpXAe0W1wyr56IVpFW60GmZPJpzWFllVIV2G4qYStBdxFrHWtvbSprpgVXGhLwg9/eR9pbCglrcjwmwct0NPYE/KsJDNfPBTT2FDm/4n4RiE/tF9xcomnzqzkt0JLDG//UvzAqbaBU9oBrD1USL9QvNVON6oFT+E2AAP+b7j4cQE+gAAAAASUVORK5CYII="

/***/ }),

/***/ "835b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1300");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/AssertionError
 */

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError = /** @class */ (function (_super) {
    __extends(AssertionError, _super);
    /**
     * @param {number} code Error code.
     */
    function AssertionError(code) {
        var _this = this;
        var path = _util_js__WEBPACK_IMPORTED_MODULE_0__[/* VERSION */ "a"] === 'latest' ? _util_js__WEBPACK_IMPORTED_MODULE_0__[/* VERSION */ "a"] : 'v' + _util_js__WEBPACK_IMPORTED_MODULE_0__[/* VERSION */ "a"].split('-')[0];
        var message = 'Assertion failed. See https://openlayers.org/en/' +
            path +
            '/doc/errors/#' +
            code +
            ' for details.';
        _this = _super.call(this, message) || this;
        /**
         * Error code. The meaning of the code can be found on
         * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
         * the version found in the OpenLayers script's header comment if a version
         * other than the latest is used).
         * @type {number}
         * @api
         */
        _this.code = code;
        /**
         * @type {string}
         */
        _this.name = 'AssertionError';
        // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
        _this.message = message;
        return _this;
    }
    return AssertionError;
}(Error));
/* harmony default export */ __webpack_exports__["a"] = (AssertionError);
//# sourceMappingURL=AssertionError.js.map

/***/ }),

/***/ "83a6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/style/Fill
 */
/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */
/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill = /** @class */ (function () {
    /**
     * @param {Options} [opt_options] Options.
     */
    function Fill(opt_options) {
        var options = opt_options || {};
        /**
         * @private
         * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
         */
        this.color_ = options.color !== undefined ? options.color : null;
    }
    /**
     * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
     * @return {Fill} The cloned style.
     * @api
     */
    Fill.prototype.clone = function () {
        var color = this.getColor();
        return new Fill({
            color: Array.isArray(color) ? color.slice() : color || undefined,
        });
    };
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
     * @api
     */
    Fill.prototype.getColor = function () {
        return this.color_;
    };
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
     * @api
     */
    Fill.prototype.setColor = function (color) {
        this.color_ = color;
    };
    return Fill;
}());
/* harmony default export */ __webpack_exports__["a"] = (Fill);
//# sourceMappingURL=Fill.js.map

/***/ }),

/***/ "83ab":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "83c0":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAWsSURBVEhLzVdZbJRVFD6AIJals4AbAU1kcSMESTBxwcQXX3wwUSJqTERColGB4AJaxBg00QejEAWXRFSCNEjpvklrQWrRDKGQWlPa2nbazvLP1tln/tmO371zy3ToUIs1xi+5+Xt77z3fOeeee84Z+t+DiWb4aME6D5nedpHpqJMMp21ksDjJeEoj0xE3mXf4ybRWbZ86Wohmg2ibl8ydfprLcZrOYZrGAZqJMZuD+EYwF//3Yd1LJguU26iO/zMMkflhH5l/T9AcHoHR2vVL2ffkRg5/coBjVQ0cbzrFseoGDu/9nH0bnmfXDcugzDTWqQhKmNv6qXi1EjV5DJP5JbgOFhE7Fi3j8L4DnPb6eCKkfSMc/vQLdi5eAS8QyI3RITI9oUT+PbB5SxykLhz2rn+W0y63Es2sJxLc3z/AnZ2d3NfXx7FYTK3kkHZ72fvURrid4AEjD0yG3EbGR8JkZg2H/Ft3KlFZeL1ebmz8kY8fL+fy8gr5ra9vYE3T1I58+LeXSHIfmfQhMqxSFOMB1xQ7yWT3i83rn5OHA6EQX7hwgbu7e7ipqZkrKiq5trbu0qisrJLK9PT0sMVyls+da2ePxyvPCvie3oxgJLaT6TwC9RpFlQ87md9PIjAci1ZwJhjiZCbDJ0408bFjZdLC6uqaPNLRUVNTK9eFUsIL4muz2SRxJhxh55K7OEHXsY0WbFZUOSACDdDK54Z2ka8OyUPBYJCrqqql4EKEVxrCC83NP3EGigtEvi1lP6Id13hxnNVIBs/E8GycN9/JmVicU+k0t7WdkUIKCZ9oCEWFdwKBgCTO6Dq7Fq9EoBXxIBnWKcosoM13UWjl37RVbrY7HNJthQRPZghPCatHo97/wqtIMtLq9xRlFnBzu3BH5OD3cqPVap0SsRgiNgYGrFJe9NBRBNl0EBtqFaWw9qYiOxlsHqRA/WSr3BiJRLiurl4GjdD+aoe4orKy4+xyuaQ8vfVX3HMRotvQrmhFlppnhiYIrLmcsLTLjQLi3ba2tspnJNx2+TjZ0sI/YxRaE2e6u7uVJObE2fNIu/NBXHxR0RKhsswDseZByOunz6itY5BJy5FGwI0dET3FsUQqbw0T+R2N6FHobRZYPAeuLu5QtHg/RNNw6X/4cAfRwz+orTnEhbwCaByM8voGBwcTOZII9CiE6NEK5P0ZIriaFW0WdjKWiwzjf2WH2ppDaXeQNzU7OZ7Kt+JYb5Bpbxc3WMNynoKVGxrt3KjmYxHYvotjMoMZ9yrKLGwoDKKcabetgYR8tfd3jDDt62KLll8Qgnqay3pDPBLP7o8l07z8UD8/WjMs55cAhVzL70XFEtnL/JiizAIuWIJuIuGEu2Nl1epEFlo0xUdgdTiR9fnotxCahiL8iyOqZlmI2u2Bm4fJ6NZo4VxFmQPe8mGdrmXtjrXMyStcFrDH4uHdv3k4rTyfxB/WYCI7uRwINO3u+zgJuaIWKKp8DNLCpR4y66IOB7a8qU6Ox4stGhu/6mU3PCEwHE7yPaVWPmWLyPlYBF7bjbJIjKrnHqT5JkU1HmgCtqXQBNiQxUIffaaO56PLp3P5nyHk86zJgvjGr3u55EyuYRAIf7yfHeLq0AxA7uOK4spAABzMkAHk0znw+q4J3T6KDk+cXbqaQKHAzndAOoNTVAxSc35+nghOMn+TgqbC7a41D6Kpq1dSJ0astpFdax9CMBGaPiMCyvShEjl5aGR8A91iPE6zcEcz2bXqfg6+9S7HKus40d7Bya4eTpzvkFEbLNnDrtUPoGWaBcJZosv0OabS5qJ+roSQUjcZkzqKSAiWeKGEAy7E25dfMRfJJ451DxnC6LG+RGNxqxIxNSCf3y5+LbjJVI/33gcCXIMgNcAbxh408ZUgfNlHhlvUkX8fyO0z8TxKmBaKJu4D8fNGLf03gKs3iQKjplcBor8A3W0xrHEYVogAAAAASUVORK5CYII="

/***/ }),

/***/ "8418":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPropertyKey = __webpack_require__("a04b");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "843f":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0290.e812c663.png";

/***/ }),

/***/ "84aa":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "8505":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "861d":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "8682":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/style/Stroke
 */
/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */
/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke = /** @class */ (function () {
    /**
     * @param {Options} [opt_options] Options.
     */
    function Stroke(opt_options) {
        var options = opt_options || {};
        /**
         * @private
         * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
         */
        this.color_ = options.color !== undefined ? options.color : null;
        /**
         * @private
         * @type {CanvasLineCap|undefined}
         */
        this.lineCap_ = options.lineCap;
        /**
         * @private
         * @type {Array<number>}
         */
        this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
        /**
         * @private
         * @type {number|undefined}
         */
        this.lineDashOffset_ = options.lineDashOffset;
        /**
         * @private
         * @type {CanvasLineJoin|undefined}
         */
        this.lineJoin_ = options.lineJoin;
        /**
         * @private
         * @type {number|undefined}
         */
        this.miterLimit_ = options.miterLimit;
        /**
         * @private
         * @type {number|undefined}
         */
        this.width_ = options.width;
    }
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */
    Stroke.prototype.clone = function () {
        var color = this.getColor();
        return new Stroke({
            color: Array.isArray(color) ? color.slice() : color || undefined,
            lineCap: this.getLineCap(),
            lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
            lineDashOffset: this.getLineDashOffset(),
            lineJoin: this.getLineJoin(),
            miterLimit: this.getMiterLimit(),
            width: this.getWidth(),
        });
    };
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */
    Stroke.prototype.getColor = function () {
        return this.color_;
    };
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */
    Stroke.prototype.getLineCap = function () {
        return this.lineCap_;
    };
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>} Line dash.
     * @api
     */
    Stroke.prototype.getLineDash = function () {
        return this.lineDash_;
    };
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
    Stroke.prototype.getLineDashOffset = function () {
        return this.lineDashOffset_;
    };
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */
    Stroke.prototype.getLineJoin = function () {
        return this.lineJoin_;
    };
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
    Stroke.prototype.getMiterLimit = function () {
        return this.miterLimit_;
    };
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
    Stroke.prototype.getWidth = function () {
        return this.width_;
    };
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */
    Stroke.prototype.setColor = function (color) {
        this.color_ = color;
    };
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */
    Stroke.prototype.setLineCap = function (lineCap) {
        this.lineCap_ = lineCap;
    };
    /**
     * Set the line dash.
     *
     * Please note that Internet Explorer 10 and lower [do not support][mdn] the
     * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
     * property will have no visual effect in these browsers.
     *
     * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
     *
     * @param {Array<number>} lineDash Line dash.
     * @api
     */
    Stroke.prototype.setLineDash = function (lineDash) {
        this.lineDash_ = lineDash;
    };
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
    Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
    };
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */
    Stroke.prototype.setLineJoin = function (lineJoin) {
        this.lineJoin_ = lineJoin;
    };
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
    Stroke.prototype.setMiterLimit = function (miterLimit) {
        this.miterLimit_ = miterLimit;
    };
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
    Stroke.prototype.setWidth = function (width) {
        this.width_ = width;
    };
    return Stroke;
}());
/* harmony default export */ __webpack_exports__["a"] = (Stroke);
//# sourceMappingURL=Stroke.js.map

/***/ }),

/***/ "869f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/ImageState
 */
/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4,
});
//# sourceMappingURL=ImageState.js.map

/***/ }),

/***/ "8778":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0ec0");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1300");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/ImageBase
 */



/**
 * @abstract
 */
var ImageBase = /** @class */ (function (_super) {
    __extends(ImageBase, _super);
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number|undefined} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./ImageState.js").default} state State.
     */
    function ImageBase(extent, resolution, pixelRatio, state) {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {import("./extent.js").Extent}
         */
        _this.extent = extent;
        /**
         * @private
         * @type {number}
         */
        _this.pixelRatio_ = pixelRatio;
        /**
         * @protected
         * @type {number|undefined}
         */
        _this.resolution = resolution;
        /**
         * @protected
         * @type {import("./ImageState.js").default}
         */
        _this.state = state;
        return _this;
    }
    /**
     * @protected
     */
    ImageBase.prototype.changed = function () {
        this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE);
    };
    /**
     * @return {import("./extent.js").Extent} Extent.
     */
    ImageBase.prototype.getExtent = function () {
        return this.extent;
    };
    /**
     * @abstract
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     */
    ImageBase.prototype.getImage = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * @return {number} PixelRatio.
     */
    ImageBase.prototype.getPixelRatio = function () {
        return this.pixelRatio_;
    };
    /**
     * @return {number} Resolution.
     */
    ImageBase.prototype.getResolution = function () {
        return /** @type {number} */ (this.resolution);
    };
    /**
     * @return {import("./ImageState.js").default} State.
     */
    ImageBase.prototype.getState = function () {
        return this.state;
    };
    /**
     * Load not yet loaded URI.
     * @abstract
     */
    ImageBase.prototype.load = function () {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    return ImageBase;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (ImageBase);
//# sourceMappingURL=ImageBase.js.map

/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "88da":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryLayout.js
var GeometryLayout = __webpack_require__("521b");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js
var GeometryType = __webpack_require__("f623");

// EXTERNAL MODULE: ./node_modules/ol/geom/MultiPoint.js
var MultiPoint = __webpack_require__("9a44");

// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules
var Polygon = __webpack_require__("5bc3");

// EXTERNAL MODULE: ./node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = __webpack_require__("9abc");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/closest.js
var closest = __webpack_require__("9769");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/deflate.js
var deflate = __webpack_require__("abb7");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/interiorpoint.js
var interiorpoint = __webpack_require__("0a9d");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js
var inflate = __webpack_require__("bb6c");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/intersectsextent.js
var intersectsextent = __webpack_require__("c560");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/orient.js + 1 modules
var orient = __webpack_require__("4d98");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/area.js
var flat_area = __webpack_require__("b589");

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/center.js
/**
 * @module ol/geom/flat/center
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
    var flatCenters = [];
    var extent = Object(ol_extent["j" /* createEmpty */])();
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        extent = Object(ol_extent["n" /* createOrUpdateFromFlatCoordinates */])(flatCoordinates, offset, ends[0], stride);
        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
        offset = ends[ends.length - 1];
    }
    return flatCenters;
}
//# sourceMappingURL=center.js.map
// EXTERNAL MODULE: ./node_modules/ol/geom/flat/contains.js
var contains = __webpack_require__("25f1");

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js
var simplify = __webpack_require__("1c48");

// CONCATENATED MODULE: ./node_modules/ol/geom/MultiPolygon.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/MultiPolygon
 */

















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
var MultiPolygon_MultiPolygon = /** @class */ (function (_super) {
    __extends(MultiPolygon, _super);
    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.
     */
    function MultiPolygon(coordinates, opt_layout, opt_endss) {
        var _this = _super.call(this) || this;
        /**
         * @type {Array<Array<number>>}
         * @private
         */
        _this.endss_ = [];
        /**
         * @private
         * @type {number}
         */
        _this.flatInteriorPointsRevision_ = -1;
        /**
         * @private
         * @type {Array<number>}
         */
        _this.flatInteriorPoints_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.maxDeltaRevision_ = -1;
        /**
         * @private
         * @type {number}
         */
        _this.orientedRevision_ = -1;
        /**
         * @private
         * @type {Array<number>}
         */
        _this.orientedFlatCoordinates_ = null;
        if (!opt_endss && !Array.isArray(coordinates[0])) {
            var layout = _this.getLayout();
            var polygons = /** @type {Array<Polygon>} */ (coordinates);
            var flatCoordinates = [];
            var endss = [];
            for (var i = 0, ii = polygons.length; i < ii; ++i) {
                var polygon = polygons[i];
                if (i === 0) {
                    layout = polygon.getLayout();
                }
                var offset = flatCoordinates.length;
                var ends = polygon.getEnds();
                for (var j = 0, jj = ends.length; j < jj; ++j) {
                    ends[j] += offset;
                }
                Object(array["c" /* extend */])(flatCoordinates, polygon.getFlatCoordinates());
                endss.push(ends);
            }
            opt_layout = layout;
            coordinates = flatCoordinates;
            opt_endss = endss;
        }
        if (opt_layout !== undefined && opt_endss) {
            _this.setFlatCoordinates(opt_layout, 
            /** @type {Array<number>} */ (coordinates));
            _this.endss_ = opt_endss;
        }
        else {
            _this.setCoordinates(
            /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (coordinates), opt_layout);
        }
        return _this;
    }
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */
    MultiPolygon.prototype.appendPolygon = function (polygon) {
        /** @type {Array<number>} */
        var ends;
        if (!this.flatCoordinates) {
            this.flatCoordinates = polygon.getFlatCoordinates().slice();
            ends = polygon.getEnds().slice();
            this.endss_.push();
        }
        else {
            var offset = this.flatCoordinates.length;
            Object(array["c" /* extend */])(this.flatCoordinates, polygon.getFlatCoordinates());
            ends = polygon.getEnds().slice();
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                ends[i] += offset;
            }
        }
        this.endss_.push(ends);
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     */
    MultiPolygon.prototype.clone = function () {
        var len = this.endss_.length;
        var newEndss = new Array(len);
        for (var i = 0; i < len; ++i) {
            newEndss[i] = this.endss_[i].slice();
        }
        var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
        multiPolygon.applyProperties(this);
        return multiPolygon;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < Object(ol_extent["e" /* closestSquaredDistanceXY */])(this.getExtent(), x, y)) {
            return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(Object(closest["f" /* multiArrayMaxSquaredDelta */])(this.flatCoordinates, 0, this.endss_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return Object(closest["c" /* assignClosestMultiArrayPoint */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    MultiPolygon.prototype.containsXY = function (x, y) {
        return Object(contains["d" /* linearRingssContainsXY */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
    };
    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    MultiPolygon.prototype.getArea = function () {
        return Object(flat_area["c" /* linearRingss */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    };
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [opt_right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     */
    MultiPolygon.prototype.getCoordinates = function (opt_right) {
        var flatCoordinates;
        if (opt_right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            Object(orient["d" /* orientLinearRingsArray */])(flatCoordinates, 0, this.endss_, this.stride, opt_right);
        }
        else {
            flatCoordinates = this.flatCoordinates;
        }
        return Object(inflate["c" /* inflateMultiCoordinatesArray */])(flatCoordinates, 0, this.endss_, this.stride);
    };
    /**
     * @return {Array<Array<number>>} Endss.
     */
    MultiPolygon.prototype.getEndss = function () {
        return this.endss_;
    };
    /**
     * @return {Array<number>} Flat interior points.
     */
    MultiPolygon.prototype.getFlatInteriorPoints = function () {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            var flatCenters = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = Object(interiorpoint["b" /* getInteriorPointsOfMultiArray */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
            this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return this.flatInteriorPoints_;
    };
    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */
    MultiPolygon.prototype.getInteriorPoints = function () {
        return new MultiPoint["a" /* default */](this.getFlatInteriorPoints().slice(), GeometryLayout["a" /* default */].XYM);
    };
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
        if (this.orientedRevision_ != this.getRevision()) {
            var flatCoordinates = this.flatCoordinates;
            if (Object(orient["b" /* linearRingssAreOriented */])(flatCoordinates, 0, this.endss_, this.stride)) {
                this.orientedFlatCoordinates_ = flatCoordinates;
            }
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = Object(orient["d" /* orientLinearRingsArray */])(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     */
    MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEndss = [];
        simplifiedFlatCoordinates.length = Object(simplify["d" /* quantizeMultiArray */])(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY, simplifiedEndss);
    };
    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */
    MultiPolygon.prototype.getPolygon = function (index) {
        if (index < 0 || this.endss_.length <= index) {
            return null;
        }
        var offset;
        if (index === 0) {
            offset = 0;
        }
        else {
            var prevEnds = this.endss_[index - 1];
            offset = prevEnds[prevEnds.length - 1];
        }
        var ends = this.endss_[index].slice();
        var end = ends[ends.length - 1];
        if (offset !== 0) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
                ends[i] -= offset;
            }
        }
        return new Polygon["a" /* default */](this.flatCoordinates.slice(offset, end), this.layout, ends);
    };
    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */
    MultiPolygon.prototype.getPolygons = function () {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var endss = this.endss_;
        var polygons = [];
        var offset = 0;
        for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i].slice();
            var end = ends[ends.length - 1];
            if (offset !== 0) {
                for (var j = 0, jj = ends.length; j < jj; ++j) {
                    ends[j] -= offset;
                }
            }
            var polygon = new Polygon["a" /* default */](flatCoordinates.slice(offset, end), layout, ends);
            polygons.push(polygon);
            offset = end;
        }
        return polygons;
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    MultiPolygon.prototype.getType = function () {
        return GeometryType["a" /* default */].MULTI_POLYGON;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    MultiPolygon.prototype.intersectsExtent = function (extent) {
        return Object(intersectsextent["d" /* intersectsLinearRingMultiArray */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
    };
    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */
    MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 3);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        var endss = Object(deflate["d" /* deflateMultiCoordinatesArray */])(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
        if (endss.length === 0) {
            this.flatCoordinates.length = 0;
        }
        else {
            var lastEnds = endss[endss.length - 1];
            this.flatCoordinates.length =
                lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
    };
    return MultiPolygon;
}(SimpleGeometry["a" /* default */]));
/* harmony default export */ var geom_MultiPolygon = __webpack_exports__["a"] = (MultiPolygon_MultiPolygon);
//# sourceMappingURL=MultiPolygon.js.map

/***/ }),

/***/ "8925":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var isCallable = __webpack_require__("1626");
var store = __webpack_require__("c6cd");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "8aa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "8cc5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return disable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return none; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createSnapToN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createSnapToZero; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7fc9");
/**
 * @module ol/rotationconstraint
 */

/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function disable(rotation) {
    if (rotation !== undefined) {
        return 0;
    }
    else {
        return undefined;
    }
}
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function none(rotation) {
    if (rotation !== undefined) {
        return rotation;
    }
    else {
        return undefined;
    }
}
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */
function createSnapToN(n) {
    var theta = (2 * Math.PI) / n;
    return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
        if (opt_isMoving) {
            return rotation;
        }
        if (rotation !== undefined) {
            rotation = Math.floor(rotation / theta + 0.5) * theta;
            return rotation;
        }
        else {
            return undefined;
        }
    });
}
/**
 * @param {number} [opt_tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */
function createSnapToZero(opt_tolerance) {
    var tolerance = opt_tolerance || Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "l"])(5);
    return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
        if (opt_isMoving) {
            return rotation;
        }
        if (rotation !== undefined) {
            if (Math.abs(rotation) <= tolerance) {
                return 0;
            }
            else {
                return rotation;
            }
        }
        else {
            return undefined;
        }
    });
}
//# sourceMappingURL=rotationconstraint.js.map

/***/ }),

/***/ "8f37":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fced");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1300");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("a896");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0af5");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("256f");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("57cb");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("bef8");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/Geometry
 */








/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_3__[/* create */ "c"])();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
var Geometry = /** @class */ (function (_super) {
    __extends(Geometry, _super);
    function Geometry() {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */
        _this.extent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* createEmpty */ "j"])();
        /**
         * @private
         * @type {number}
         */
        _this.extentRevision_ = -1;
        /**
         * @protected
         * @type {number}
         */
        _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        /**
         * @protected
         * @type {number}
         */
        _this.simplifiedGeometryRevision = 0;
        /**
         * Get a transformed and simplified version of the geometry.
         * @abstract
         * @param {number} revision The geometry revision.
         * @param {number} squaredTolerance Squared tolerance.
         * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
         * @return {Geometry} Simplified geometry.
         */
        _this.simplifyTransformedInternal = Object(_functions_js__WEBPACK_IMPORTED_MODULE_6__[/* memoizeOne */ "d"])(function (revision, squaredTolerance, opt_transform) {
            if (!opt_transform) {
                return this.getSimplifiedGeometry(squaredTolerance);
            }
            var clone = this.clone();
            clone.applyTransform(opt_transform);
            return clone.getSimplifiedGeometry(squaredTolerance);
        });
        return _this;
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
    };
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */
    Geometry.prototype.clone = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    Geometry.prototype.containsXY = function (x, y) {
        var coord = this.getClosestPoint([x, y]);
        return coord[0] === x && coord[1] === y;
    };
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [opt_closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */
    Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
        var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
    };
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */
    Geometry.prototype.intersectsCoordinate = function (coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
    };
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    Geometry.prototype.computeExtent = function (extent) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [opt_extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */
    Geometry.prototype.getExtent = function (opt_extent) {
        if (this.extentRevision_ != this.getRevision()) {
            var extent = this.computeExtent(this.extent_);
            if (isNaN(extent[0]) || isNaN(extent[1])) {
                Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* createOrUpdateEmpty */ "l"])(extent);
            }
            this.extentRevision_ = this.getRevision();
        }
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* returnOrUpdate */ "H"])(this.extent_, opt_extent);
    };
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    Geometry.prototype.rotate = function (angle, anchor) {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */
    Geometry.prototype.simplify = function (tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
    };
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */
    Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {import("./GeometryType.js").default} Geometry type.
     */
    Geometry.prototype.getType = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */
    Geometry.prototype.applyTransform = function (transformFn) {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */
    Geometry.prototype.intersectsExtent = function (extent) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    Geometry.prototype.translate = function (deltaX, deltaY) {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {Geometry} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */
    Geometry.prototype.transform = function (source, destination) {
        /** @type {import("../proj/Projection.js").default} */
        var sourceProj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__[/* get */ "m"])(source);
        var transformFn = sourceProj.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"].TILE_PIXELS
            ? function (inCoordinates, outCoordinates, stride) {
                var pixelExtent = sourceProj.getExtent();
                var projectedExtent = sourceProj.getWorldExtent();
                var scale = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* getHeight */ "z"])(projectedExtent) / Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__[/* getHeight */ "z"])(pixelExtent);
                Object(_transform_js__WEBPACK_IMPORTED_MODULE_3__[/* compose */ "b"])(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
                Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_7__[/* transform2D */ "c"])(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
                return Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__[/* getTransform */ "o"])(sourceProj, destination)(inCoordinates, outCoordinates, stride);
            }
            : Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__[/* getTransform */ "o"])(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
    };
    return Geometry;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (Geometry);
//# sourceMappingURL=Geometry.js.map

/***/ }),

/***/ "8fc6":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0091.d932046d.png";

/***/ }),

/***/ "90e3":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "9112":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "9263":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var toString = __webpack_require__("577e");
var regexpFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");
var shared = __webpack_require__("5692");
var create = __webpack_require__("7c73");
var getInternalState = __webpack_require__("69f3").get;
var UNSUPPORTED_DOT_ALL = __webpack_require__("fce3");
var UNSUPPORTED_NCG = __webpack_require__("107c");

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call(nativeExec, re1, 'a');
  call(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice(match.input, charsAdded);
        match[0] = stringSlice(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      call(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "92fa":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assert; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("835b");
/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
    if (!assertion) {
        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](errorCode);
    }
}
//# sourceMappingURL=asserts.js.map

/***/ }),

/***/ "936b":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAOASURBVEhL1ZVdSJNRGMeP+7CZzaXi1tKKCqKSMij7sC6MCAIrsRujr4sMia66KhXSoLqo6MtIo1yfRF9QUUF1YdpVmX1hdiUlRV4YtNp0undz+/ecs6Ob7963MF3QHx442845v/f/PM+el/13SkmxF6+ck/mWMcdi+dW/UHZR1Xqr4nEZUb4yzc1YTr78IZHKLtpTZA3gMkPoEoO/IQllhQmHR6H+8wzeeoaAi0FxJWFH4uAq6FmGHopYeAKca0MHI0Fwgq4lKF3cf2a40/5zDLgaiUADgXmMTdqlU3IZuDMffY9L4D0ZAXPnH48YULctBae2jEdLtQn9BB4D5xJKF/ldVoR+doDLd3uhgIM6unGPGeMtk8AMThwuTRXOR5l2Cb3IoTYMdL8QUK6w4kHv9VyEyfGzSjOyM+1ItzqEa1yJr/kI0h5tpP46hr5HxRj42ggE+wR44Fsr/M8rAUrr070mpKU6YDJPwtGN5FiC/6LhotCh7uUNRRHu+SLAvtsL4D3BEKRL2w4YyZENW1fYcH/3OAQpQ4PgEcA1oDzIdc95M8K9XQLcd79Q1HjgAkNrjQlr8tJRODcD13ZaxCSLBavhcWl32uwlVesIykdgLJQHHfSeJlBXkwAHO+9FmovATRVmZKY5YKEGO7YpWmN1DML5eN21Ks2dPsG5grA1huWzMjoDDQbRqXxT3MFTVOuHqwWYS3lzCGHa11xhhDPDDtsEB05u1gfz8NB+3vXdtSbkTslsFo4tlskF/C2j0BPxJ9OEk0vlzUGJJrXtQ9NuhiyLAakGE46XJomL1efEWbovRPV31xlRunTip2TmnC3AEeXk8xrwWmjCqdbceaD9jCQD359sR+vFrXh5tRyfL+TBp/XAEvqj3ogNi9I/MTZ1hgTGKiefd58enIN9N3MllvSjXS7o//1uPzzU7cP2D0LJKUE7CTpdgrSkD/fWUq3vLJEoIPTtNcLBXrFWWiqGxqkGVM+pWtppjwe/0gQPQX+fXj3FOxfguwUCxBVyf0BYrpXWagFWOf1TevU0HO4hsO/WPIS+vxcR7LhBc7yF1u3wN5fBQz3wF+nVk0baNWKU6dVTjHN6OXj5GI2F0ucQTbJRpldP2t2uqulYOVUrPu0JSK+eIs75wOcjko/BBKRXTzn5u1ZZ3Z9rk8XsTbBTtezLFkzLesDYlJnyixGIsV8M7kAAeh3rVgAAAABJRU5ErkJggg=="

/***/ }),

/***/ "94ca":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "9670":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "96dc":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0094.431032db.png";

/***/ }),

/***/ "9769":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return maxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return multiArrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return assignClosestPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assignClosestArrayPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return assignClosestMultiArrayPoint; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7fc9");
/**
 * @module ol/geom/flat/closest
 */

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
    var x1 = flatCoordinates[offset1];
    var y1 = flatCoordinates[offset1 + 1];
    var dx = flatCoordinates[offset2] - x1;
    var dy = flatCoordinates[offset2 + 1] - y1;
    var offset;
    if (dx === 0 && dy === 0) {
        offset = offset1;
    }
    else {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            offset = offset2;
        }
        else if (t > 0) {
            for (var i = 0; i < stride; ++i) {
                closestPoint[i] = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* lerp */ "e"])(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
            }
            closestPoint.length = stride;
            return;
        }
        else {
            offset = offset1;
        }
    }
    for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
    }
    closestPoint.length = stride;
}
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    for (offset += stride; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        var squaredDelta = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "i"])(x1, y1, x2, y2);
        if (squaredDelta > max) {
            max = squaredDelta;
        }
        x1 = x2;
        y1 = y2;
    }
    return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
        offset = end;
    }
    return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
        offset = ends[ends.length - 1];
    }
    return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
    if (offset == end) {
        return minSquaredDistance;
    }
    var i, squaredDistance;
    if (maxDelta === 0) {
        // All points are identical, so just test the first point.
        squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "i"])(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
        if (squaredDistance < minSquaredDistance) {
            for (i = 0; i < stride; ++i) {
                closestPoint[i] = flatCoordinates[offset + i];
            }
            closestPoint.length = stride;
            return squaredDistance;
        }
        else {
            return minSquaredDistance;
        }
    }
    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
    var index = offset + stride;
    while (index < end) {
        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
        squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "i"])(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for (i = 0; i < stride; ++i) {
                closestPoint[i] = tmpPoint[i];
            }
            closestPoint.length = stride;
            index += stride;
        }
        else {
            // Skip ahead multiple points, because we know that all the skipped
            // points cannot be any closer than the closest point we have found so
            // far.  We know this because we know how close the current point is, how
            // close the closest point we have found so far is, and the maximum
            // distance between consecutive points.  For example, if we're currently
            // at distance 10, the best we've found so far is 3, and that the maximum
            // distance between consecutive points is 2, then we'll need to skip at
            // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
            // finding a closer point.  We use Math.max(..., 1) to ensure that we
            // always advance at least one point, to avoid an infinite loop.
            index +=
                stride *
                    Math.max(((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /
                        maxDelta) |
                        0, 1);
        }
    }
    if (isRing) {
        // Check the closing segment.
        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
        squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "i"])(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for (i = 0; i < stride; ++i) {
                closestPoint[i] = tmpPoint[i];
            }
            closestPoint.length = stride;
        }
    }
    return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = end;
    }
    return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = ends[ends.length - 1];
    }
    return minSquaredDistance;
}
//# sourceMappingURL=closest.js.map

/***/ }),

/***/ "97c6":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "9a1f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var aCallable = __webpack_require__("59ed");
var anObject = __webpack_require__("825a");
var tryToString = __webpack_require__("0d51");
var getIteratorMethod = __webpack_require__("35a1");

var TypeError = global.TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "9a44":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f623");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("f403");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("9abc");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("0af5");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("abb7");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("9f5e");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("bb6c");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("7fc9");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/MultiPoint
 */








/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
var MultiPoint = /** @class */ (function (_super) {
    __extends(MultiPoint, _super);
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */
    function MultiPoint(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        if (opt_layout && !Array.isArray(coordinates[0])) {
            _this.setFlatCoordinates(opt_layout, 
            /** @type {Array<number>} */ (coordinates));
        }
        else {
            _this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
        }
        return _this;
    }
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */
    MultiPoint.prototype.appendPoint = function (point) {
        if (!this.flatCoordinates) {
            this.flatCoordinates = point.getFlatCoordinates().slice();
        }
        else {
            Object(_array_js__WEBPACK_IMPORTED_MODULE_5__[/* extend */ "c"])(this.flatCoordinates, point.getFlatCoordinates());
        }
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     */
    MultiPoint.prototype.clone = function () {
        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
        multiPoint.applyProperties(this);
        return multiPoint;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* closestSquaredDistanceXY */ "e"])(this.getExtent(), x, y)) {
            return minSquaredDistance;
        }
        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;
        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
            var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_7__[/* squaredDistance */ "i"])(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
            if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for (var j = 0; j < stride; ++j) {
                    closestPoint[j] = flatCoordinates[i + j];
                }
                closestPoint.length = stride;
            }
        }
        return minSquaredDistance;
    };
    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
    MultiPoint.prototype.getCoordinates = function () {
        return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__[/* inflateCoordinates */ "a"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */
    MultiPoint.prototype.getPoint = function (index) {
        var n = !this.flatCoordinates
            ? 0
            : this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) {
            return null;
        }
        return new _Point_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"](this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
    };
    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */
    MultiPoint.prototype.getPoints = function () {
        var flatCoordinates = this.flatCoordinates;
        var layout = this.layout;
        var stride = this.stride;
        /** @type {Array<Point>} */
        var points = [];
        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
            var point = new _Point_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"](flatCoordinates.slice(i, i + stride), layout);
            points.push(point);
        }
        return points;
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    MultiPoint.prototype.getType = function () {
        return _GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].MULTI_POINT;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    MultiPoint.prototype.intersectsExtent = function (extent) {
        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;
        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
            var x = flatCoordinates[i];
            var y = flatCoordinates[i + 1];
            if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* containsXY */ "h"])(extent, x, y)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */
    MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_4__[/* deflateCoordinates */ "b"])(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return MultiPoint;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (MultiPoint);
//# sourceMappingURL=MultiPoint.js.map

/***/ }),

/***/ "9abc":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getStrideForLayout */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return transformGeom2D; });
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8f37");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("521b");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1300");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("0af5");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("bef8");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/SimpleGeometry
 */





/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry = /** @class */ (function (_super) {
    __extends(SimpleGeometry, _super);
    function SimpleGeometry() {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {import("./GeometryLayout.js").default}
         */
        _this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XY;
        /**
         * @protected
         * @type {number}
         */
        _this.stride = 2;
        /**
         * @protected
         * @type {Array<number>}
         */
        _this.flatCoordinates = null;
        return _this;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    SimpleGeometry.prototype.computeExtent = function (extent) {
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* createOrUpdateFromFlatCoordinates */ "n"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    };
    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */
    SimpleGeometry.prototype.getCoordinates = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */
    SimpleGeometry.prototype.getFirstCoordinate = function () {
        return this.flatCoordinates.slice(0, this.stride);
    };
    /**
     * @return {Array<number>} Flat coordinates.
     */
    SimpleGeometry.prototype.getFlatCoordinates = function () {
        return this.flatCoordinates;
    };
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */
    SimpleGeometry.prototype.getLastCoordinate = function () {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
    };
    /**
     * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
     * @return {import("./GeometryLayout.js").default} Layout.
     * @api
     */
    SimpleGeometry.prototype.getLayout = function () {
        return this.layout;
    };
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     */
    SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        // If squaredTolerance is negative or if we know that simplification will not
        // have any effect then just return this.
        if (squaredTolerance < 0 ||
            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
            return this;
        }
        var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
            return simplifiedGeometry;
        }
        else {
            // Simplification did not actually remove any coordinates.  We now know
            // that any calls to getSimplifiedGeometry with a squaredTolerance less
            // than or equal to the current squaredTolerance will also not have any
            // effect.  This allows us to short circuit simplification (saving CPU
            // cycles) and prevents the cache of simplified geometries from filling
            // up with useless identical copies of this geometry (saving memory).
            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
            return this;
        }
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */
    SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
        return this;
    };
    /**
     * @return {number} Stride.
     */
    SimpleGeometry.prototype.getStride = function () {
        return this.stride;
    };
    /**
     * @param {import("./GeometryLayout.js").default} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */
    SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
    };
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */
    SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */
    SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
        /** @type {number} */
        var stride;
        if (layout) {
            stride = getStrideForLayout(layout);
        }
        else {
            for (var i = 0; i < nesting; ++i) {
                if (coordinates.length === 0) {
                    this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XY;
                    this.stride = 2;
                    return;
                }
                else {
                    coordinates = /** @type {Array} */ (coordinates[0]);
                }
            }
            stride = coordinates.length;
            layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
    };
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */
    SimpleGeometry.prototype.applyTransform = function (transformFn) {
        if (this.flatCoordinates) {
            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
            this.changed();
        }
    };
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    SimpleGeometry.prototype.rotate = function (angle, anchor) {
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            var stride = this.getStride();
            Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* rotate */ "a"])(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
            this.changed();
        }
    };
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
        var sy = opt_sy;
        if (sy === undefined) {
            sy = sx;
        }
        var anchor = opt_anchor;
        if (!anchor) {
            anchor = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* getCenter */ "w"])(this.getExtent());
        }
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            var stride = this.getStride();
            Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* scale */ "b"])(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
            this.changed();
        }
    };
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            var stride = this.getStride();
            Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* translate */ "d"])(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
            this.changed();
        }
    };
    return SimpleGeometry;
}(_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * @param {number} stride Stride.
 * @return {import("./GeometryLayout.js").default} layout Layout.
 */
function getLayoutForStride(stride) {
    var layout;
    if (stride == 2) {
        layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XY;
    }
    else if (stride == 3) {
        layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XYZ;
    }
    else if (stride == 4) {
        layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XYZM;
    }
    return /** @type {import("./GeometryLayout.js").default} */ (layout);
}
/**
 * @param {import("./GeometryLayout.js").default} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
    var stride;
    if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XY) {
        stride = 2;
    }
    else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XYZ || layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XYM) {
        stride = 3;
    }
    else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].XYZM) {
        stride = 4;
    }
    return /** @type {number} */ (stride);
}
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, opt_dest) {
    var flatCoordinates = simpleGeometry.getFlatCoordinates();
    if (!flatCoordinates) {
        return null;
    }
    else {
        var stride = simpleGeometry.getStride();
        return Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* transform2D */ "c"])(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
    }
}
/* harmony default export */ __webpack_exports__["a"] = (SimpleGeometry);
//# sourceMappingURL=SimpleGeometry.js.map

/***/ }),

/***/ "9bf2":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DESCRIPTORS = __webpack_require__("83ab");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__("aed9");
var anObject = __webpack_require__("825a");
var toPropertyKey = __webpack_require__("a04b");

var TypeError = global.TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "9c6a":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "9f5e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return numberSafeCompareFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return linearFindNearest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return reverseSubArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return extend; });
/* unused harmony export remove */
/* unused harmony export find */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return equals; });
/* unused harmony export stableSort */
/* unused harmony export findIndex */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isSorted; });
/**
 * @module ol/array
 */
/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [opt_comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
    var mid, cmp;
    var comparator = opt_comparator || numberSafeCompareFunction;
    var low = 0;
    var high = haystack.length;
    var found = false;
    while (low < high) {
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
         * to double (which gives the wrong results). */
        mid = low + ((high - low) >> 1);
        cmp = +comparator(haystack[mid], needle);
        if (cmp < 0.0) {
            /* Too low. */
            low = mid + 1;
        }
        else {
            /* Key found or too high */
            high = mid;
            found = !cmp;
        }
    }
    /* Key not found. */
    return found ? low : ~low;
}
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
    return arr.indexOf(obj) >= 0;
}
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */
/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
    var n = arr.length;
    if (arr[0] <= target) {
        return 0;
    }
    else if (target <= arr[n - 1]) {
        return n - 1;
    }
    else {
        var i = void 0;
        if (direction > 0) {
            for (i = 1; i < n; ++i) {
                if (arr[i] < target) {
                    return i - 1;
                }
            }
        }
        else if (direction < 0) {
            for (i = 1; i < n; ++i) {
                if (arr[i] <= target) {
                    return i;
                }
            }
        }
        else {
            for (i = 1; i < n; ++i) {
                if (arr[i] == target) {
                    return i;
                }
                else if (arr[i] < target) {
                    if (typeof direction === 'function') {
                        if (direction(target, arr[i - 1], arr[i]) > 0) {
                            return i - 1;
                        }
                        else {
                            return i;
                        }
                    }
                    else if (arr[i - 1] - target < target - arr[i]) {
                        return i - 1;
                    }
                    else {
                        return i;
                    }
                }
            }
        }
        return n - 1;
    }
}
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
    while (begin < end) {
        var tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
    }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
    var extension = Array.isArray(data) ? data : [data];
    var length = extension.length;
    for (var i = 0; i < length; i++) {
        arr[arr.length] = extension[i];
    }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
    var i = arr.indexOf(obj);
    var found = i > -1;
    if (found) {
        arr.splice(i, 1);
    }
    return found;
}
/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
    var length = arr.length >>> 0;
    var value;
    for (var i = 0; i < length; i++) {
        value = arr[i];
        if (func(value, i, arr)) {
            return value;
        }
    }
    return null;
}
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
    var len1 = arr1.length;
    if (len1 !== arr2.length) {
        return false;
    }
    for (var i = 0; i < len1; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
    var length = arr.length;
    var tmp = Array(arr.length);
    var i;
    for (i = 0; i < length; i++) {
        tmp[i] = { index: i, value: arr[i] };
    }
    tmp.sort(function (a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
    });
    for (i = 0; i < arr.length; i++) {
        arr[i] = tmp[i].value;
    }
}
/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
    var index;
    var found = !arr.every(function (el, idx) {
        index = idx;
        return !func(el, idx, arr);
    });
    return found ? index : -1;
}
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [opt_func] Comparison function.
 * @param {boolean} [opt_strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
    var compare = opt_func || numberSafeCompareFunction;
    return arr.every(function (currentVal, index) {
        if (index === 0) {
            return true;
        }
        var res = compare(arr[index - 1], currentVal);
        return !(res > 0 || (opt_strict && res === 0));
    });
}
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "9f7f":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = global.RegExp;

var UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
  return !$RegExp('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

module.exports = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y
};


/***/ }),

/***/ "9ffa":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGFUlEQVR4nIWVfXDU5RHHP/u7y90ld5f3NwhJCBJ8OQMRQaAOVpEQCo21IFiZacdOcYyvYEWkb6OAxbYZ7NS0tYOGykxBMbTQAVEnvAwarQGEGRQihhAl74m53F1yd7ncy/aPu6OWMnRnnj9+u/t899nv7m9XYrEYACJCQqqBlSPB8Tmffvl18Yn2gfTuoVHaezwYZpOScIuFo1JSkE5prpOZZXm+irLcziyHrQVoBN4FUFVEVZPAq4HntjednfTaO2e40OelMDONsklZTMyy45qcS7bdCiKgytBoiNavvqZnOMCFLje9bj/FuQ5WV1fwSM2MLhPyPNCQDFB3on1gXfW6N8nPSGPt/bdx63X5jATG6fUE+Ki1hy5vgBH/OCqCqJLltJGXZmG+q4jCbDuZdisn2wbYuruFrgEfe7fcR3VlyVZR1Yf6PIFtE+7/M3Wr7+CBqpupe+NjGv/VTk/3MPT7mFdTSceAj76OQUizgi8IdgvfnX89B46cg6gysTiLFfOmsn7VXHY1neWZl97j3FuPIqraWvuXozdcGvTx1vol5K98heDQCDhTwRDqa+/i8ZpK1jS8z8s7msFpo6Ikh79tWMr00lxMy/9IzB+CFBN4Atiy7Hj3PsGi5/ZSkufEUFVHW69Hf7LQpQ/96bAG3X6lMEMxG0qKSW8ozVFAR8fCiogSiWlhrlNTLWZVVVU0rreYVQrSdczt10deOaIPV1dot9uvBjBgNRvS3uflix4POK2ggMUMkShVa3aiqtitZkAQp42mI61sbjye6D4ABVWIKdgtfHJxkOB4BIvZEENEzpfkObGmmMRiNgkxFSBxRMiyi4iIJnSqCDazZKRZE3oRBEFEVESIqZTmOWXQFxRXcU7MUNW628oLwyPBsN4yJU8JRxVQNPksTVCBIhrXq1w2XPZVVECJqs66Ll8/vTSk1xdlDhsicvpOV1F7a5dbSnIdgiKoCpLIRBEREYvJiNtEBVQsJkNERISEn2g8S1UpzU+XXrdfqmaUnDEAphRmHA6EIhRlOyA1Jc5lgiFE6HaP4h4di3/H4sS7R8fodftRTfghEIliykzFEDBEmJyfvi/5o83ZuLvl4yy7lZ3NX3D89CVw2OJTQUC9wXjRAUJhsKVANM6gOKxcHgaeAN9b5GJqQQa56TY2LJs1MXGLltULXWd/+tcPXKvmT+P4hxfAYUVjCoFxtj6xkNI8J4YhmESIxpuTd09/xav7ToHdejmDlfOmUn/wDHufXbIf6DXinawU5Tjq7TYLEzLtOqG8QAlFlFi8x5fMLNXHth3Tx199X+dMK9Qfb/ynNhw+q4tvKVWiiUIHQ1o5u0yD4Yi6irMpzLLXqSoG/5GGJ5dO799/skOevvdW8CU4j0QZj8bYvW4xO9dWYbelsGfzMjY/MBePP8Rlfvwhnr13Jg2HzslT91SeBj4AMEQkOaojlWV5v7aYDYpz7FLuKhJGx4QUk6iq3LPlgCz73TvSOTgiNRsa5ZkdzWK3pQgmQ/AGZcGCm6RvOCBl+em4inOeTK4ASe6DpKLfE+h4sP7Q5AcX3Kg/+FkjWMzs/80KRoNhzGaDqunFHGy5iMNp5bNONz+vP4yRmkLTb1fw1PZmObrp+4eynbaq5Br45j5Iyu0vNJ5oHo9E8Y2F+cNrx6AggwyTQW6ekwO/qGHu2l1EDAN/KAx9Xra/eB9vn+xg4fRiaqsrJgHdSTDjSnTgw1+umN3Q0tbPnTdN5DuLboY+D15fEPdoiByHDa8ngH8kCN3DbHq6miFfkMBYhNrqike/CQ7E19pVjvQN+z+fte5NPd8zrEt+9Xdl7iZl6UtatXGf8u0XlTu26IYdzbrnozadUvu6hiPRN66GdTWKklJ++EznZz96ucmy/bG7uTQwwsHj7Vzs9TK7vICVd91IW+cQW/7xCad+v+pkQWbat4DwlSD/VeT/MYrMu9jvbVr2/D77tOJsFs+egtNu4cs+H3uOtpLltPH2C8tPmQy5XVXHropxrQCJIFOBbbuOnZ//3skOcyAU1rz0NFk+v9x394yS14E112DhmhRdKT8EHgZsQA+wHvj8/136N6aj99VgslNXAAAAAElFTkSuQmCC"

/***/ }),

/***/ "a04b":
/***/ (function(module, exports, __webpack_require__) {

var toPrimitive = __webpack_require__("c04e");
var isSymbol = __webpack_require__("d9b5");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "a264":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track03.858b4868.png";

/***/ }),

/***/ "a2c7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: createCenterConstraint, createResolutionConstraint, createRotationConstraint, isNoopAnimation

// EXTERNAL MODULE: ./node_modules/ol/Object.js
var ol_Object = __webpack_require__("e269");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js
var GeometryType = __webpack_require__("f623");

// EXTERNAL MODULE: ./node_modules/ol/proj/Units.js
var Units = __webpack_require__("fced");

// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js
var ViewHint = __webpack_require__("496f");

// CONCATENATED MODULE: ./node_modules/ol/ViewProperty.js
/**
 * @module ol/ViewProperty
 */
/**
 * @enum {string}
 */
/* harmony default export */ var ViewProperty = ({
    CENTER: 'center',
    RESOLUTION: 'resolution',
    ROTATION: 'rotation',
});
//# sourceMappingURL=ViewProperty.js.map
// EXTERNAL MODULE: ./node_modules/ol/tilegrid/common.js
var common = __webpack_require__("0414");

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules
var proj = __webpack_require__("256f");

// EXTERNAL MODULE: ./node_modules/ol/functions.js
var functions = __webpack_require__("57cb");

// EXTERNAL MODULE: ./node_modules/ol/coordinate.js
var ol_coordinate = __webpack_require__("a568");

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__("92fa");

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__("38f3");

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__("7fc9");

// CONCATENATED MODULE: ./node_modules/ol/centerconstraint.js
/**
 * @module ol/centerconstraint
 */

/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */
function createExtent(extent, onlyCenter, smooth) {
    return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, opt_isMoving, opt_centerShift) {
        if (!center) {
            return undefined;
        }
        if (!resolution && !onlyCenter) {
            return center;
        }
        var viewWidth = onlyCenter ? 0 : size[0] * resolution;
        var viewHeight = onlyCenter ? 0 : size[1] * resolution;
        var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
        var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
        var minX = extent[0] + viewWidth / 2 + shiftX;
        var maxX = extent[2] - viewWidth / 2 + shiftX;
        var minY = extent[1] + viewHeight / 2 + shiftY;
        var maxY = extent[3] - viewHeight / 2 + shiftY;
        // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for
        if (minX > maxX) {
            minX = (maxX + minX) / 2;
            maxX = minX;
        }
        if (minY > maxY) {
            minY = (maxY + minY) / 2;
            maxY = minY;
        }
        var x = Object(math["b" /* clamp */])(center[0], minX, maxX);
        var y = Object(math["b" /* clamp */])(center[1], minY, maxY);
        // during an interaction, allow some overscroll
        if (opt_isMoving && smooth && resolution) {
            var ratio = 30 * resolution;
            x +=
                -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +
                    ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
            y +=
                -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +
                    ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }
        return [x, y];
    });
}
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */
function none(center) {
    return center;
}
//# sourceMappingURL=centerconstraint.js.map
// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__("9f5e");

// CONCATENATED MODULE: ./node_modules/ol/resolutionconstraint.js
/**
 * @module ol/resolutionconstraint
 */



/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */
/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    var xResolution = Object(ol_extent["D" /* getWidth */])(maxExtent) / viewportSize[0];
    var yResolution = Object(ol_extent["z" /* getHeight */])(maxExtent) / viewportSize[1];
    if (showFullExtent) {
        return Math.min(resolution, Math.max(xResolution, yResolution));
    }
    return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    var result = Math.min(resolution, maxResolution);
    var ratio = 50;
    result *=
        Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +
            1;
    if (minResolution) {
        result = Math.max(result, minResolution);
        result /=
            Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /
                ratio +
                1;
    }
    return Object(math["b" /* clamp */])(result, minResolution / 2, maxResolution * 2);
}
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
    return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
        if (resolution !== undefined) {
            var maxResolution = resolutions[0];
            var minResolution = resolutions[resolutions.length - 1];
            var cappedMaxRes = opt_maxExtent
                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                : maxResolution;
            // during interacting or animating, allow intermediary values
            if (opt_isMoving) {
                var smooth = opt_smooth !== undefined ? opt_smooth : true;
                if (!smooth) {
                    return Object(math["b" /* clamp */])(resolution, minResolution, cappedMaxRes);
                }
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            var capped = Math.min(cappedMaxRes, resolution);
            var z = Math.floor(Object(array["f" /* linearFindNearest */])(resolutions, capped, direction));
            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                return resolutions[z + 1];
            }
            return resolutions[z];
        }
        else {
            return undefined;
        }
    });
}
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [opt_minResolution] Minimum resolution.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
    return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
        if (resolution !== undefined) {
            var cappedMaxRes = opt_maxExtent
                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                : maxResolution;
            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;
            // during interacting or animating, allow intermediary values
            if (opt_isMoving) {
                var smooth = opt_smooth !== undefined ? opt_smooth : true;
                if (!smooth) {
                    return Object(math["b" /* clamp */])(resolution, minResolution, cappedMaxRes);
                }
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            var tolerance = 1e-9;
            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
            var offset = -direction * (0.5 - tolerance) + 0.5;
            var capped = Math.min(cappedMaxRes, resolution);
            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
            var newResolution = maxResolution / Math.pow(power, zoomLevel);
            return Object(math["b" /* clamp */])(newResolution, minResolution, cappedMaxRes);
        }
        else {
            return undefined;
        }
    });
}
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
    return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
        if (resolution !== undefined) {
            var cappedMaxRes = opt_maxExtent
                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                : maxResolution;
            var smooth = opt_smooth !== undefined ? opt_smooth : true;
            if (!smooth || !opt_isMoving) {
                return Object(math["b" /* clamp */])(resolution, minResolution, cappedMaxRes);
            }
            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        else {
            return undefined;
        }
    });
}
//# sourceMappingURL=resolutionconstraint.js.map
// EXTERNAL MODULE: ./node_modules/ol/rotationconstraint.js
var rotationconstraint = __webpack_require__("8cc5");

// EXTERNAL MODULE: ./node_modules/ol/easing.js
var easing = __webpack_require__("ca42");

// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules
var Polygon = __webpack_require__("5bc3");

// CONCATENATED MODULE: ./node_modules/ol/View.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/View
 */



















/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */
/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */
/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */
/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */
/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */
/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center.
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */
/**
 * Default min zoom level for the map view.
 * @type {number}
 */
var DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */
/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `opt_anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */
var View_View = /** @class */ (function (_super) {
    __extends(View, _super);
    /**
     * @param {ViewOptions} [opt_options] View options.
     */
    function View(opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {ViewOnSignature<import("./events").EventsKey>}
         */
        _this.on;
        /***
         * @type {ViewOnSignature<import("./events").EventsKey>}
         */
        _this.once;
        /***
         * @type {ViewOnSignature<void>}
         */
        _this.un;
        var options = Object(obj["a" /* assign */])({}, opt_options);
        /**
         * @private
         * @type {Array<number>}
         */
        _this.hints_ = [0, 0];
        /**
         * @private
         * @type {Array<Array<Animation>>}
         */
        _this.animations_ = [];
        /**
         * @private
         * @type {number|undefined}
         */
        _this.updateAnimationKey_;
        /**
         * @private
         * @const
         * @type {import("./proj/Projection.js").default}
         */
        _this.projection_ = Object(proj["f" /* createProjection */])(options.projection, 'EPSG:3857');
        /**
         * @private
         * @type {import("./size.js").Size}
         */
        _this.viewportSize_ = [100, 100];
        /**
         * @private
         * @type {import("./coordinate.js").Coordinate|undefined}
         */
        _this.targetCenter_ = null;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.targetResolution_;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.targetRotation_;
        /**
         * @private
         * @type {import("./coordinate.js").Coordinate}
         */
        _this.nextCenter_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.nextResolution_;
        /**
         * @private
         * @type {number}
         */
        _this.nextRotation_;
        /**
         * @private
         * @type {import("./coordinate.js").Coordinate|undefined}
         */
        _this.cancelAnchor_ = undefined;
        if (options.center) {
            options.center = Object(proj["j" /* fromUserCoordinate */])(options.center, _this.projection_);
        }
        if (options.extent) {
            options.extent = Object(proj["k" /* fromUserExtent */])(options.extent, _this.projection_);
        }
        if (options.projection) {
            Object(proj["h" /* disableCoordinateWarning */])();
        }
        _this.applyOptions_(options);
        return _this;
    }
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */
    View.prototype.applyOptions_ = function (options) {
        var properties = Object(obj["a" /* assign */])({}, options);
        for (var key in ViewProperty) {
            delete properties[key];
        }
        this.setProperties(properties, true);
        var resolutionConstraintInfo = createResolutionConstraint(options);
        /**
         * @private
         * @type {number}
         */
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        /**
         * @private
         * @type {number}
         */
        this.minResolution_ = resolutionConstraintInfo.minResolution;
        /**
         * @private
         * @type {number}
         */
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        /**
         * @private
         * @type {Array<number>|undefined}
         */
        this.resolutions_ = options.resolutions;
        /**
         * @type {Array<number>|undefined}
         * @private
         */
        this.padding_ = options.padding;
        /**
         * @private
         * @type {number}
         */
        this.minZoom_ = resolutionConstraintInfo.minZoom;
        var centerConstraint = createCenterConstraint(options);
        var resolutionConstraint = resolutionConstraintInfo.constraint;
        var rotationConstraint = createRotationConstraint(options);
        /**
         * @private
         * @type {Constraints}
         */
        this.constraints_ = {
            center: centerConstraint,
            resolution: resolutionConstraint,
            rotation: rotationConstraint,
        };
        this.setRotation(options.rotation !== undefined ? options.rotation : 0);
        this.setCenterInternal(options.center !== undefined ? options.center : null);
        if (options.resolution !== undefined) {
            this.setResolution(options.resolution);
        }
        else if (options.zoom !== undefined) {
            this.setZoom(options.zoom);
        }
    };
    Object.defineProperty(View.prototype, "padding", {
        /**
         * Padding (in css pixels).
         * If the map viewport is partially covered with other content (overlays) along
         * its edges, this setting allows to shift the center of the viewport away from that
         * content. The order of the values in the array is top, right, bottom, left.
         * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
         * @type {Array<number>|undefined}
         * @api
         */
        get: function () {
            return this.padding_;
        },
        set: function (padding) {
            var oldPadding = this.padding_;
            this.padding_ = padding;
            var center = this.getCenter();
            if (center) {
                var newPadding = padding || [0, 0, 0, 0];
                oldPadding = oldPadding || [0, 0, 0, 0];
                var resolution = this.getResolution();
                var offsetX = (resolution / 2) *
                    (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
                var offsetY = (resolution / 2) *
                    (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
                this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */
    View.prototype.getUpdatedOptions_ = function (newOptions) {
        var options = this.getProperties();
        // preserve resolution (or zoom)
        if (options.resolution !== undefined) {
            options.resolution = this.getResolution();
        }
        else {
            options.zoom = this.getZoom();
        }
        // preserve center
        options.center = this.getCenterInternal();
        // preserve rotation
        options.rotation = this.getRotation();
        return Object(obj["a" /* assign */])({}, options, newOptions);
    };
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */
    View.prototype.animate = function (var_args) {
        if (this.isDef() && !this.getAnimating()) {
            this.resolveConstraints(0);
        }
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i) {
            var options = arguments[i];
            if (options.center) {
                options = Object(obj["a" /* assign */])({}, options);
                options.center = Object(proj["j" /* fromUserCoordinate */])(options.center, this.getProjection());
            }
            if (options.anchor) {
                options = Object(obj["a" /* assign */])({}, options);
                options.anchor = Object(proj["j" /* fromUserCoordinate */])(options.anchor, this.getProjection());
            }
            args[i] = options;
        }
        this.animateInternal.apply(this, args);
    };
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */
    View.prototype.animateInternal = function (var_args) {
        var animationCount = arguments.length;
        var callback;
        if (animationCount > 1 &&
            typeof arguments[animationCount - 1] === 'function') {
            callback = arguments[animationCount - 1];
            --animationCount;
        }
        var i = 0;
        for (; i < animationCount && !this.isDef(); ++i) {
            // if view properties are not yet set, shortcut to the final state
            var state = arguments[i];
            if (state.center) {
                this.setCenterInternal(state.center);
            }
            if (state.zoom !== undefined) {
                this.setZoom(state.zoom);
            }
            else if (state.resolution) {
                this.setResolution(state.resolution);
            }
            if (state.rotation !== undefined) {
                this.setRotation(state.rotation);
            }
        }
        if (i === animationCount) {
            if (callback) {
                animationCallback(callback, true);
            }
            return;
        }
        var start = Date.now();
        var center = this.targetCenter_.slice();
        var resolution = this.targetResolution_;
        var rotation = this.targetRotation_;
        var series = [];
        for (; i < animationCount; ++i) {
            var options = /** @type {AnimationOptions} */ (arguments[i]);
            var animation = {
                start: start,
                complete: false,
                anchor: options.anchor,
                duration: options.duration !== undefined ? options.duration : 1000,
                easing: options.easing || easing["c" /* inAndOut */],
                callback: callback,
            };
            if (options.center) {
                animation.sourceCenter = center;
                animation.targetCenter = options.center.slice();
                center = animation.targetCenter;
            }
            if (options.zoom !== undefined) {
                animation.sourceResolution = resolution;
                animation.targetResolution = this.getResolutionForZoom(options.zoom);
                resolution = animation.targetResolution;
            }
            else if (options.resolution) {
                animation.sourceResolution = resolution;
                animation.targetResolution = options.resolution;
                resolution = animation.targetResolution;
            }
            if (options.rotation !== undefined) {
                animation.sourceRotation = rotation;
                var delta = Object(math["g" /* modulo */])(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                animation.targetRotation = rotation + delta;
                rotation = animation.targetRotation;
            }
            // check if animation is a no-op
            if (isNoopAnimation(animation)) {
                animation.complete = true;
                // we still push it onto the series for callback handling
            }
            else {
                start += animation.duration;
            }
            series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint["a" /* default */].ANIMATING, 1);
        this.updateAnimations_();
    };
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */
    View.prototype.getAnimating = function () {
        return this.hints_[ViewHint["a" /* default */].ANIMATING] > 0;
    };
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */
    View.prototype.getInteracting = function () {
        return this.hints_[ViewHint["a" /* default */].INTERACTING] > 0;
    };
    /**
     * Cancel any ongoing animations.
     * @api
     */
    View.prototype.cancelAnimations = function () {
        this.setHint(ViewHint["a" /* default */].ANIMATING, -this.hints_[ViewHint["a" /* default */].ANIMATING]);
        var anchor;
        for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
            var series = this.animations_[i];
            if (series[0].callback) {
                animationCallback(series[0].callback, false);
            }
            if (!anchor) {
                for (var j = 0, jj = series.length; j < jj; ++j) {
                    var animation = series[j];
                    if (!animation.complete) {
                        anchor = animation.anchor;
                        break;
                    }
                }
            }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
    };
    /**
     * Update all animations.
     */
    View.prototype.updateAnimations_ = function () {
        if (this.updateAnimationKey_ !== undefined) {
            cancelAnimationFrame(this.updateAnimationKey_);
            this.updateAnimationKey_ = undefined;
        }
        if (!this.getAnimating()) {
            return;
        }
        var now = Date.now();
        var more = false;
        for (var i = this.animations_.length - 1; i >= 0; --i) {
            var series = this.animations_[i];
            var seriesComplete = true;
            for (var j = 0, jj = series.length; j < jj; ++j) {
                var animation = series[j];
                if (animation.complete) {
                    continue;
                }
                var elapsed = now - animation.start;
                var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                if (fraction >= 1) {
                    animation.complete = true;
                    fraction = 1;
                }
                else {
                    seriesComplete = false;
                }
                var progress = animation.easing(fraction);
                if (animation.sourceCenter) {
                    var x0 = animation.sourceCenter[0];
                    var y0 = animation.sourceCenter[1];
                    var x1 = animation.targetCenter[0];
                    var y1 = animation.targetCenter[1];
                    this.nextCenter_ = animation.targetCenter;
                    var x = x0 + progress * (x1 - x0);
                    var y = y0 + progress * (y1 - y0);
                    this.targetCenter_ = [x, y];
                }
                if (animation.sourceResolution && animation.targetResolution) {
                    var resolution = progress === 1
                        ? animation.targetResolution
                        : animation.sourceResolution +
                            progress *
                                (animation.targetResolution - animation.sourceResolution);
                    if (animation.anchor) {
                        var size = this.getViewportSize_(this.getRotation());
                        var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                    }
                    this.nextResolution_ = animation.targetResolution;
                    this.targetResolution_ = resolution;
                    this.applyTargetState_(true);
                }
                if (animation.sourceRotation !== undefined &&
                    animation.targetRotation !== undefined) {
                    var rotation = progress === 1
                        ? Object(math["g" /* modulo */])(animation.targetRotation + Math.PI, 2 * Math.PI) -
                            Math.PI
                        : animation.sourceRotation +
                            progress *
                                (animation.targetRotation - animation.sourceRotation);
                    if (animation.anchor) {
                        var constrainedRotation = this.constraints_.rotation(rotation, true);
                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                    }
                    this.nextRotation_ = animation.targetRotation;
                    this.targetRotation_ = rotation;
                }
                this.applyTargetState_(true);
                more = true;
                if (!animation.complete) {
                    break;
                }
            }
            if (seriesComplete) {
                this.animations_[i] = null;
                this.setHint(ViewHint["a" /* default */].ANIMATING, -1);
                this.nextCenter_ = null;
                this.nextResolution_ = NaN;
                this.nextRotation_ = NaN;
                var callback = series[0].callback;
                if (callback) {
                    animationCallback(callback, true);
                }
            }
        }
        // prune completed series
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === undefined) {
            this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
        }
    };
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */
    View.prototype.calculateCenterRotate = function (rotation, anchor) {
        var center;
        var currentCenter = this.getCenterInternal();
        if (currentCenter !== undefined) {
            center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
            Object(ol_coordinate["f" /* rotate */])(center, rotation - this.getRotation());
            Object(ol_coordinate["a" /* add */])(center, anchor);
        }
        return center;
    };
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */
    View.prototype.calculateCenterZoom = function (resolution, anchor) {
        var center;
        var currentCenter = this.getCenterInternal();
        var currentResolution = this.getResolution();
        if (currentCenter !== undefined && currentResolution !== undefined) {
            var x = anchor[0] -
                (resolution * (anchor[0] - currentCenter[0])) / currentResolution;
            var y = anchor[1] -
                (resolution * (anchor[1] - currentCenter[1])) / currentResolution;
            center = [x, y];
        }
        return center;
    };
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */
    View.prototype.getViewportSize_ = function (opt_rotation) {
        var size = this.viewportSize_;
        if (opt_rotation) {
            var w = size[0];
            var h = size[1];
            return [
                Math.abs(w * Math.cos(opt_rotation)) +
                    Math.abs(h * Math.sin(opt_rotation)),
                Math.abs(w * Math.sin(opt_rotation)) +
                    Math.abs(h * Math.cos(opt_rotation)),
            ];
        }
        else {
            return size;
        }
    };
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [opt_size] Viewport size; if undefined, [100, 100] is assumed
     */
    View.prototype.setViewportSize = function (opt_size) {
        this.viewportSize_ = Array.isArray(opt_size)
            ? opt_size.slice()
            : [100, 100];
        if (!this.getAnimating()) {
            this.resolveConstraints(0);
        }
    };
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */
    View.prototype.getCenter = function () {
        var center = this.getCenterInternal();
        if (!center) {
            return center;
        }
        return Object(proj["r" /* toUserCoordinate */])(center, this.getProjection());
    };
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */
    View.prototype.getCenterInternal = function () {
        return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(ViewProperty.CENTER));
    };
    /**
     * @return {Constraints} Constraints.
     */
    View.prototype.getConstraints = function () {
        return this.constraints_;
    };
    /**
     * @return {boolean} Resolution constraint is set
     */
    View.prototype.getConstrainResolution = function () {
        return this.get('constrainResolution');
    };
    /**
     * @param {Array<number>} [opt_hints] Destination array.
     * @return {Array<number>} Hint.
     */
    View.prototype.getHints = function (opt_hints) {
        if (opt_hints !== undefined) {
            opt_hints[0] = this.hints_[0];
            opt_hints[1] = this.hints_[1];
            return opt_hints;
        }
        else {
            return this.hints_.slice();
        }
    };
    /**
     * Calculate the extent for the current view state and the passed size.
     * The size is the pixel dimensions of the box into which the calculated extent
     * should fit. In most cases you want to get the extent of the entire map,
     * that is `map.getSize()`.
     * @param {import("./size.js").Size} [opt_size] Box pixel size. If not provided, the size
     * of the map that uses this view will be used.
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */
    View.prototype.calculateExtent = function (opt_size) {
        var extent = this.calculateExtentInternal(opt_size);
        return Object(proj["s" /* toUserExtent */])(extent, this.getProjection());
    };
    /**
     * @param {import("./size.js").Size} [opt_size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */
    View.prototype.calculateExtentInternal = function (opt_size) {
        var size = opt_size || this.getViewportSizeMinusPadding_();
        var center = /** @type {!import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
        Object(asserts["a" /* assert */])(center, 1); // The view center is not defined
        var resolution = /** @type {!number} */ (this.getResolution());
        Object(asserts["a" /* assert */])(resolution !== undefined, 2); // The view resolution is not defined
        var rotation = /** @type {!number} */ (this.getRotation());
        Object(asserts["a" /* assert */])(rotation !== undefined, 3); // The view rotation is not defined
        return Object(ol_extent["y" /* getForViewAndSize */])(center, resolution, rotation, size);
    };
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */
    View.prototype.getMaxResolution = function () {
        return this.maxResolution_;
    };
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */
    View.prototype.getMinResolution = function () {
        return this.minResolution_;
    };
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */
    View.prototype.getMaxZoom = function () {
        return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
    };
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */
    View.prototype.setMaxZoom = function (zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
    };
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */
    View.prototype.getMinZoom = function () {
        return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
    };
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */
    View.prototype.setMinZoom = function (zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
    };
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */
    View.prototype.setConstrainResolution = function (enabled) {
        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
    };
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */
    View.prototype.getProjection = function () {
        return this.projection_;
    };
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */
    View.prototype.getResolution = function () {
        return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));
    };
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */
    View.prototype.getResolutions = function () {
        return this.resolutions_;
    };
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [opt_size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */
    View.prototype.getResolutionForExtent = function (extent, opt_size) {
        return this.getResolutionForExtentInternal(Object(proj["k" /* fromUserExtent */])(extent, this.getProjection()), opt_size);
    };
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [opt_size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */
    View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
        var size = opt_size || this.getViewportSizeMinusPadding_();
        var xResolution = Object(ol_extent["D" /* getWidth */])(extent) / size[0];
        var yResolution = Object(ol_extent["z" /* getHeight */])(extent) / size[1];
        return Math.max(xResolution, yResolution);
    };
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [opt_power] Power.
     * @return {function(number): number} Resolution for value function.
     */
    View.prototype.getResolutionForValueFunction = function (opt_power) {
        var power = opt_power || 2;
        var maxResolution = this.getConstrainedResolution(this.maxResolution_);
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function (value) {
            var resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
        });
    };
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */
    View.prototype.getRotation = function () {
        return /** @type {number} */ (this.get(ViewProperty.ROTATION));
    };
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [opt_power] Power.
     * @return {function(number): number} Value for resolution function.
     */
    View.prototype.getValueForResolutionFunction = function (opt_power) {
        var logPower = Math.log(opt_power || 2);
        var maxResolution = this.getConstrainedResolution(this.maxResolution_);
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / logPower;
        return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function (resolution) {
            var value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
        });
    };
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */
    View.prototype.getViewportSizeMinusPadding_ = function (opt_rotation) {
        var size = this.getViewportSize_(opt_rotation);
        var padding = this.padding_;
        if (padding) {
            size = [
                size[0] - padding[1] - padding[3],
                size[1] - padding[0] - padding[2],
            ];
        }
        return size;
    };
    /**
     * @return {State} View state.
     */
    View.prototype.getState = function () {
        var projection = this.getProjection();
        var resolution = this.getResolution();
        var rotation = this.getRotation();
        var center = /** @type {import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
        var padding = this.padding_;
        if (padding) {
            var reducedSize = this.getViewportSizeMinusPadding_();
            center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
        }
        return {
            center: center.slice(0),
            projection: projection !== undefined ? projection : null,
            resolution: resolution,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: rotation,
            zoom: this.getZoom(),
        };
    };
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */
    View.prototype.getZoom = function () {
        var zoom;
        var resolution = this.getResolution();
        if (resolution !== undefined) {
            zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
    };
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */
    View.prototype.getZoomForResolution = function (resolution) {
        var offset = this.minZoom_ || 0;
        var max, zoomFactor;
        if (this.resolutions_) {
            var nearest = Object(array["f" /* linearFindNearest */])(this.resolutions_, resolution, 1);
            offset = nearest;
            max = this.resolutions_[nearest];
            if (nearest == this.resolutions_.length - 1) {
                zoomFactor = 2;
            }
            else {
                zoomFactor = max / this.resolutions_[nearest + 1];
            }
        }
        else {
            max = this.maxResolution_;
            zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    };
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */
    View.prototype.getResolutionForZoom = function (zoom) {
        if (this.resolutions_) {
            if (this.resolutions_.length <= 1) {
                return 0;
            }
            var baseLevel = Object(math["b" /* clamp */])(Math.floor(zoom), 0, this.resolutions_.length - 2);
            var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
            return (this.resolutions_[baseLevel] /
                Math.pow(zoomFactor, Object(math["b" /* clamp */])(zoom - baseLevel, 0, 1)));
        }
        else {
            return (this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_));
        }
    };
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [opt_options] Options.
     * @api
     */
    View.prototype.fit = function (geometryOrExtent, opt_options) {
        /** @type {import("./geom/SimpleGeometry.js").default} */
        var geometry;
        Object(asserts["a" /* assert */])(Array.isArray(geometryOrExtent) ||
            typeof ( /** @type {?} */(geometryOrExtent).getSimplifiedGeometry) ===
                'function', 24); // Invalid extent or geometry provided as `geometry`
        if (Array.isArray(geometryOrExtent)) {
            Object(asserts["a" /* assert */])(!Object(ol_extent["G" /* isEmpty */])(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
            var extent = Object(proj["k" /* fromUserExtent */])(geometryOrExtent, this.getProjection());
            geometry = Object(Polygon["c" /* fromExtent */])(extent);
        }
        else if (geometryOrExtent.getType() === GeometryType["a" /* default */].CIRCLE) {
            var extent = Object(proj["k" /* fromUserExtent */])(geometryOrExtent.getExtent(), this.getProjection());
            geometry = Object(Polygon["c" /* fromExtent */])(extent);
            geometry.rotate(this.getRotation(), Object(ol_extent["w" /* getCenter */])(extent));
        }
        else {
            var userProjection = Object(proj["q" /* getUserProjection */])();
            if (userProjection) {
                geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometryOrExtent
                    .clone()
                    .transform(userProjection, this.getProjection()));
            }
            else {
                geometry = geometryOrExtent;
            }
        }
        this.fitInternal(geometry, opt_options);
    };
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */
    View.prototype.rotatedExtentForGeometry = function (geometry) {
        var rotation = this.getRotation();
        var cosAngle = Math.cos(rotation);
        var sinAngle = Math.sin(-rotation);
        var coords = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        var minRotX = +Infinity;
        var minRotY = +Infinity;
        var maxRotX = -Infinity;
        var maxRotY = -Infinity;
        for (var i = 0, ii = coords.length; i < ii; i += stride) {
            var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
            var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
            minRotX = Math.min(minRotX, rotX);
            minRotY = Math.min(minRotY, rotY);
            maxRotX = Math.max(maxRotX, rotX);
            maxRotY = Math.max(maxRotY, rotY);
        }
        return [minRotX, minRotY, maxRotX, maxRotY];
    };
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [opt_options] Options.
     */
    View.prototype.fitInternal = function (geometry, opt_options) {
        var options = opt_options || {};
        var size = options.size;
        if (!size) {
            size = this.getViewportSizeMinusPadding_();
        }
        var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
        var nearest = options.nearest !== undefined ? options.nearest : false;
        var minResolution;
        if (options.minResolution !== undefined) {
            minResolution = options.minResolution;
        }
        else if (options.maxZoom !== undefined) {
            minResolution = this.getResolutionForZoom(options.maxZoom);
        }
        else {
            minResolution = 0;
        }
        var rotatedExtent = this.rotatedExtentForGeometry(geometry);
        // calculate resolution
        var resolution = this.getResolutionForExtentInternal(rotatedExtent, [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2],
        ]);
        resolution = isNaN(resolution)
            ? minResolution
            : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        // calculate center
        var rotation = this.getRotation();
        var sinAngle = Math.sin(rotation);
        var cosAngle = Math.cos(rotation);
        var centerRot = Object(ol_extent["w" /* getCenter */])(rotatedExtent);
        centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;
        centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;
        var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        var center = this.getConstrainedCenter([centerX, centerY], resolution);
        var callback = options.callback ? options.callback : functions["c" /* VOID */];
        if (options.duration !== undefined) {
            this.animateInternal({
                resolution: resolution,
                center: center,
                duration: options.duration,
                easing: options.easing,
            }, callback);
        }
        else {
            this.targetResolution_ = resolution;
            this.targetCenter_ = center;
            this.applyTargetState_(false, true);
            animationCallback(callback, true);
        }
    };
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */
    View.prototype.centerOn = function (coordinate, size, position) {
        this.centerOnInternal(Object(proj["j" /* fromUserCoordinate */])(coordinate, this.getProjection()), size, position);
    };
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */
    View.prototype.centerOnInternal = function (coordinate, size, position) {
        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    };
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */
    View.prototype.calculateCenterShift = function (center, resolution, rotation, size) {
        var centerShift;
        var padding = this.padding_;
        if (padding && center) {
            var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
            var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
            centerShift = [
                center[0] - shiftedCenter[0],
                center[1] - shiftedCenter[1],
            ];
        }
        return centerShift;
    };
    /**
     * @return {boolean} Is defined.
     */
    View.prototype.isDef = function () {
        return !!this.getCenterInternal() && this.getResolution() !== undefined;
    };
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */
    View.prototype.adjustCenter = function (deltaCoordinates) {
        var center = Object(proj["r" /* toUserCoordinate */])(this.targetCenter_, this.getProjection());
        this.setCenter([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1],
        ]);
    };
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */
    View.prototype.adjustCenterInternal = function (deltaCoordinates) {
        var center = this.targetCenter_;
        this.setCenterInternal([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1],
        ]);
    };
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     * @api
     */
    View.prototype.adjustResolution = function (ratio, opt_anchor) {
        var anchor = opt_anchor && Object(proj["j" /* fromUserCoordinate */])(opt_anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
    };
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     */
    View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
        var isMoving = this.getAnimating() || this.getInteracting();
        var size = this.getViewportSize_(this.getRotation());
        var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
        if (opt_anchor) {
            this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
    };
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     * @api
     */
    View.prototype.adjustZoom = function (delta, opt_anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
    };
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The rotation center.
     * @api
     */
    View.prototype.adjustRotation = function (delta, opt_anchor) {
        if (opt_anchor) {
            opt_anchor = Object(proj["j" /* fromUserCoordinate */])(opt_anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, opt_anchor);
    };
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The rotation center.
     */
    View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
        var isMoving = this.getAnimating() || this.getInteracting();
        var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
        if (opt_anchor) {
            this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
    };
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */
    View.prototype.setCenter = function (center) {
        this.setCenterInternal(center ? Object(proj["j" /* fromUserCoordinate */])(center, this.getProjection()) : center);
    };
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */
    View.prototype.setCenterInternal = function (center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
    };
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */
    View.prototype.setHint = function (hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
    };
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */
    View.prototype.setResolution = function (resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
    };
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */
    View.prototype.setRotation = function (rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
    };
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */
    View.prototype.setZoom = function (zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
    };
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [opt_doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [opt_forceMoving] Apply constraints as if the view is moving.
     * @private
     */
    View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
        var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
        // compute rotation
        var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
        var size = this.getViewportSize_(newRotation);
        var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (this.get(ViewProperty.ROTATION) !== newRotation) {
            this.set(ViewProperty.ROTATION, newRotation);
        }
        if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
            this.set(ViewProperty.RESOLUTION, newResolution);
            this.set('zoom', this.getZoom(), true);
        }
        if (!newCenter ||
            !this.get(ViewProperty.CENTER) ||
            !Object(ol_coordinate["d" /* equals */])(this.get(ViewProperty.CENTER), newCenter)) {
            this.set(ViewProperty.CENTER, newCenter);
        }
        if (this.getAnimating() && !opt_doNotCancelAnims) {
            this.cancelAnimations();
        }
        this.cancelAnchor_ = undefined;
    };
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [opt_duration] The animation duration in ms.
     * @param {number} [opt_resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     */
    View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
        var duration = opt_duration !== undefined ? opt_duration : 200;
        var direction = opt_resolutionDirection || 0;
        var newRotation = this.constraints_.rotation(this.targetRotation_);
        var size = this.getViewportSize_(newRotation);
        var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (duration === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = newResolution;
            this.targetRotation_ = newRotation;
            this.targetCenter_ = newCenter;
            this.applyTargetState_();
            return;
        }
        var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
        this.cancelAnchor_ = undefined;
        if (this.getResolution() !== newResolution ||
            this.getRotation() !== newRotation ||
            !this.getCenterInternal() ||
            !Object(ol_coordinate["d" /* equals */])(this.getCenterInternal(), newCenter)) {
            if (this.getAnimating()) {
                this.cancelAnimations();
            }
            this.animateInternal({
                rotation: newRotation,
                center: newCenter,
                resolution: newResolution,
                duration: duration,
                easing: easing["b" /* easeOut */],
                anchor: anchor,
            });
        }
    };
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */
    View.prototype.beginInteraction = function () {
        this.resolveConstraints(0);
        this.setHint(ViewHint["a" /* default */].INTERACTING, 1);
    };
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [opt_duration] Animation duration in ms.
     * @param {number} [opt_resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     * @api
     */
    View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
        var anchor = opt_anchor && Object(proj["j" /* fromUserCoordinate */])(opt_anchor, this.getProjection());
        this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
    };
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [opt_duration] Animation duration in ms.
     * @param {number} [opt_resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     */
    View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
        this.setHint(ViewHint["a" /* default */].INTERACTING, -1);
        this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
    };
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [opt_targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */
    View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
        var size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
    };
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [opt_direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */
    View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
        var targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
    };
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [opt_direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */
    View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
        var direction = opt_direction || 0;
        var size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
    };
    return View;
}(ol_Object["a" /* default */]));
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */
function animationCallback(callback, returnValue) {
    setTimeout(function () {
        callback(returnValue);
    }, 0);
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */
function createCenterConstraint(options) {
    if (options.extent !== undefined) {
        var smooth = options.smoothExtentConstraint !== undefined
            ? options.smoothExtentConstraint
            : true;
        return createExtent(options.extent, options.constrainOnlyCenter, smooth);
    }
    var projection = Object(proj["f" /* createProjection */])(options.projection, 'EPSG:3857');
    if (options.multiWorld !== true && projection.isGlobal()) {
        var extent = projection.getExtent().slice();
        extent[0] = -Infinity;
        extent[2] = Infinity;
        return createExtent(extent, false, false);
    }
    return none;
}
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */
function createResolutionConstraint(options) {
    var resolutionConstraint;
    var maxResolution;
    var minResolution;
    // TODO: move these to be ol constants
    // see https://github.com/openlayers/openlayers/issues/2076
    var defaultMaxZoom = 28;
    var defaultZoomFactor = 2;
    var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
    var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
    var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
    var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
    var smooth = options.smoothResolutionConstraint !== undefined
        ? options.smoothResolutionConstraint
        : true;
    var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
    var projection = Object(proj["f" /* createProjection */])(options.projection, 'EPSG:3857');
    var projExtent = projection.getExtent();
    var constrainOnlyCenter = options.constrainOnlyCenter;
    var extent = options.extent;
    if (!multiWorld && !extent && projection.isGlobal()) {
        constrainOnlyCenter = false;
        extent = projExtent;
    }
    if (options.resolutions !== undefined) {
        var resolutions = options.resolutions;
        maxResolution = resolutions[minZoom];
        minResolution =
            resolutions[maxZoom] !== undefined
                ? resolutions[maxZoom]
                : resolutions[resolutions.length - 1];
        if (options.constrainResolution) {
            resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
        }
        else {
            resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        }
    }
    else {
        // calculate the default min and max resolution
        var size = !projExtent
            ? // use an extent that can fit the whole world if need be
                (360 * proj["a" /* METERS_PER_UNIT */][Units["b" /* default */].DEGREES]) / projection.getMetersPerUnit()
            : Math.max(Object(ol_extent["D" /* getWidth */])(projExtent), Object(ol_extent["z" /* getHeight */])(projExtent));
        var defaultMaxResolution = size / common["b" /* DEFAULT_TILE_SIZE */] / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
        var defaultMinResolution = defaultMaxResolution /
            Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
        // user provided maxResolution takes precedence
        maxResolution = options.maxResolution;
        if (maxResolution !== undefined) {
            minZoom = 0;
        }
        else {
            maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
        }
        // user provided minResolution takes precedence
        minResolution = options.minResolution;
        if (minResolution === undefined) {
            if (options.maxZoom !== undefined) {
                if (options.maxResolution !== undefined) {
                    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                }
                else {
                    minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                }
            }
            else {
                minResolution = defaultMinResolution;
            }
        }
        // given discrete zoom levels, minResolution may be different than provided
        maxZoom =
            minZoom +
                Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
        if (options.constrainResolution) {
            resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        }
        else {
            resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        }
    }
    return {
        constraint: resolutionConstraint,
        maxResolution: maxResolution,
        minResolution: minResolution,
        minZoom: minZoom,
        zoomFactor: zoomFactor,
    };
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */
function createRotationConstraint(options) {
    var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
    if (enableRotation) {
        var constrainRotation = options.constrainRotation;
        if (constrainRotation === undefined || constrainRotation === true) {
            return Object(rotationconstraint["b" /* createSnapToZero */])();
        }
        else if (constrainRotation === false) {
            return rotationconstraint["d" /* none */];
        }
        else if (typeof constrainRotation === 'number') {
            return Object(rotationconstraint["a" /* createSnapToN */])(constrainRotation);
        }
        else {
            return rotationconstraint["d" /* none */];
        }
    }
    else {
        return rotationconstraint["c" /* disable */];
    }
}
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
        if (!Object(ol_coordinate["d" /* equals */])(animation.sourceCenter, animation.targetCenter)) {
            return false;
        }
    }
    if (animation.sourceResolution !== animation.targetResolution) {
        return false;
    }
    if (animation.sourceRotation !== animation.targetRotation) {
        return false;
    }
    return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    // calculate rotated position
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;
    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    var centerX = rotX * cosAngle - rotY * sinAngle;
    var centerY = rotY * cosAngle + rotX * sinAngle;
    return [centerX, centerY];
}
/* harmony default export */ var ol_View = __webpack_exports__["a"] = (View_View);
//# sourceMappingURL=View.js.map

/***/ }),

/***/ "a2e1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/Feature.js
var Feature = __webpack_require__("4cdf");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryCollection.js
var GeometryCollection = __webpack_require__("d352");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js
var GeometryType = __webpack_require__("f623");

// EXTERNAL MODULE: ./node_modules/ol/format/Feature.js
var format_Feature = __webpack_require__("b7df");

// EXTERNAL MODULE: ./node_modules/ol/format/FormatType.js
var FormatType = __webpack_require__("1ecb");

// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// CONCATENATED MODULE: ./node_modules/ol/format/JSONFeature.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/format/JSONFeature
 */



/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */
var JSONFeature_JSONFeature = /** @class */ (function (_super) {
    __extends(JSONFeature, _super);
    function JSONFeature() {
        return _super.call(this) || this;
    }
    /**
     * @return {import("./FormatType.js").default} Format.
     */
    JSONFeature.prototype.getType = function () {
        return FormatType["a" /* default */].JSON;
    };
    /**
     * Read a feature.  Only works for a single feature. Use `readFeatures` to
     * read a feature collection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     */
    JSONFeature.prototype.readFeature = function (source, opt_options) {
        return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
    };
    /**
     * Read all features.  Works with both a single feature and a feature
     * collection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     */
    JSONFeature.prototype.readFeatures = function (source, opt_options) {
        return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
    };
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @protected
     * @return {import("../Feature.js").default} Feature.
     */
    JSONFeature.prototype.readFeatureFromObject = function (object, opt_options) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    JSONFeature.prototype.readFeaturesFromObject = function (object, opt_options) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Read a geometry.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @api
     */
    JSONFeature.prototype.readGeometry = function (source, opt_options) {
        return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
    };
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    JSONFeature.prototype.readGeometryFromObject = function (object, opt_options) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Read the projection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     */
    JSONFeature.prototype.readProjection = function (source) {
        return this.readProjectionFromObject(getObject(source));
    };
    /**
     * @abstract
     * @param {Object} object Object.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    JSONFeature.prototype.readProjectionFromObject = function (object) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {string} Encoded feature.
     * @api
     */
    JSONFeature.prototype.writeFeature = function (feature, opt_options) {
        return JSON.stringify(this.writeFeatureObject(feature, opt_options));
    };
    /**
     * @abstract
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {Object} Object.
     */
    JSONFeature.prototype.writeFeatureObject = function (feature, opt_options) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {string} Encoded features.
     * @api
     */
    JSONFeature.prototype.writeFeatures = function (features, opt_options) {
        return JSON.stringify(this.writeFeaturesObject(features, opt_options));
    };
    /**
     * @abstract
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {Object} Object.
     */
    JSONFeature.prototype.writeFeaturesObject = function (features, opt_options) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {string} Encoded geometry.
     * @api
     */
    JSONFeature.prototype.writeGeometry = function (geometry, opt_options) {
        return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
    };
    /**
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {Object} Object.
     */
    JSONFeature.prototype.writeGeometryObject = function (geometry, opt_options) {
        return Object(util["b" /* abstract */])();
    };
    return JSONFeature;
}(format_Feature["a" /* default */]));
/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */
function getObject(source) {
    if (typeof source === 'string') {
        var object = JSON.parse(source);
        return object ? /** @type {Object} */ (object) : null;
    }
    else if (source !== null) {
        return source;
    }
    else {
        return null;
    }
}
/* harmony default export */ var format_JSONFeature = (JSONFeature_JSONFeature);
//# sourceMappingURL=JSONFeature.js.map
// EXTERNAL MODULE: ./node_modules/ol/geom/LineString.js
var LineString = __webpack_require__("7a09");

// EXTERNAL MODULE: ./node_modules/ol/geom/MultiLineString.js
var MultiLineString = __webpack_require__("47e4");

// EXTERNAL MODULE: ./node_modules/ol/geom/MultiPoint.js
var MultiPoint = __webpack_require__("9a44");

// EXTERNAL MODULE: ./node_modules/ol/geom/MultiPolygon.js + 1 modules
var MultiPolygon = __webpack_require__("88da");

// EXTERNAL MODULE: ./node_modules/ol/geom/Point.js
var Point = __webpack_require__("f403");

// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules
var Polygon = __webpack_require__("5bc3");

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__("92fa");

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__("38f3");

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules
var proj = __webpack_require__("256f");

// CONCATENATED MODULE: ./node_modules/ol/format/GeoJSON.js
/**
 * @module ol/format/GeoJSON
 */
var GeoJSON_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();














/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */
/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 */
/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @api
 */
var GeoJSON_GeoJSON = /** @class */ (function (_super) {
    GeoJSON_extends(GeoJSON, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function GeoJSON(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this) || this;
        /**
         * @type {import("../proj/Projection.js").default}
         */
        _this.dataProjection = Object(proj["m" /* get */])(options.dataProjection ? options.dataProjection : 'EPSG:4326');
        if (options.featureProjection) {
            /**
             * @type {import("../proj/Projection.js").default}
             */
            _this.defaultFeatureProjection = Object(proj["m" /* get */])(options.featureProjection);
        }
        /**
         * Name of the geometry attribute for features.
         * @type {string|undefined}
         * @private
         */
        _this.geometryName_ = options.geometryName;
        /**
         * Look for the geometry name in the feature GeoJSON
         * @type {boolean|undefined}
         * @private
         */
        _this.extractGeometryName_ = options.extractGeometryName;
        _this.supportedMediaTypes = [
            'application/geo+json',
            'application/vnd.geo+json',
        ];
        return _this;
    }
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @protected
     * @return {import("../Feature.js").default} Feature.
     */
    GeoJSON.prototype.readFeatureFromObject = function (object, opt_options) {
        /**
         * @type {GeoJSONFeature}
         */
        var geoJSONFeature = null;
        if (object['type'] === 'Feature') {
            geoJSONFeature = /** @type {GeoJSONFeature} */ (object);
        }
        else {
            geoJSONFeature = {
                'type': 'Feature',
                'geometry': /** @type {GeoJSONGeometry} */ (object),
                'properties': null,
            };
        }
        var geometry = readGeometry(geoJSONFeature['geometry'], opt_options);
        var feature = new Feature["a" /* default */]();
        if (this.geometryName_) {
            feature.setGeometryName(this.geometryName_);
        }
        else if (this.extractGeometryName_ &&
            'geometry_name' in geoJSONFeature !== undefined) {
            feature.setGeometryName(geoJSONFeature['geometry_name']);
        }
        feature.setGeometry(geometry);
        if ('id' in geoJSONFeature) {
            feature.setId(geoJSONFeature['id']);
        }
        if (geoJSONFeature['properties']) {
            feature.setProperties(geoJSONFeature['properties'], true);
        }
        return feature;
    };
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @protected
     * @return {Array<Feature>} Features.
     */
    GeoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
        var geoJSONObject = /** @type {GeoJSONObject} */ (object);
        /** @type {Array<import("../Feature.js").default>} */
        var features = null;
        if (geoJSONObject['type'] === 'FeatureCollection') {
            var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (object);
            features = [];
            var geoJSONFeatures = geoJSONFeatureCollection['features'];
            for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
                features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
            }
        }
        else {
            features = [this.readFeatureFromObject(object, opt_options)];
        }
        return features;
    };
    /**
     * @param {GeoJSONGeometry} object Object.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    GeoJSON.prototype.readGeometryFromObject = function (object, opt_options) {
        return readGeometry(object, opt_options);
    };
    /**
     * @param {Object} object Object.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    GeoJSON.prototype.readProjectionFromObject = function (object) {
        var crs = object['crs'];
        var projection;
        if (crs) {
            if (crs['type'] == 'name') {
                projection = Object(proj["m" /* get */])(crs['properties']['name']);
            }
            else if (crs['type'] === 'EPSG') {
                projection = Object(proj["m" /* get */])('EPSG:' + crs['properties']['code']);
            }
            else {
                Object(asserts["a" /* assert */])(false, 36); // Unknown SRS type
            }
        }
        else {
            projection = this.dataProjection;
        }
        return /** @type {import("../proj/Projection.js").default} */ (projection);
    };
    /**
     * Encode a feature as a GeoJSON Feature object.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {GeoJSONFeature} Object.
     * @api
     */
    GeoJSON.prototype.writeFeatureObject = function (feature, opt_options) {
        opt_options = this.adaptOptions(opt_options);
        /** @type {GeoJSONFeature} */
        var object = {
            'type': 'Feature',
            geometry: null,
            properties: null,
        };
        var id = feature.getId();
        if (id !== undefined) {
            object.id = id;
        }
        if (!feature.hasProperties()) {
            return object;
        }
        var properties = feature.getProperties();
        var geometry = feature.getGeometry();
        if (geometry) {
            object.geometry = writeGeometry(geometry, opt_options);
            delete properties[feature.getGeometryName()];
        }
        if (!Object(obj["d" /* isEmpty */])(properties)) {
            object.properties = properties;
        }
        return object;
    };
    /**
     * Encode an array of features as a GeoJSON object.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {GeoJSONFeatureCollection} GeoJSON Object.
     * @api
     */
    GeoJSON.prototype.writeFeaturesObject = function (features, opt_options) {
        opt_options = this.adaptOptions(opt_options);
        var objects = [];
        for (var i = 0, ii = features.length; i < ii; ++i) {
            objects.push(this.writeFeatureObject(features[i], opt_options));
        }
        return {
            type: 'FeatureCollection',
            features: objects,
        };
    };
    /**
     * Encode a geometry as a GeoJSON object.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
     * @api
     */
    GeoJSON.prototype.writeGeometryObject = function (geometry, opt_options) {
        return writeGeometry(geometry, this.adaptOptions(opt_options));
    };
    return GeoJSON;
}(format_JSONFeature));
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */
function readGeometry(object, opt_options) {
    if (!object) {
        return null;
    }
    /**
     * @type {import("../geom/Geometry.js").default}
     */
    var geometry;
    switch (object['type']) {
        case GeometryType["a" /* default */].POINT: {
            geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));
            break;
        }
        case GeometryType["a" /* default */].LINE_STRING: {
            geometry = readLineStringGeometry(
            /** @type {GeoJSONLineString} */ (object));
            break;
        }
        case GeometryType["a" /* default */].POLYGON: {
            geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));
            break;
        }
        case GeometryType["a" /* default */].MULTI_POINT: {
            geometry = readMultiPointGeometry(
            /** @type {GeoJSONMultiPoint} */ (object));
            break;
        }
        case GeometryType["a" /* default */].MULTI_LINE_STRING: {
            geometry = readMultiLineStringGeometry(
            /** @type {GeoJSONMultiLineString} */ (object));
            break;
        }
        case GeometryType["a" /* default */].MULTI_POLYGON: {
            geometry = readMultiPolygonGeometry(
            /** @type {GeoJSONMultiPolygon} */ (object));
            break;
        }
        case GeometryType["a" /* default */].GEOMETRY_COLLECTION: {
            geometry = readGeometryCollectionGeometry(
            /** @type {GeoJSONGeometryCollection} */ (object));
            break;
        }
        default: {
            throw new Error('Unsupported GeoJSON type: ' + object.type);
        }
    }
    return Object(format_Feature["b" /* transformGeometryWithOptions */])(geometry, false, opt_options);
}
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
 * @return {GeometryCollection} Geometry collection.
 */
function readGeometryCollectionGeometry(object, opt_options) {
    var geometries = object['geometries'].map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function (geometry) {
        return readGeometry(geometry, opt_options);
    });
    return new GeometryCollection["a" /* default */](geometries);
}
/**
 * @param {GeoJSONPoint} object Object.
 * @return {Point} Point.
 */
function readPointGeometry(object) {
    return new Point["a" /* default */](object['coordinates']);
}
/**
 * @param {GeoJSONLineString} object Object.
 * @return {LineString} LineString.
 */
function readLineStringGeometry(object) {
    return new LineString["a" /* default */](object['coordinates']);
}
/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {MultiLineString} MultiLineString.
 */
function readMultiLineStringGeometry(object) {
    return new MultiLineString["a" /* default */](object['coordinates']);
}
/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {MultiPoint} MultiPoint.
 */
function readMultiPointGeometry(object) {
    return new MultiPoint["a" /* default */](object['coordinates']);
}
/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {MultiPolygon} MultiPolygon.
 */
function readMultiPolygonGeometry(object) {
    return new MultiPolygon["a" /* default */](object['coordinates']);
}
/**
 * @param {GeoJSONPolygon} object Object.
 * @return {Polygon} Polygon.
 */
function readPolygonGeometry(object) {
    return new Polygon["a" /* default */](object['coordinates']);
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeGeometry(geometry, opt_options) {
    geometry = Object(format_Feature["b" /* transformGeometryWithOptions */])(geometry, true, opt_options);
    var type = geometry.getType();
    /** @type {GeoJSONGeometry} */
    var geoJSON;
    switch (type) {
        case GeometryType["a" /* default */].POINT: {
            geoJSON = writePointGeometry(
            /** @type {Point} */ (geometry), opt_options);
            break;
        }
        case GeometryType["a" /* default */].LINE_STRING: {
            geoJSON = writeLineStringGeometry(
            /** @type {LineString} */ (geometry), opt_options);
            break;
        }
        case GeometryType["a" /* default */].POLYGON: {
            geoJSON = writePolygonGeometry(
            /** @type {Polygon} */ (geometry), opt_options);
            break;
        }
        case GeometryType["a" /* default */].MULTI_POINT: {
            geoJSON = writeMultiPointGeometry(
            /** @type {MultiPoint} */ (geometry), opt_options);
            break;
        }
        case GeometryType["a" /* default */].MULTI_LINE_STRING: {
            geoJSON = writeMultiLineStringGeometry(
            /** @type {MultiLineString} */ (geometry), opt_options);
            break;
        }
        case GeometryType["a" /* default */].MULTI_POLYGON: {
            geoJSON = writeMultiPolygonGeometry(
            /** @type {MultiPolygon} */ (geometry), opt_options);
            break;
        }
        case GeometryType["a" /* default */].GEOMETRY_COLLECTION: {
            geoJSON = writeGeometryCollectionGeometry(
            /** @type {GeometryCollection} */ (geometry), opt_options);
            break;
        }
        case GeometryType["a" /* default */].CIRCLE: {
            geoJSON = {
                type: 'GeometryCollection',
                geometries: [],
            };
            break;
        }
        default: {
            throw new Error('Unsupported geometry type: ' + type);
        }
    }
    return geoJSON;
}
/**
 * @param {GeometryCollection} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */
function writeGeometryCollectionGeometry(geometry, opt_options) {
    var geometries = geometry.getGeometriesArray().map(function (geometry) {
        var options = Object(obj["a" /* assign */])({}, opt_options);
        delete options.featureProjection;
        return writeGeometry(geometry, options);
    });
    return {
        type: 'GeometryCollection',
        geometries: geometries,
    };
}
/**
 * @param {LineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeLineStringGeometry(geometry, opt_options) {
    return {
        type: 'LineString',
        coordinates: geometry.getCoordinates(),
    };
}
/**
 * @param {MultiLineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiLineStringGeometry(geometry, opt_options) {
    return {
        type: 'MultiLineString',
        coordinates: geometry.getCoordinates(),
    };
}
/**
 * @param {MultiPoint} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiPointGeometry(geometry, opt_options) {
    return {
        type: 'MultiPoint',
        coordinates: geometry.getCoordinates(),
    };
}
/**
 * @param {MultiPolygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiPolygonGeometry(geometry, opt_options) {
    var right;
    if (opt_options) {
        right = opt_options.rightHanded;
    }
    return {
        type: 'MultiPolygon',
        coordinates: geometry.getCoordinates(right),
    };
}
/**
 * @param {Point} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writePointGeometry(geometry, opt_options) {
    return {
        type: 'Point',
        coordinates: geometry.getCoordinates(),
    };
}
/**
 * @param {Polygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writePolygonGeometry(geometry, opt_options) {
    var right;
    if (opt_options) {
        right = opt_options.rightHanded;
    }
    return {
        type: 'Polygon',
        coordinates: geometry.getCoordinates(right),
    };
}
/* harmony default export */ var format_GeoJSON = __webpack_exports__["a"] = (GeoJSON_GeoJSON);
//# sourceMappingURL=GeoJSON.js.map

/***/ }),

/***/ "a305":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "a37a":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "a43f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/source/VectorEventType
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Triggered when a feature is added to the source.
     * @event module:ol/source/Vector.VectorSourceEvent#addfeature
     * @api
     */
    ADDFEATURE: 'addfeature',
    /**
     * Triggered when a feature is updated.
     * @event module:ol/source/Vector.VectorSourceEvent#changefeature
     * @api
     */
    CHANGEFEATURE: 'changefeature',
    /**
     * Triggered when the clear method is called on the source.
     * @event module:ol/source/Vector.VectorSourceEvent#clear
     * @api
     */
    CLEAR: 'clear',
    /**
     * Triggered when a feature is removed from the source.
     * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
     * @event module:ol/source/Vector.VectorSourceEvent#removefeature
     * @api
     */
    REMOVEFEATURE: 'removefeature',
    /**
     * Triggered when features starts loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
     * @api
     */
    FEATURESLOADSTART: 'featuresloadstart',
    /**
     * Triggered when features finishes loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
     * @api
     */
    FEATURESLOADEND: 'featuresloadend',
    /**
     * Triggered if feature loading results in an error.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
     * @api
     */
    FEATURESLOADERROR: 'featuresloaderror',
});
/**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */
//# sourceMappingURL=VectorEventType.js.map

/***/ }),

/***/ "a4b4":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ "a4c4":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "a504":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ERROR_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ENABLE_RASTER_REPROJECTION; });
/**
 * @module ol/reproj/common
 */
/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;
/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */
var ENABLE_RASTER_REPROJECTION = true;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "a568":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return add; });
/* unused harmony export closestOnCircle */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return closestOnSegment; });
/* unused harmony export createStringXY */
/* unused harmony export degreesToStringHDMS */
/* unused harmony export format */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return squaredDistanceToSegment; });
/* unused harmony export toStringHDMS */
/* unused harmony export toStringXY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return wrapX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getWorldsAway; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0af5");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7fc9");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("b0c1");
/**
 * @module ol/coordinate
 */



/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */
/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */
/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
}
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
    var r = circle.getRadius();
    var center = circle.getCenter();
    var x0 = center[0];
    var y0 = center[1];
    var x1 = coordinate[0];
    var y1 = coordinate[1];
    var dx = x1 - x0;
    var dy = y1 - y0;
    if (dx === 0 && dy === 0) {
        dx = 1;
    }
    var d = Math.sqrt(dx * dx + dy * dy);
    var x = x0 + (r * dx) / d;
    var y = y0 + (r * dy) / d;
    return [x, y];
}
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
    var x0 = coordinate[0];
    var y0 = coordinate[1];
    var start = segment[0];
    var end = segment[1];
    var x1 = start[0];
    var y1 = start[1];
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = dx === 0 && dy === 0
        ? 0
        : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    var x, y;
    if (along <= 0) {
        x = x1;
        y = y1;
    }
    else if (along >= 1) {
        x = x2;
        y = y2;
    }
    else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return [x, y];
}
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(opt_fractionDigits) {
    return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
        return toStringXY(coordinate, opt_fractionDigits);
    });
}
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
    var normalizedDegrees = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* modulo */ "g"])(degrees + 180, 360) - 180;
    var x = Math.abs(3600 * normalizedDegrees);
    var dflPrecision = opt_fractionDigits || 0;
    var precision = Math.pow(10, dflPrecision);
    var deg = Math.floor(x / 3600);
    var min = Math.floor((x - deg * 3600) / 60);
    var sec = x - deg * 3600 - min * 60;
    sec = Math.ceil(sec * precision) / precision;
    if (sec >= 60) {
        sec = 0;
        min += 1;
    }
    if (min >= 60) {
        min = 0;
        deg += 1;
    }
    return (deg +
        '\u00b0 ' +
        Object(_string_js__WEBPACK_IMPORTED_MODULE_2__[/* padNumber */ "a"])(min, 2) +
        '\u2032 ' +
        Object(_string_js__WEBPACK_IMPORTED_MODULE_2__[/* padNumber */ "a"])(sec, 2, dflPrecision) +
        '\u2033' +
        (normalizedDegrees == 0
            ? ''
            : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0)));
}
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, opt_fractionDigits) {
    if (coordinate) {
        return template
            .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
            .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
    }
    else {
        return '';
    }
}
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
    var equals = true;
    for (var i = coordinate1.length - 1; i >= 0; --i) {
        if (coordinate1[i] != coordinate2[i]) {
            equals = false;
            break;
        }
    }
    return equals;
}
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
}
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
    var dx = coord1[0] - coord2[0];
    var dy = coord1[1] - coord2[1];
    return dx * dx + dy * dy;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
}
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, opt_fractionDigits) {
    if (coordinate) {
        return (degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) +
            ' ' +
            degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits));
    }
    else {
        return '';
    }
}
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, opt_fractionDigits) {
    return format(coordinate, '{x}, {y}', opt_fractionDigits);
}
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */
function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
        var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(projection.getExtent());
        var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
        if (worldsAway) {
            coordinate[0] -= worldsAway * worldWidth;
        }
    }
    return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [opt_sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */
function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
    var projectionExtent = projection.getExtent();
    var worldsAway = 0;
    if (projection.canWrapX() &&
        (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
        var sourceExtentWidth = opt_sourceExtentWidth || Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(projectionExtent);
        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }
    return worldsAway;
}
//# sourceMappingURL=coordinate.js.map

/***/ }),

/***/ "a640":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("d039");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ "a6ee":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "a715":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGNUlEQVR4nIWVa1DU5xXGf+9//7sLe+e+XJWbAiuVeIkhjjUhGgwZYyZYU6nt2BbGyrTaNlE6yaSmaWs+UJmJTDXNaE3aNF5bsUar9daqiRgITqFI5KYCWS4KLAsst919+2HZaG72zJxv5zzP8573XITf7wdACMG05QNrhscmFzXcuptY09Zn+bR/hDanC0XVSKbD/FM+kRRjYUakmXnJUe7s5MjOMFPIVeAwcApASomQUgaBi4FtfzzTmLDnH/W09gxhtxlITggjLsyIY2Yk4UY9CAFS0j8yQdPtuzgHPbR2DdA9MEpipIni/Gw2rpzbpUG8CuwNEpTXtPW9mP/iAaKtBn76/MPMT41m2DNJ95CH2uYe/tM1SG//CCgK+P3YI0zkpkaTmRSB3WbAZtJT29LHjoNX6epzc3T7avJzknYIKWVJj8vzVuzzuygv/iZrl8+hfH81h6+04nQOwfgks3KSyEgIxxyqRRECn18y6fVx5GIzuEZBryUu1sq3ctPYWvQI751pZEvFaa4fKkVIKZt+9OaFjI47bg5tLSB6zW7G+ochzAhaFQZGOPL6agpz0/iiZWx6lxtN3WAOgSkfuDyEhBkZOvoTntx2lKQoM6qU0tTS7ZKlK7Ip+f05xgZGwW4FCUgJArSqwvGadn78u1OY7VYGRydxdg6AToOwhiIloFMRMRbGe9xs3H2eDfnZ7DnbiAr06VUloa1nSDY7XWDW3wP3S5DgSAwn1W5j5cHSz9QfvNzMDypO45nwgk4NxEvAqOPj9jsszoxDpypCFULcSIoyz9NrNUKnagKggb4FAZj0bP3Th8yOD+N2n5uGll4WO+LZVZqHxain4IUDoCqgKEgAv2RGlJk77jEciRF+VUpZ/nC6fbVzYFR9KCWK6pqbAQIJQhEQquNvVXUwPgWqBoSg4WQ9i7LiWP94JoRqA6LEdAf7JAtSo2no6GdpVtygKoS49pgjvu2V/dUZ2TMiPld7KQH3OLt+uQqflLR09DPkmSLFbmH945kc+qAFPFNgU0FI5HTSjGgL/2r8lOVzk+pVgBS79ZxnwpsRH266p0ijgM8HOpU4m4GCBcloVeWzP/h7dRvfrzgNJn1gNgC8PjS2UBQBihDMjLZUBQdt0a8OXq0OM+r5y+VmPrrWAaaQwFYQAul0QYiKyW7FoNfSd8cNPUMQbUEY9cjgv7k8rHrSQVqMlUhLCL94bkGcOi3oavEyR+PP911yFC2ZxUcftIJJj/RJGJuk4qWnibEamPD6GBmbxOeXZCZGsOWdyzRcd4JxuvO8PtbkplF5sp6jZQXHgW41uIviI0yVxhDdm7E2o4xNj6G7zx1oP72Wwx+2YtBrGewfITsxnLe3PMX+ize4eetuIAZgbIKchcmMTXlxJIYLe5ixXErJvaLC3k1Pf6P3eO1N8cKz88E9DkIgdBqu1N3m3LE67NZQyooeYdVrxyh66a+MeP0InSaQPTpB2bPz2Hv2uvjZMznXgEsA6n1r2puTHPVbnarsTIwwinRHPC3tfUijHjyT7Ni2ivwFM8kvO0Rn5wDEWGB4HKkIGBknLy+LnkEPydEWHIkRm4InQJFSEnSgcvt3Hr2173wTv16XK5nwSlwe+UZZgZybEiXnFP1Bdva6JWFGyfiULFg6W5oNOomqkS8Xzpf7zjdRWbz0LHA5iKkIIQg6QIzNsG5xRiyNHf2iZO0igd8vNuTPEcu2VQWC9KpgZEJYbaHixMsrxfCQR1RuXi52nWoQG1fMIdwcsj6oXgjxuYNzv+3Jf+3YD0uWZbHz/XpWL5zJQxmxaBWBX4IiwYvk8MVmhKoQH2HiQkMXJ195phTYfT/Q1xGIXpenaeX292f/efNySt74J5c+vh0YKlUDE16Y9FJaOJ+87ATK3r3CJ5XrDqgaZe2XgL6GACD9XH3nf7+384xuz8Y82pwuTtS0Mzg8TmqMlW8/kcXtbhevV9VRV7G2NsZmeBSY+hJB8Oh/5TOEyG3vHTrz3KtVxlmJ4axYmILZqONWj5sjF5oIM4dw4jeFdRpFLJZSjn8lxoMIpknSgLfe+/eNJadrb6qeiSkZZTGIwiXp7ifmJr0NbH5AFR5Yoi/ad4ENQAjgBLYCn/y/pP8BfxSbBD6fifMAAAAASUVORK5CYII="

/***/ }),

/***/ "a7dd":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "a808":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "a896":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return create; });
/* unused harmony export reset */
/* unused harmony export multiply */
/* unused harmony export set */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return setFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return apply; });
/* unused harmony export rotate */
/* unused harmony export scale */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return makeScale; });
/* unused harmony export translate */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return compose; });
/* unused harmony export composeCssTransform */
/* unused harmony export invert */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return makeInverse; });
/* unused harmony export determinant */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return toString; });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("617d");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("92fa");
/**
 * @module ol/transform
 */


/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */
/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */
/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
    return [1, 0, 0, 1, 0, 0];
}
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
}
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
    var a1 = transform1[0];
    var b1 = transform1[1];
    var c1 = transform1[2];
    var d1 = transform1[3];
    var e1 = transform1[4];
    var f1 = transform1[5];
    var a2 = transform2[0];
    var b2 = transform2[1];
    var c2 = transform2[2];
    var d2 = transform2[3];
    var e2 = transform2[4];
    var f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
}
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
}
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
}
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
    var x = coordinate[0];
    var y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
}
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */
function makeScale(target, x, y) {
    return set(target, x, 0, 0, y, 0, 0);
}
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    var sin = Math.sin(angle);
    var cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */
function invert(source) {
    return makeInverse(source, source);
}
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */
function makeInverse(target, source) {
    var det = determinant(source);
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__[/* assert */ "a"])(det !== 0, 32); // Transformation matrix cannot be inverted
    var a = source[0];
    var b = source[1];
    var c = source[2];
    var d = source[3];
    var e = source[4];
    var f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
}
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */
var transformStringDiv;
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */
function toString(mat) {
    var transformString = 'matrix(' + mat.join(', ') + ')';
    if (_has_js__WEBPACK_IMPORTED_MODULE_0__[/* WORKER_OFFSCREEN_CANVAS */ "g"]) {
        return transformString;
    }
    var node = transformStringDiv || (transformStringDiv = document.createElement('div'));
    node.style.transform = transformString;
    return node.style.transform;
}
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "a9e3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var hasOwn = __webpack_require__("1a2d");
var inheritIfRequired = __webpack_require__("7156");
var isPrototypeOf = __webpack_require__("3a9b");
var isSymbol = __webpack_require__("d9b5");
var toPrimitive = __webpack_require__("c04e");
var fails = __webpack_require__("d039");
var getOwnPropertyNames = __webpack_require__("241c").f;
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var defineProperty = __webpack_require__("9bf2").f;
var thisNumberValue = __webpack_require__("408a");
var trim = __webpack_require__("58a8").trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = global.TypeError;
var arraySlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = arraySlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
    var dummy = this;
    // check on 1..constructor(foo) case
    return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); })
      ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ "aabb":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "ab35":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1300");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("345d");
/**
 * @module ol/style/Image
 */


/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 */
/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
var ImageStyle = /** @class */ (function () {
    /**
     * @param {Options} options Options.
     */
    function ImageStyle(options) {
        /**
         * @private
         * @type {number}
         */
        this.opacity_ = options.opacity;
        /**
         * @private
         * @type {boolean}
         */
        this.rotateWithView_ = options.rotateWithView;
        /**
         * @private
         * @type {number}
         */
        this.rotation_ = options.rotation;
        /**
         * @private
         * @type {number|import("../size.js").Size}
         */
        this.scale_ = options.scale;
        /**
         * @private
         * @type {import("../size.js").Size}
         */
        this.scaleArray_ = Object(_size_js__WEBPACK_IMPORTED_MODULE_1__[/* toSize */ "c"])(options.scale);
        /**
         * @private
         * @type {Array<number>}
         */
        this.displacement_ = options.displacement;
    }
    /**
     * Clones the style.
     * @return {ImageStyle} The cloned style.
     * @api
     */
    ImageStyle.prototype.clone = function () {
        var scale = this.getScale();
        return new ImageStyle({
            opacity: this.getOpacity(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
        });
    };
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */
    ImageStyle.prototype.getOpacity = function () {
        return this.opacity_;
    };
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */
    ImageStyle.prototype.getRotateWithView = function () {
        return this.rotateWithView_;
    };
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */
    ImageStyle.prototype.getRotation = function () {
        return this.rotation_;
    };
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */
    ImageStyle.prototype.getScale = function () {
        return this.scale_;
    };
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    ImageStyle.prototype.getScaleArray = function () {
        return this.scaleArray_;
    };
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */
    ImageStyle.prototype.getDisplacement = function () {
        return this.displacement_;
    };
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */
    ImageStyle.prototype.getAnchor = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
     */
    ImageStyle.prototype.getImage = function (pixelRatio) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * @abstract
     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
     */
    ImageStyle.prototype.getHitDetectionImage = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    ImageStyle.prototype.getPixelRatio = function (pixelRatio) {
        return 1;
    };
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */
    ImageStyle.prototype.getImageState = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */
    ImageStyle.prototype.getImageSize = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */
    ImageStyle.prototype.getOrigin = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */
    ImageStyle.prototype.getSize = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */
    ImageStyle.prototype.setDisplacement = function (displacement) {
        this.displacement_ = displacement;
    };
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */
    ImageStyle.prototype.setOpacity = function (opacity) {
        this.opacity_ = opacity;
    };
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    };
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */
    ImageStyle.prototype.setRotation = function (rotation) {
        this.rotation_ = rotation;
    };
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
    ImageStyle.prototype.setScale = function (scale) {
        this.scale_ = scale;
        this.scaleArray_ = Object(_size_js__WEBPACK_IMPORTED_MODULE_1__[/* toSize */ "c"])(scale);
    };
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    ImageStyle.prototype.listenImageChange = function (listener) {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * Load not yet loaded URI.
     * @abstract
     */
    ImageStyle.prototype.load = function () {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    ImageStyle.prototype.unlistenImageChange = function (listener) {
        Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();
    };
    return ImageStyle;
}());
/* harmony default export */ __webpack_exports__["a"] = (ImageStyle);
//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "abb7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return deflateCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return deflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return deflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return deflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/deflate
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
    for (var i = 0, ii = coordinate.length; i < ii; ++i) {
        flatCoordinates[offset++] = coordinate[i];
    }
    return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        var coordinate = coordinates[i];
        for (var j = 0; j < stride; ++j) {
            flatCoordinates[offset++] = coordinate[j];
        }
    }
    return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [opt_ends] Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
    var ends = opt_ends ? opt_ends : [];
    var i = 0;
    for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
        var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
        ends[i++] = end;
        offset = end;
    }
    ends.length = i;
    return ends;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [opt_endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
    var endss = opt_endss ? opt_endss : [];
    var i = 0;
    for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
        var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
        endss[i++] = ends;
        offset = ends[ends.length - 1];
    }
    endss.length = i;
    return endss;
}
//# sourceMappingURL=deflate.js.map

/***/ }),

/***/ "ac1f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var exec = __webpack_require__("9263");

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "ac29":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DrawEvent */
/* unused harmony export createRegularPolygon */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createBox; });
/* harmony import */ var _geom_Circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f822");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("cef7");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("01d4");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("4cdf");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("f623");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("bf62");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("7a09");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("509b");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("0b2d");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("47e4");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("9a44");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("88da");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("f403");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("4105");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("5bc3");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("3e6b");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("5831");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("57cb");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("06f8");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("0af5");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("6c77");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("256f");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("a568");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/Draw
 */























/**
 * @typedef {Object} Options
 * @property {import("../geom/GeometryType.js").default} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */
/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */
/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */
/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */
/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */
/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */
/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */
var Mode = {
    POINT: 'Point',
    LINE_STRING: 'LineString',
    POLYGON: 'Polygon',
    CIRCLE: 'Circle',
};
/**
 * @enum {string}
 */
var DrawEventType = {
    /**
     * Triggered upon feature draw start
     * @event DrawEvent#drawstart
     * @api
     */
    DRAWSTART: 'drawstart',
    /**
     * Triggered upon feature draw end
     * @event DrawEvent#drawend
     * @api
     */
    DRAWEND: 'drawend',
    /**
     * Triggered upon feature draw abortion
     * @event DrawEvent#drawabort
     * @api
     */
    DRAWABORT: 'drawabort',
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
var DrawEvent = /** @class */ (function (_super) {
    __extends(DrawEvent, _super);
    /**
     * @param {DrawEventType} type Type.
     * @param {Feature} feature The feature drawn.
     */
    function DrawEvent(type, feature) {
        var _this = _super.call(this, type) || this;
        /**
         * The feature being drawn.
         * @type {Feature}
         * @api
         */
        _this.feature = feature;
        return _this;
    }
    return DrawEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]));

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */
/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
var Draw = /** @class */ (function (_super) {
    __extends(Draw, _super);
    /**
     * @param {Options} options Options.
     */
    function Draw(options) {
        var _this = this;
        var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
        if (!pointerOptions.stopDown) {
            pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_17__[/* FALSE */ "a"];
        }
        _this = _super.call(this, pointerOptions) || this;
        /***
         * @type {DrawOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {DrawOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {DrawOnSignature<void>}
         */
        _this.un;
        /**
         * @type {boolean}
         * @private
         */
        _this.shouldHandle_ = false;
        /**
         * @type {import("../pixel.js").Pixel}
         * @private
         */
        _this.downPx_ = null;
        /**
         * @type {?}
         * @private
         */
        _this.downTimeout_;
        /**
         * @type {number|undefined}
         * @private
         */
        _this.lastDragTime_;
        /**
         * Pointer type of the last pointermove event
         * @type {string}
         * @private
         */
        _this.pointerType_;
        /**
         * @type {boolean}
         * @private
         */
        _this.freehand_ = false;
        /**
         * Target source for drawn features.
         * @type {VectorSource|null}
         * @private
         */
        _this.source_ = options.source ? options.source : null;
        /**
         * Target collection for drawn features.
         * @type {import("../Collection.js").default<Feature>|null}
         * @private
         */
        _this.features_ = options.features ? options.features : null;
        /**
         * Pixel distance for snapping.
         * @type {number}
         * @private
         */
        _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
        /**
         * Geometry type.
         * @type {import("../geom/GeometryType.js").default}
         * @private
         */
        _this.type_ = /** @type {import("../geom/GeometryType.js").default} */ (options.type);
        /**
         * Drawing mode (derived from geometry type.
         * @type {Mode}
         * @private
         */
        _this.mode_ = getMode(_this.type_);
        /**
         * Stop click, singleclick, and doubleclick events from firing during drawing.
         * Default is `false`.
         * @type {boolean}
         * @private
         */
        _this.stopClick_ = !!options.stopClick;
        /**
         * The number of points that must be drawn before a polygon ring or line
         * string can be finished.  The default is 3 for polygon rings and 2 for
         * line strings.
         * @type {number}
         * @private
         */
        _this.minPoints_ = options.minPoints
            ? options.minPoints
            : _this.mode_ === Mode.POLYGON
                ? 3
                : 2;
        /**
         * The number of points that can be drawn before a polygon ring or line string
         * is finished. The default is no restriction.
         * @type {number}
         * @private
         */
        _this.maxPoints_ =
            _this.mode_ === Mode.CIRCLE
                ? 2
                : options.maxPoints
                    ? options.maxPoints
                    : Infinity;
        /**
         * A function to decide if a potential finish coordinate is permissible
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.finishCondition_ = options.finishCondition
            ? options.finishCondition
            : _functions_js__WEBPACK_IMPORTED_MODULE_17__[/* TRUE */ "b"];
        var geometryFunction = options.geometryFunction;
        if (!geometryFunction) {
            var mode_1 = _this.mode_;
            if (mode_1 === Mode.CIRCLE) {
                /**
                 * @param {!LineCoordType} coordinates The coordinates.
                 * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
                 * @param {import("../proj/Projection.js").default} projection The view projection.
                 * @return {import("../geom/SimpleGeometry.js").default} A geometry.
                 */
                geometryFunction = function (coordinates, geometry, projection) {
                    var circle = geometry
                        ? /** @type {Circle} */ (geometry)
                        : new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]([NaN, NaN]);
                    var center = Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* fromUserCoordinate */ "j"])(coordinates[0], projection);
                    var squaredLength = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_22__[/* squaredDistance */ "h"])(center, Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* fromUserCoordinate */ "j"])(coordinates[coordinates.length - 1], projection));
                    circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
                    var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* getUserProjection */ "q"])();
                    if (userProjection) {
                        circle.transform(projection, userProjection);
                    }
                    return circle;
                };
            }
            else {
                var Constructor_1;
                if (mode_1 === Mode.POINT) {
                    Constructor_1 = _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"];
                }
                else if (mode_1 === Mode.LINE_STRING) {
                    Constructor_1 = _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"];
                }
                else if (mode_1 === Mode.POLYGON) {
                    Constructor_1 = _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"];
                }
                /**
                 * @param {!LineCoordType} coordinates The coordinates.
                 * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
                 * @param {import("../proj/Projection.js").default} projection The view projection.
                 * @return {import("../geom/SimpleGeometry.js").default} A geometry.
                 */
                geometryFunction = function (coordinates, geometry, projection) {
                    if (geometry) {
                        if (mode_1 === Mode.POLYGON) {
                            if (coordinates[0].length) {
                                // Add a closing coordinate to match the first
                                geometry.setCoordinates([
                                    coordinates[0].concat([coordinates[0][0]]),
                                ]);
                            }
                            else {
                                geometry.setCoordinates([]);
                            }
                        }
                        else {
                            geometry.setCoordinates(coordinates);
                        }
                    }
                    else {
                        geometry = new Constructor_1(coordinates);
                    }
                    return geometry;
                };
            }
        }
        /**
         * @type {GeometryFunction}
         * @private
         */
        _this.geometryFunction_ = geometryFunction;
        /**
         * @type {number}
         * @private
         */
        _this.dragVertexDelay_ =
            options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
        /**
         * Finish coordinate for the feature (first point for polygons, last point for
         * linestrings).
         * @type {import("../coordinate.js").Coordinate}
         * @private
         */
        _this.finishCoordinate_ = null;
        /**
         * Sketch feature.
         * @type {Feature<import('../geom/SimpleGeometry.js').default>}
         * @private
         */
        _this.sketchFeature_ = null;
        /**
         * Sketch point.
         * @type {Feature<Point>}
         * @private
         */
        _this.sketchPoint_ = null;
        /**
         * Sketch coordinates. Used when drawing a line or polygon.
         * @type {SketchCoordType}
         * @private
         */
        _this.sketchCoords_ = null;
        /**
         * Sketch line. Used when drawing polygon.
         * @type {Feature<LineString>}
         * @private
         */
        _this.sketchLine_ = null;
        /**
         * Sketch line coordinates. Used when drawing a polygon or circle.
         * @type {LineCoordType}
         * @private
         */
        _this.sketchLineCoords_ = null;
        /**
         * Squared tolerance for handling up events.  If the squared distance
         * between a down and up event is greater than this tolerance, up events
         * will not be handled.
         * @type {number}
         * @private
         */
        _this.squaredClickTolerance_ = options.clickTolerance
            ? options.clickTolerance * options.clickTolerance
            : 36;
        /**
         * Draw overlay where our sketch features are drawn.
         * @type {VectorLayer}
         * @private
         */
        _this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"]({
            source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]({
                useSpatialIndex: false,
                wrapX: options.wrapX ? options.wrapX : false,
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileInteracting: true,
        });
        /**
         * Name of the geometry attribute for newly created features.
         * @type {string|undefined}
         * @private
         */
        _this.geometryName_ = options.geometryName;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_18__[/* noModifierKeys */ "h"];
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.freehandCondition_;
        if (options.freehand) {
            _this.freehandCondition_ = _events_condition_js__WEBPACK_IMPORTED_MODULE_18__[/* always */ "d"];
        }
        else {
            _this.freehandCondition_ = options.freehandCondition
                ? options.freehandCondition
                : _events_condition_js__WEBPACK_IMPORTED_MODULE_18__[/* shiftKeyOnly */ "j"];
        }
        _this.addChangeListener(_Property_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].ACTIVE, _this.updateState_);
        return _this;
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */
    Draw.prototype.setMap = function (map) {
        _super.prototype.setMap.call(this, map);
        this.updateState_();
    };
    /**
     * Get the overlay layer that this interaction renders sketch features to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */
    Draw.prototype.getOverlay = function () {
        return this.overlay_;
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
     * @param {import("../MapBrowserEvent.js").default} event Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    Draw.prototype.handleEvent = function (event) {
        if (event.originalEvent.type === _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].CONTEXTMENU) {
            // Avoid context menu for long taps when drawing on mobile
            event.originalEvent.preventDefault();
        }
        this.freehand_ =
            this.mode_ !== Mode.POINT && this.freehandCondition_(event);
        var move = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].POINTERMOVE;
        var pass = true;
        if (!this.freehand_ &&
            this.lastDragTime_ &&
            event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].POINTERDRAG) {
            var now = Date.now();
            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                this.downPx_ = event.pixel;
                this.shouldHandle_ = !this.freehand_;
                move = true;
            }
            else {
                this.lastDragTime_ = undefined;
            }
            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
        }
        if (this.freehand_ &&
            event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].POINTERDRAG &&
            this.sketchFeature_ !== null) {
            this.addToDrawing_(event.coordinate);
            pass = false;
        }
        else if (this.freehand_ &&
            event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].POINTERDOWN) {
            pass = false;
        }
        else if (move && this.getPointerCount() < 2) {
            pass = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].POINTERMOVE;
            if (pass && this.freehand_) {
                this.handlePointerMove_(event);
                if (this.shouldHandle_) {
                    // Avoid page scrolling when freehand drawing on mobile
                    event.originalEvent.preventDefault();
                }
            }
            else if (event.originalEvent.pointerType === 'mouse' ||
                (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].POINTERDRAG &&
                    this.downTimeout_ === undefined)) {
                this.handlePointerMove_(event);
            }
        }
        else if (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].DBLCLICK) {
            pass = false;
        }
        return _super.prototype.handleEvent.call(this, event) && pass;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */
    Draw.prototype.handleDownEvent = function (event) {
        this.shouldHandle_ = !this.freehand_;
        if (this.freehand_) {
            this.downPx_ = event.pixel;
            if (!this.finishCoordinate_) {
                this.startDrawing_(event.coordinate);
            }
            return true;
        }
        else if (this.condition_(event)) {
            this.lastDragTime_ = Date.now();
            this.downTimeout_ = setTimeout(function () {
                this.handlePointerMove_(new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"](_MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
            }.bind(this), this.dragVertexDelay_);
            this.downPx_ = event.pixel;
            return true;
        }
        else {
            this.lastDragTime_ = undefined;
            return false;
        }
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */
    Draw.prototype.handleUpEvent = function (event) {
        var pass = true;
        if (this.getPointerCount() === 0) {
            if (this.downTimeout_) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
            this.handlePointerMove_(event);
            if (this.shouldHandle_) {
                var startingToDraw = !this.finishCoordinate_;
                if (startingToDraw) {
                    this.startDrawing_(event.coordinate);
                }
                if (!startingToDraw && this.freehand_) {
                    this.finishDrawing();
                }
                else if (!this.freehand_ &&
                    (!startingToDraw || this.mode_ === Mode.POINT)) {
                    if (this.atFinish_(event.pixel)) {
                        if (this.finishCondition_(event)) {
                            this.finishDrawing();
                        }
                    }
                    else {
                        this.addToDrawing_(event.coordinate);
                    }
                }
                pass = false;
            }
            else if (this.freehand_) {
                this.abortDrawing();
            }
        }
        if (!pass && this.stopClick_) {
            event.preventDefault();
        }
        return pass;
    };
    /**
     * Handle move events.
     * @param {import("../MapBrowserEvent.js").default} event A move event.
     * @private
     */
    Draw.prototype.handlePointerMove_ = function (event) {
        this.pointerType_ = event.originalEvent.pointerType;
        if (this.downPx_ &&
            ((!this.freehand_ && this.shouldHandle_) ||
                (this.freehand_ && !this.shouldHandle_))) {
            var downPx = this.downPx_;
            var clickPx = event.pixel;
            var dx = downPx[0] - clickPx[0];
            var dy = downPx[1] - clickPx[1];
            var squaredDistance = dx * dx + dy * dy;
            this.shouldHandle_ = this.freehand_
                ? squaredDistance > this.squaredClickTolerance_
                : squaredDistance <= this.squaredClickTolerance_;
            if (!this.shouldHandle_) {
                return;
            }
        }
        if (this.finishCoordinate_) {
            this.modifyDrawing_(event.coordinate);
        }
        else {
            this.createOrUpdateSketchPoint_(event.coordinate.slice());
        }
    };
    /**
     * Determine if an event is within the snapping tolerance of the start coord.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {boolean} The event is within the snapping tolerance of the start.
     * @private
     */
    Draw.prototype.atFinish_ = function (pixel) {
        var at = false;
        if (this.sketchFeature_) {
            var potentiallyDone = false;
            var potentiallyFinishCoordinates = [this.finishCoordinate_];
            var mode = this.mode_;
            if (mode === Mode.POINT) {
                at = true;
            }
            else if (mode === Mode.CIRCLE) {
                at = this.sketchCoords_.length === 2;
            }
            else if (mode === Mode.LINE_STRING) {
                potentiallyDone = this.sketchCoords_.length > this.minPoints_;
            }
            else if (mode === Mode.POLYGON) {
                var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);
                potentiallyDone = sketchCoords[0].length > this.minPoints_;
                potentiallyFinishCoordinates = [
                    sketchCoords[0][0],
                    sketchCoords[0][sketchCoords[0].length - 2],
                ];
            }
            if (potentiallyDone) {
                var map = this.getMap();
                for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
                    var finishCoordinate = potentiallyFinishCoordinates[i];
                    var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                    var dx = pixel[0] - finishPixel[0];
                    var dy = pixel[1] - finishPixel[1];
                    var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                    if (at) {
                        this.finishCoordinate_ = finishCoordinate;
                        break;
                    }
                }
            }
        }
        return at;
    };
    /**
     * @param {import("../coordinate").Coordinate} coordinates Coordinate.
     * @private
     */
    Draw.prototype.createOrUpdateSketchPoint_ = function (coordinates) {
        if (!this.sketchPoint_) {
            this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"](coordinates));
            this.updateSketchFeatures_();
        }
        else {
            var sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinates);
        }
    };
    /**
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @private
     */
    Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {
        if (!this.sketchLine_) {
            this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]();
        }
        var ring = geometry.getLinearRing(0);
        var sketchLineGeom = this.sketchLine_.getGeometry();
        if (!sketchLineGeom) {
            sketchLineGeom = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](ring.getFlatCoordinates(), ring.getLayout());
            this.sketchLine_.setGeometry(sketchLineGeom);
        }
        else {
            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
            sketchLineGeom.changed();
        }
    };
    /**
     * Start the drawing.
     * @param {import("../coordinate.js").Coordinate} start Start coordinate.
     * @private
     */
    Draw.prototype.startDrawing_ = function (start) {
        var projection = this.getMap().getView().getProjection();
        this.finishCoordinate_ = start;
        if (this.mode_ === Mode.POINT) {
            this.sketchCoords_ = start.slice();
        }
        else if (this.mode_ === Mode.POLYGON) {
            this.sketchCoords_ = [[start.slice(), start.slice()]];
            this.sketchLineCoords_ = this.sketchCoords_[0];
        }
        else {
            this.sketchCoords_ = [start.slice(), start.slice()];
        }
        if (this.sketchLineCoords_) {
            this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](this.sketchLineCoords_));
        }
        var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
        this.sketchFeature_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]();
        if (this.geometryName_) {
            this.sketchFeature_.setGeometryName(this.geometryName_);
        }
        this.sketchFeature_.setGeometry(geometry);
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    };
    /**
     * Modify the drawing.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @private
     */
    Draw.prototype.modifyDrawing_ = function (coordinate) {
        var map = this.getMap();
        var geometry = this.sketchFeature_.getGeometry();
        var projection = map.getView().getProjection();
        var coordinates, last;
        if (this.mode_ === Mode.POINT) {
            last = this.sketchCoords_;
        }
        else if (this.mode_ === Mode.POLYGON) {
            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
            last = coordinates[coordinates.length - 1];
            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
                // snap to finish
                coordinate = this.finishCoordinate_.slice();
            }
        }
        else {
            coordinates = this.sketchCoords_;
            last = coordinates[coordinates.length - 1];
        }
        last[0] = coordinate[0];
        last[1] = coordinate[1];
        this.geometryFunction_(
        /** @type {!LineCoordType} */ (this.sketchCoords_), geometry, projection);
        if (this.sketchPoint_) {
            var sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinate);
        }
        if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].POLYGON &&
            this.mode_ !== Mode.POLYGON) {
            this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));
        }
        else if (this.sketchLineCoords_) {
            var sketchLineGeom = this.sketchLine_.getGeometry();
            sketchLineGeom.setCoordinates(this.sketchLineCoords_);
        }
        this.updateSketchFeatures_();
    };
    /**
     * Add a new coordinate to the drawing.
     * @param {!PointCoordType} coordinate Coordinate
     * @private
     */
    Draw.prototype.addToDrawing_ = function (coordinate) {
        var geometry = this.sketchFeature_.getGeometry();
        var projection = this.getMap().getView().getProjection();
        var done;
        var coordinates;
        var mode = this.mode_;
        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
            this.finishCoordinate_ = coordinate.slice();
            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) {
                    coordinates.pop();
                }
                else {
                    done = true;
                }
            }
            coordinates.push(coordinate.slice());
            this.geometryFunction_(coordinates, geometry, projection);
        }
        else if (mode === Mode.POLYGON) {
            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) {
                    coordinates.pop();
                }
                else {
                    done = true;
                }
            }
            coordinates.push(coordinate.slice());
            if (done) {
                this.finishCoordinate_ = coordinates[0];
            }
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        this.createOrUpdateSketchPoint_(coordinate.slice());
        this.updateSketchFeatures_();
        if (done) {
            this.finishDrawing();
        }
    };
    /**
     * Remove last point of the feature currently being drawn. Does not do anything when
     * drawing POINT or MULTI_POINT geometries.
     * @api
     */
    Draw.prototype.removeLastPoint = function () {
        if (!this.sketchFeature_) {
            return;
        }
        var geometry = this.sketchFeature_.getGeometry();
        var projection = this.getMap().getView().getProjection();
        var coordinates;
        var mode = this.mode_;
        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
            coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
            coordinates.splice(-2, 1);
            if (coordinates.length >= 2) {
                this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
                var finishCoordinate = this.finishCoordinate_.slice();
                coordinates[coordinates.length - 1] = finishCoordinate;
                this.createOrUpdateSketchPoint_(finishCoordinate);
            }
            this.geometryFunction_(coordinates, geometry, projection);
            if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].POLYGON && this.sketchLine_) {
                this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));
            }
        }
        else if (mode === Mode.POLYGON) {
            coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
            coordinates.splice(-2, 1);
            var sketchLineGeom = this.sketchLine_.getGeometry();
            if (coordinates.length >= 2) {
                var finishCoordinate = coordinates[coordinates.length - 2].slice();
                coordinates[coordinates.length - 1] = finishCoordinate;
                this.createOrUpdateSketchPoint_(finishCoordinate);
            }
            sketchLineGeom.setCoordinates(coordinates);
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        if (coordinates.length === 1) {
            this.abortDrawing();
        }
        this.updateSketchFeatures_();
    };
    /**
     * Stop drawing and add the sketch feature to the target layer.
     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
     * dispatched before inserting the feature.
     * @api
     */
    Draw.prototype.finishDrawing = function () {
        var sketchFeature = this.abortDrawing_();
        if (!sketchFeature) {
            return;
        }
        var coordinates = this.sketchCoords_;
        var geometry = sketchFeature.getGeometry();
        var projection = this.getMap().getView().getProjection();
        if (this.mode_ === Mode.LINE_STRING) {
            // remove the redundant last point
            coordinates.pop();
            this.geometryFunction_(coordinates, geometry, projection);
        }
        else if (this.mode_ === Mode.POLYGON) {
            // remove the redundant last point in ring
            /** @type {PolyCoordType} */ (coordinates)[0].pop();
            this.geometryFunction_(coordinates, geometry, projection);
            coordinates = geometry.getCoordinates();
        }
        // cast multi-part geometries
        if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].MULTI_POINT) {
            sketchFeature.setGeometry(new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]([/** @type {PointCoordType} */ (coordinates)]));
        }
        else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].MULTI_LINE_STRING) {
            sketchFeature.setGeometry(new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"]([/** @type {LineCoordType} */ (coordinates)]));
        }
        else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].MULTI_POLYGON) {
            sketchFeature.setGeometry(new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"]([/** @type {PolyCoordType} */ (coordinates)]));
        }
        // First dispatch event to allow full set up of feature
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
        // Then insert feature
        if (this.features_) {
            this.features_.push(sketchFeature);
        }
        if (this.source_) {
            this.source_.addFeature(sketchFeature);
        }
    };
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
     * @private
     */
    Draw.prototype.abortDrawing_ = function () {
        this.finishCoordinate_ = null;
        var sketchFeature = this.sketchFeature_;
        this.sketchFeature_ = null;
        this.sketchPoint_ = null;
        this.sketchLine_ = null;
        this.overlay_.getSource().clear(true);
        return sketchFeature;
    };
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @api
     */
    Draw.prototype.abortDrawing = function () {
        var sketchFeature = this.abortDrawing_();
        if (sketchFeature) {
            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
        }
    };
    /**
     * Append coordinates to the end of the geometry that is currently being drawn.
     * This can be used when drawing LineStrings or Polygons. Coordinates will
     * either be appended to the current LineString or the outer ring of the current
     * Polygon. If no geometry is being drawn, a new one will be created.
     * @param {!LineCoordType} coordinates Linear coordinates to be appended to
     * the coordinate array.
     * @api
     */
    Draw.prototype.appendCoordinates = function (coordinates) {
        var mode = this.mode_;
        var newDrawing = !this.sketchFeature_;
        if (newDrawing) {
            this.startDrawing_(coordinates[0]);
        }
        /** @type {LineCoordType} */
        var sketchCoords;
        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
            sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);
        }
        else if (mode === Mode.POLYGON) {
            sketchCoords =
                this.sketchCoords_ && this.sketchCoords_.length
                    ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]
                    : [];
        }
        else {
            return;
        }
        if (newDrawing) {
            sketchCoords.shift();
        }
        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
        sketchCoords.pop();
        // Append coordinate list
        for (var i = 0; i < coordinates.length; i++) {
            this.addToDrawing_(coordinates[i]);
        }
        var ending = coordinates[coordinates.length - 1];
        // Duplicate last coordinate for sketch drawing (cursor position)
        this.addToDrawing_(ending);
        this.modifyDrawing_(ending);
    };
    /**
     * Initiate draw mode by starting from an existing geometry which will
     * receive new additional points. This only works on features with
     * `LineString` geometries, where the interaction will extend lines by adding
     * points to the end of the coordinates array.
     * This will change the original feature, instead of drawing a copy.
     *
     * The function will dispatch a `drawstart` event.
     *
     * @param {!Feature<LineString>} feature Feature to be extended.
     * @api
     */
    Draw.prototype.extend = function (feature) {
        var geometry = feature.getGeometry();
        var lineString = geometry;
        this.sketchFeature_ = feature;
        this.sketchCoords_ = lineString.getCoordinates();
        var last = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = last.slice();
        this.sketchCoords_.push(last.slice());
        this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"](last));
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    };
    /**
     * Redraw the sketch features.
     * @private
     */
    Draw.prototype.updateSketchFeatures_ = function () {
        var sketchFeatures = [];
        if (this.sketchFeature_) {
            sketchFeatures.push(this.sketchFeature_);
        }
        if (this.sketchLine_) {
            sketchFeatures.push(this.sketchLine_);
        }
        if (this.sketchPoint_) {
            sketchFeatures.push(this.sketchPoint_);
        }
        var overlaySource = this.overlay_.getSource();
        overlaySource.clear(true);
        overlaySource.addFeatures(sketchFeatures);
    };
    /**
     * @private
     */
    Draw.prototype.updateState_ = function () {
        var map = this.getMap();
        var active = this.getActive();
        if (!map || !active) {
            this.abortDrawing();
        }
        this.overlay_.setMap(active ? map : null);
    };
    return Draw;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_13__[/* default */ "b"]));
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
    var styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_20__[/* createEditingStyle */ "b"])();
    return function (feature, resolution) {
        return styles[feature.getGeometry().getType()];
    };
}
/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * {@link import("../geom/Circle.js").Circle} geometry.
 * @param {number} [opt_sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [opt_angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */
function createRegularPolygon(opt_sides, opt_angle) {
    return function (coordinates, opt_geometry, projection) {
        var center = Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* fromUserCoordinate */ "j"])(
        /** @type {LineCoordType} */ (coordinates)[0], projection);
        var end = Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* fromUserCoordinate */ "j"])(
        /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1], projection);
        var radius = Math.sqrt(Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_22__[/* squaredDistance */ "h"])(center, end));
        var geometry = opt_geometry
            ? /** @type {Polygon} */ (opt_geometry)
            : Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__[/* fromCircle */ "b"])(new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](center), opt_sides);
        var angle = opt_angle;
        if (!opt_angle && opt_angle !== 0) {
            var x = end[0] - center[0];
            var y = end[1] - center[1];
            angle = Math.atan2(y, x);
        }
        Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__[/* makeRegular */ "d"])(geometry, center, radius, angle);
        var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* getUserProjection */ "q"])();
        if (userProjection) {
            geometry.transform(projection, userProjection);
        }
        return geometry;
    };
}
/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */
function createBox() {
    return function (coordinates, opt_geometry, projection) {
        var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__[/* boundingExtent */ "b"])(
        /** @type {LineCoordType} */ ([
            coordinates[0],
            coordinates[coordinates.length - 1],
        ]).map(function (coordinate) {
            return Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* fromUserCoordinate */ "j"])(coordinate, projection);
        }));
        var boxCoordinates = [
            [
                Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__[/* getBottomLeft */ "u"])(extent),
                Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__[/* getBottomRight */ "v"])(extent),
                Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__[/* getTopRight */ "C"])(extent),
                Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__[/* getTopLeft */ "B"])(extent),
                Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__[/* getBottomLeft */ "u"])(extent),
            ],
        ];
        var geometry = opt_geometry;
        if (geometry) {
            geometry.setCoordinates(boxCoordinates);
        }
        else {
            geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"](boxCoordinates);
        }
        var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_21__[/* getUserProjection */ "q"])();
        if (userProjection) {
            geometry.transform(projection, userProjection);
        }
        return geometry;
    };
}
/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/GeometryType.js").default} type Geometry type.
 * @return {Mode} Drawing mode.
 */
function getMode(type) {
    switch (type) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].MULTI_POINT:
            return Mode.POINT;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LINE_STRING:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].MULTI_LINE_STRING:
            return Mode.LINE_STRING;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].POLYGON:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].MULTI_POLYGON:
            return Mode.POLYGON;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].CIRCLE:
            return Mode.CIRCLE;
        default:
            throw new Error('Invalid type: ' + type);
    }
}
/* harmony default export */ __webpack_exports__["b"] = (Draw);
//# sourceMappingURL=Draw.js.map

/***/ }),

/***/ "acc1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/TileState
 */
/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
     * Indicates that tile loading failed
     * @type {number}
     */
    ERROR: 3,
    EMPTY: 4,
});
//# sourceMappingURL=TileState.js.map

/***/ }),

/***/ "ad6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("825a");

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "aed9":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ "afd9":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "b041":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classof = __webpack_require__("f5df");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "b052":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track01.891b9225.png";

/***/ }),

/***/ "b0c1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return padNumber; });
/* unused harmony export compareVersions */
/**
 * @module ol/string
 */
/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [opt_precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
    var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
    var decimal = numberString.indexOf('.');
    decimal = decimal === -1 ? numberString.length : decimal;
    return decimal > width
        ? numberString
        : new Array(1 + width - decimal).join('0') + numberString;
}
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */
function compareVersions(v1, v2) {
    var s1 = ('' + v1).split('.');
    var s2 = ('' + v2).split('.');
    for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
        var n1 = parseInt(s1[i] || '0', 10);
        var n2 = parseInt(s2[i] || '0', 10);
        if (n1 > n2) {
            return 1;
        }
        if (n2 > n1) {
            return -1;
        }
    }
    return 0;
}
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "b142":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "b1a2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return interpolatePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return lineStringCoordinateAtM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return lineStringsCoordinateAtM; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9f5e");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7fc9");
/**
 * @module ol/geom/flat/interpolate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [opt_dest] Destination.
 * @param {number} [opt_dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
    var o, t;
    var n = (end - offset) / stride;
    if (n === 1) {
        o = offset;
    }
    else if (n === 2) {
        o = offset;
        t = fraction;
    }
    else if (n !== 0) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        var length_1 = 0;
        var cumulativeLengths = [0];
        for (var i = offset + stride; i < end; i += stride) {
            var x2 = flatCoordinates[i];
            var y2 = flatCoordinates[i + 1];
            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            cumulativeLengths.push(length_1);
            x1 = x2;
            y1 = y2;
        }
        var target = fraction * length_1;
        var index = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__[/* binarySearch */ "a"])(cumulativeLengths, target);
        if (index < 0) {
            t =
                (target - cumulativeLengths[-index - 2]) /
                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
            o = offset + (-index - 2) * stride;
        }
        else {
            o = offset + index * stride;
        }
    }
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var dest = opt_dest ? opt_dest : new Array(dimension);
    for (var i = 0; i < dimension; ++i) {
        dest[i] =
            o === undefined
                ? NaN
                : t === undefined
                    ? flatCoordinates[o + i]
                    : Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* lerp */ "e"])(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
    }
    return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) {
        return null;
    }
    var coordinate;
    if (m < flatCoordinates[offset + stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(offset, offset + stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    else if (flatCoordinates[end - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(end - stride, end);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    // FIXME use O(1) search
    if (m == flatCoordinates[offset + stride - 1]) {
        return flatCoordinates.slice(offset, offset + stride);
    }
    var lo = offset / stride;
    var hi = end / stride;
    while (lo < hi) {
        var mid = (lo + hi) >> 1;
        if (m < flatCoordinates[(mid + 1) * stride - 1]) {
            hi = mid;
        }
        else {
            lo = mid + 1;
        }
    }
    var m0 = flatCoordinates[lo * stride - 1];
    if (m == m0) {
        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    }
    var m1 = flatCoordinates[(lo + 1) * stride - 1];
    var t = (m - m0) / (m1 - m0);
    coordinate = [];
    for (var i = 0; i < stride - 1; ++i) {
        coordinate.push(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* lerp */ "e"])(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
    }
    coordinate.push(m);
    return coordinate;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) {
        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    }
    var coordinate;
    if (m < flatCoordinates[stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(0, stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        else {
            return null;
        }
    }
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        if (offset == end) {
            continue;
        }
        if (m < flatCoordinates[offset + stride - 1]) {
            return null;
        }
        else if (m <= flatCoordinates[end - 1]) {
            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
        }
        offset = end;
    }
    return null;
}
//# sourceMappingURL=interpolate.js.map

/***/ }),

/***/ "b358":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABIZJREFUeNq0l1tsG0UUhn/fkyaN3dACvcRykkrl0lJDiYQUKtwXKlUg+QEJKkAEXihC0BRUKi5SwxMCVAK8BJ7SCEFa8dBWoipUSA4hrarSEJdY5VKROImIQprYjq+x1+vhzGTXWTu+JmWk37s7O7PfnJkzZ451qLJMo9FJF1tedWgLAt5qvqOrEOaiywskdwFoFk46S+qjQQysCaxY101yaevNrvacdmmvD5nQgraKg49UOwsqtIPEVAU7XmVJzxArVlIjo2yh8x02Y2tmmn4d1UJ71c5zridZenyCVVrkYIgF3M9p4b2VQjvVTpGuD9lqS7z3Gy28s6wT3Q5oEXiOnxi0D2+i9gxd7q5xH4C15wTOHXsPnu7PhQdueWAnrn19Cr7zF0TbsaHLuPjBR0gnk+JdoWJy7gJbCEO6co0/Ok8g8eUKr1YcoVdvs2LjyAD8U1O4/PpR7H+oDac9P0LafCfWhyLY3bwdgzd/hzWdQdtWO676x+B45SU8/vbRgnDu7XMPuiD7J/nji+TpJ/mNXtOG71NYyFqDwy4qbJYaWJISnt/zCOqnZ7Hb3owdtkY81XoPnmjZAbvBhDbrHfj750tFl48bUnf45RxGFkzW2tS9Wnf4ULYTS6aQiURIUezdtBk/eYfxw/BVNNBgzLGYsCa0EEJwYhI9B9zwfXehILy246B661JYMCoVTnV0JufOHDAjKFtMYpPMcNB2F/pnpzBI9XadEU0Z4P6kjK3BObCb/+Db6z603hhGrdW6wmr+XYkCjcIaUKdaWGt05jlJSgELRWCJJfC0oQ6hW7fwS2BWWMxVF4vDJEnYNh/E9G++glabXY9Cy9KX2l6MPJYDBTgcFdNuicawP57GusQiPpPCWEwtIsJkLIChkRzu9KHXiq51znNJMFmcCS9Zy6JRISmRQCIj42Ga4hYCfV+jw59GHW6YdKiRM8iMT+CT9n0lHa4sGHyNo1HhXOl4DIm0BHIp0BCE7iV4LcF8BE2xjLC6aVFC3ZVfaY9/XBHYz39k/9QKi2UCJ6Uk4vThmALkUu83SLLY0zNGvVCKIsN2psM8OVpwcvl7yYEhaFkq2LsEnlQ3uiiyLAvgEgxZYP4AGqQ0zOT1YQLHLRbcxwxomQ8hMLH8rdRAduq9WbByboqRJPpOZRsH6G0+SKs4KcVnhrSR4NtomgO0FF+tI+v37MqG0sTJ/qy16hmtXeM+/hOnRnyLtO5tF1FssEaP62Y9fKQ/zAb8RRojTZmNmCHN5qme1jxua8AblzzZ/Rzv689h5MdqHlHGeaRc33UM9cffEvU8Gk2P+qo6z9uefQYb7E3iPvbpFwgfeVdNjZrJ4lDJszhx5vyaj0WelWgykrJnsoc35B1KpTpVQj2VZCA20shaEoJod48WOqIeDFXD/3U4RTZRrvDl4TmaJusoCi2X3nbR5bg23vKDxLIc8EWRvKNin+aluO+TI3WtOqEnuEOBl0rm85N6DvWv+Z+EZhBu5Tx9TJPk84Bwjl8Jdva2/oUp5v3KDOwruDf/r6I4oGO1/f8TYAD8oxIpHxFGqwAAAABJRU5ErkJggg=="

/***/ }),

/***/ "b401":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABAxJREFUeNqsV7tPWmEUPyIRER+IqIgd2qDGWExoqo4VlrraoalOylindrVD9Q8w7eToY6luYtoOdlE71dCkNDqW1JiI8c1TuPKw53x+3/WCFwTpSQ7f5ePe+zvn950XFVCi/PH7HbgYc7aDHTabr5T3VBQJ5sRlDHVYBVQGR/WgLqIRG2UBc+8+oDqV+3q9Pus+SZIgk8kotwj4bSEWKgqAjuMyL77X1dUx1VdXq94vXV5CJBJhqjDCjeALRQMjKAGOC+9amptBq9UWdXYEenR8DLFYTGwtILj7TmAEfcPpBVNjIzSi3kfIczKAC9H+MS8wD6L1ckHzgLuUQZfLH/PUYDAw0FWPB/YDAejv72fq9Xrh/OwMbB0dcIbrzvY22Ht72W9qQjFBZx8KhcS7n4jfNDnB5NBoNGBuagK/3w/xeBzcbjcDnJmZYUDW9nbwoEF0/WxwkK3f1tbyek3M8fhwcIxbHo8Jb0UgmUwmFlwTExMwPzcH/QMDYLfbwWq1sn2RVmsI/DwPMDlibGiAk9NTgbEge4yWGEWuNuBNajI0NMQAiH5hEAlRTvTPzs7Czs5OXsq5ODmWTLVDWKerqlJ9mCgmz/FBRi0dBQmd72vcHxkZAc/KCjseNa8V73UogZm3Op2uYJQK2snL75ub8j5RqddVQ2dnJwQwGNWk+qbaObOCq1gh8FfoXUN9PbybnITLeALCoTCEgkGwtrXB8tKS6nOVmmyo0oCvriCdTEI8dgEupwse9/TAp+Ul+O37Bd6fXqilwKysZBkgjiKfFA2cSaUhgd5FI1EsDGGmfU/7oL62Fn5sbbFGQV73dHeDtbWVBWIhEem0Sx9J9OaWk1h7k1gEpIQECSmBawISeC1J16vFYoEgFoi9vT00KgKGmhpoxb3A4SELNBH9cXxOiSWAWftKpVJMRR6n8foiGlMFlOS9BLSYzez6+OQELjB1Xo6OQiQaZYFms9mugW+i3SdTzfvmrqivQqjOMlrDEbnlkUbZXhii+PJLZOMKz/4Bplt3VxccHhzIOS1qveKdu6JHKyvXIur7MN5ERYQspZT5/OUr1NToGRNpzkgqnYY0qpqY0fsjpHlqevqmWaCBCozs7sQryl9KS2VnIssD+/slBX8fFhWqbiTUIHi5pNHoEXocVGuLci+2YGRS3S5HqDPROfOJJKsnqw0C1I+dVOYoYvONOiWCbiCo6648fkGRRw/Qg+fn5yWDEr0KUB9/Z1Ezl5FPIqygU3rRuSu6jKrQnBXCaM9JHZc411LG2ymK9Kwug40kl36ilcByRtxpBJy690CP4A85eKFhPneoJ9Ddsv9JKIwY5vQPKoZ8onOVVgTz/Ne/MHmMWOcMqJ7hXaItI00pUo33ASX5J8AAc2YlgXv6+0AAAAAASUVORK5CYII="

/***/ }),

/***/ "b4de":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "b52d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "b575":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var bind = __webpack_require__("0366");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var macrotask = __webpack_require__("2cf4").set;
var IS_IOS = __webpack_require__("1cdc");
var IS_IOS_PEBBLE = __webpack_require__("d4c3");
var IS_WEBOS_WEBKIT = __webpack_require__("a4b4");
var IS_NODE = __webpack_require__("605d");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise;
    then = bind(promise.then, promise);
    notify = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    // strange IE + webpack dev server bug - use .bind(global)
    macrotask = bind(macrotask, global);
    notify = function () {
      macrotask(flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "b589":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return linearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return linearRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return linearRingss; });
/**
 * @module ol/geom/flat/area
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
    var twiceArea = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];
    for (; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        twiceArea += y1 * x2 - x1 * y2;
        x1 = x2;
        y1 = y2;
    }
    return twiceArea / 2;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
    var area = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        area += linearRing(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return area;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
    var area = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        area += linearRings(flatCoordinates, offset, ends, stride);
        offset = ends[ends.length - 1];
    }
    return area;
}
//# sourceMappingURL=area.js.map

/***/ }),

/***/ "b622":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var shared = __webpack_require__("5692");
var hasOwn = __webpack_require__("1a2d");
var uid = __webpack_require__("90e3");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "b6eb":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAVZSURBVEhLtVZ7bFNVGG/wH2NMiBITY5y8JICjt73nFtEEQzAm/oExErMQBGOMxMQQDRiNwQdESYzPKCYwngtjbAt7OGTANtxYh6ztQCbyUoHe2+ft1r3adV22devP892eAu268f4lX7p7zvf9fuc753zfmelO8FJB79TnPw/LbIt/qbkozJRPeqeKqXuPRd/5pYVFoS9ZWdAuH/D6LZXeqLnGEzfXeqPSb16/dDDYLFXqX8jF+nwRcndQNv07z7avo4LVBJOKYwDM2YM5LUHMavZhvt2H2U0+zLEHwVw93AZgOaonpJpQSf6Wy7MFxe2D/ay+pVR3xBRXDNIJH6TjGp4+pmLFKR1N4TguRoeMX/qmcZq3tPjBTvEFHOmISMXqm4Lq1qH84l5va4jC0tphEEpNHsz/XcMiuxe9w6O4EfRN4zRPflKTBiuPY/YozMXqx4Ly5lB+urrSVs9FTwYMkhSZB3OOaXjNGRRymaBxmk/7UpzlRACspR8L9rlXCeqJ8exmz0xWocetDp7pDaJp4VcnEKbxTOGUOGUu1epxS6E2Q0jkBtupVin8kmSLkmULD48B/0UBfZBn7MolTKYZZy6Vq2VCYjxsX6lz5epAUjrhz0EwXniEC/sGgO6hXFt93SzEV+tPTJg1K9Q2KK18deIyZVsuYe8tCBMfcw7AXKatE1KZYHs9h5izL3cwt2xhgi8OhCbd6pTJbRGYK7QqIZUJucTTbnV05QwkI+JljgCQTCIQSaDVN4RAf6q0aHwyYYO3WjstpDIhl2rnrY5wzkCyx4+6sfJ0kG/tGOYWhWHa7MOThSHoA6NY9aduzOeKI7O2hmH+VTsvpDLBSjwO2dGdM/Cpejc++LsTPcMJRHiSr5wdQ97BKEzbdQTjY4gmRo158ssVb3V2w1yltQmpTMhF2n7mjI4Lms7J1p0LG1saTQAb3cDrl4B5xwZg2qFjWUMfdC5OID/yz+ZgbZy3wpO7pNg2z1rlD96Xm6+fVbpNRkdGEeeZrvkHWHIGWEHCDVx4dwimQh0zKrvQN5xEf2Isq31yo1vt4Lyl2ntCKhPUteQq3+iNdTy9XsWHItuKTuAFLrr8XJbw3k6YturYfJbXFgf5U1yag1qndMg3kr81kCekxkPerdYyF213asV5dSq+vdxjEH7jAV5s56WTS3h7CMuPRww/8qe4lDB1rn5IB7QKIZEb7Ht1kXKYX316Bhs9mMFX/j6/NIT9oUky3qbj0zMxw4/8Kc4QbvHBWh9C/h7VIiQmhrxD3a/wTkNn8ww/K3bcg66hBGL8jN+4ACzlWRdcFMK7dH7GIUwrDSM8OIZu/kTK3J/iUtnGIZWpuwT15Fi8QX+Mlfu7rY5OI5hW//YZni6SCI8AH13hWXPhJw7HjHJaXNuDy9FUIyG/VLb8ZaKmUeMPmbd5HxHUNwf78epyW0PE2HIL3zKqz9WnQ7gS442ZI8qr51wkCS/9waHFh435dB3TwyA39kAquvKyoLx1sK3qD7aTg5DsnIiTzWxQkd+o4Z32ELa7e1EdjGK3pw9r2juMcZonP6mZ160zjgXFVzcKqtsH2+M9rHCSdG2TwCwukFfnvmb0TePGZaKabRuEuVwrERR3BuXd4EOsOOAy/uGb4Lm8ZiTKL5O50l9nMmGKoLhzPLf+wqPKvuBfhjhlzstsIlFLVbBx+ibtQRF691i49tI0Vqy7jDIzxEX29Etn2kaigbp7KprGkoILDyt7g3W2Vn7mLd6UKG8QdJGkA4FSU0HFA8L1fmDTFNvOwC5bcwxWVxdkewSWct/XYvL+Q9nh/Uw50q8tKPOsFkO3AZPpf4A8PG2I3gdtAAAAAElFTkSuQmCC"

/***/ }),

/***/ "b727":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var uncurryThis = __webpack_require__("e330");
var IndexedObject = __webpack_require__("44ad");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var arraySpeciesCreate = __webpack_require__("65f0");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "b739":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0af5");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("256f");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("7fc9");
/**
 * @module ol/reproj/Triangulation
 */



/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */
/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;
/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
var MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
var Triangulation = /** @class */ (function () {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
     * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
     * @param {number} errorThreshold Acceptable error (in source units).
     * @param {?number} opt_destinationResolution The (optional) resolution of the destination.
     */
    function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
        /**
         * @type {import("../proj/Projection.js").default}
         * @private
         */
        this.sourceProj_ = sourceProj;
        /**
         * @type {import("../proj/Projection.js").default}
         * @private
         */
        this.targetProj_ = targetProj;
        /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
        var transformInvCache = {};
        var transformInv = Object(_proj_js__WEBPACK_IMPORTED_MODULE_1__[/* getTransform */ "o"])(this.targetProj_, this.sourceProj_);
        /**
         * @param {import("../coordinate.js").Coordinate} c A coordinate.
         * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
         * @private
         */
        this.transformInv_ = function (c) {
            var key = c[0] + '/' + c[1];
            if (!transformInvCache[key]) {
                transformInvCache[key] = transformInv(c);
            }
            return transformInvCache[key];
        };
        /**
         * @type {import("../extent.js").Extent}
         * @private
         */
        this.maxSourceExtent_ = maxSourceExtent;
        /**
         * @type {number}
         * @private
         */
        this.errorThresholdSquared_ = errorThreshold * errorThreshold;
        /**
         * @type {Array<Triangle>}
         * @private
         */
        this.triangles_ = [];
        /**
         * Indicates that the triangulation crosses edge of the source projection.
         * @type {boolean}
         * @private
         */
        this.wrapsXInSource_ = false;
        /**
         * @type {boolean}
         * @private
         */
        this.canWrapXInSource_ =
            this.sourceProj_.canWrapX() &&
                !!maxSourceExtent &&
                !!this.sourceProj_.getExtent() &&
                Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(maxSourceExtent) == Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(this.sourceProj_.getExtent());
        /**
         * @type {?number}
         * @private
         */
        this.sourceWorldWidth_ = this.sourceProj_.getExtent()
            ? Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(this.sourceProj_.getExtent())
            : null;
        /**
         * @type {?number}
         * @private
         */
        this.targetWorldWidth_ = this.targetProj_.getExtent()
            ? Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(this.targetProj_.getExtent())
            : null;
        var destinationTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getTopLeft */ "B"])(targetExtent);
        var destinationTopRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getTopRight */ "C"])(targetExtent);
        var destinationBottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getBottomRight */ "v"])(targetExtent);
        var destinationBottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getBottomLeft */ "u"])(targetExtent);
        var sourceTopLeft = this.transformInv_(destinationTopLeft);
        var sourceTopRight = this.transformInv_(destinationTopRight);
        var sourceBottomRight = this.transformInv_(destinationBottomRight);
        var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
        /*
         * The maxSubdivision controls how many splittings of the target area can
         * be done. The idea here is to do a linear mapping of the target areas
         * but the actual overal reprojection (can be) extremely non-linear. The
         * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
         * tile size. However this function is also called to remap canvas rendered
         * layers which can be much larger. This calculation increases the maxSubdivision
         * value by the right factor so that each 256x256 pixel area has
         * MAX_SUBDIVISION divisions.
         */
        var maxSubdivision = MAX_SUBDIVISION +
            (opt_destinationResolution
                ? Math.max(0, Math.ceil(Object(_math_js__WEBPACK_IMPORTED_MODULE_2__[/* log2 */ "f"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getArea */ "t"])(targetExtent) /
                    (opt_destinationResolution *
                        opt_destinationResolution *
                        256 *
                        256))))
                : 0);
        this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
        if (this.wrapsXInSource_) {
            var leftBound_1 = Infinity;
            this.triangles_.forEach(function (triangle, i, arr) {
                leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
            });
            // Shift triangles to be as close to `leftBound` as possible
            // (if the distance is more than `worldWidth / 2` it can be closer.
            this.triangles_.forEach(function (triangle) {
                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -
                    leftBound_1 >
                    this.sourceWorldWidth_ / 2) {
                    var newTriangle = [
                        [triangle.source[0][0], triangle.source[0][1]],
                        [triangle.source[1][0], triangle.source[1][1]],
                        [triangle.source[2][0], triangle.source[2][1]],
                    ];
                    if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                        newTriangle[0][0] -= this.sourceWorldWidth_;
                    }
                    if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                        newTriangle[1][0] -= this.sourceWorldWidth_;
                    }
                    if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                        newTriangle[2][0] -= this.sourceWorldWidth_;
                    }
                    // Rarely (if the extent contains both the dateline and prime meridian)
                    // the shift can in turn break some triangles.
                    // Detect this here and don't shift in such cases.
                    var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                    var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                    if (maxX - minX < this.sourceWorldWidth_ / 2) {
                        triangle.source = newTriangle;
                    }
                }
            }.bind(this));
        }
        transformInvCache = {};
    }
    /**
     * Adds triangle to the triangulation.
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @private
     */
    Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
        this.triangles_.push({
            source: [aSrc, bSrc, cSrc],
            target: [a, b, c],
        });
    };
    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */
    Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
        var sourceQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* boundingExtent */ "b"])([aSrc, bSrc, cSrc, dSrc]);
        var sourceCoverageX = this.sourceWorldWidth_
            ? Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(sourceQuadExtent) / this.sourceWorldWidth_
            : null;
        var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);
        // when the quad is wrapped in the source projection
        // it covers most of the projection extent, but not fully
        var wrapsX = this.sourceProj_.canWrapX() &&
            sourceCoverageX > 0.5 &&
            sourceCoverageX < 1;
        var needsSubdivision = false;
        if (maxSubdivision > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                var targetQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* boundingExtent */ "b"])([a, b, c, d]);
                var targetCoverageX = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* getWidth */ "D"])(targetQuadExtent) / this.targetWorldWidth_;
                needsSubdivision =
                    targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
            }
            if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
                needsSubdivision =
                    sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
            }
        }
        if (!needsSubdivision && this.maxSourceExtent_) {
            if (isFinite(sourceQuadExtent[0]) &&
                isFinite(sourceQuadExtent[1]) &&
                isFinite(sourceQuadExtent[2]) &&
                isFinite(sourceQuadExtent[3])) {
                if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* intersects */ "E"])(sourceQuadExtent, this.maxSourceExtent_)) {
                    // whole quad outside source projection extent -> ignore
                    return;
                }
            }
        }
        var isNotFinite = 0;
        if (!needsSubdivision) {
            if (!isFinite(aSrc[0]) ||
                !isFinite(aSrc[1]) ||
                !isFinite(bSrc[0]) ||
                !isFinite(bSrc[1]) ||
                !isFinite(cSrc[0]) ||
                !isFinite(cSrc[1]) ||
                !isFinite(dSrc[0]) ||
                !isFinite(dSrc[1])) {
                if (maxSubdivision > 0) {
                    needsSubdivision = true;
                }
                else {
                    // It might be the case that only 1 of the points is infinite. In this case
                    // we can draw a single triangle with the other three points
                    isNotFinite =
                        (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +
                            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +
                            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +
                            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                    if (isNotFinite != 1 &&
                        isNotFinite != 2 &&
                        isNotFinite != 4 &&
                        isNotFinite != 8) {
                        return;
                    }
                }
            }
        }
        if (maxSubdivision > 0) {
            if (!needsSubdivision) {
                var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
                var centerSrc = this.transformInv_(center);
                var dx = void 0;
                if (wrapsX) {
                    var centerSrcEstimX = (Object(_math_js__WEBPACK_IMPORTED_MODULE_2__[/* modulo */ "g"])(aSrc[0], sourceWorldWidth) +
                        Object(_math_js__WEBPACK_IMPORTED_MODULE_2__[/* modulo */ "g"])(cSrc[0], sourceWorldWidth)) /
                        2;
                    dx = centerSrcEstimX - Object(_math_js__WEBPACK_IMPORTED_MODULE_2__[/* modulo */ "g"])(centerSrc[0], sourceWorldWidth);
                }
                else {
                    dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                }
                var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                var centerSrcErrorSquared = dx * dx + dy * dy;
                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
            }
            if (needsSubdivision) {
                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                    // split horizontally (top & bottom)
                    var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
                    var bcSrc = this.transformInv_(bc);
                    var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
                    var daSrc = this.transformInv_(da);
                    this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                    this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                }
                else {
                    // split vertically (left & right)
                    var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
                    var abSrc = this.transformInv_(ab);
                    var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
                    var cdSrc = this.transformInv_(cd);
                    this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                    this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                }
                return;
            }
        }
        if (wrapsX) {
            if (!this.canWrapXInSource_) {
                return;
            }
            this.wrapsXInSource_ = true;
        }
        // Exactly zero or one of *Src is not finite
        // The triangles must have the diagonal line as the first side
        // This is to allow easy code in reproj.s to make it straight for broken
        // browsers that can't handle diagonal clipping
        if ((isNotFinite & 0xb) == 0) {
            this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
        }
        if ((isNotFinite & 0xe) == 0) {
            this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
        }
        if (isNotFinite) {
            // Try the other two triangles
            if ((isNotFinite & 0xd) == 0) {
                this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
            }
            if ((isNotFinite & 0x7) == 0) {
                this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
            }
        }
    };
    /**
     * Calculates extent of the `source` coordinates from all the triangles.
     *
     * @return {import("../extent.js").Extent} Calculated extent.
     */
    Triangulation.prototype.calculateSourceExtent = function () {
        var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* createEmpty */ "j"])();
        this.triangles_.forEach(function (triangle, i, arr) {
            var src = triangle.source;
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* extendCoordinate */ "q"])(extent, src[0]);
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* extendCoordinate */ "q"])(extent, src[1]);
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* extendCoordinate */ "q"])(extent, src[2]);
        });
        return extent;
    };
    /**
     * @return {Array<Triangle>} Array of the calculated triangles.
     */
    Triangulation.prototype.getTriangles = function () {
        return this.triangles_;
    };
    return Triangulation;
}());
/* harmony default export */ __webpack_exports__["a"] = (Triangulation);
//# sourceMappingURL=Triangulation.js.map

/***/ }),

/***/ "b7df":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return transformGeometryWithOptions; });
/* unused harmony export transformExtentWithOptions */
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fced");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("1300");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("38f3");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("256f");
/**
 * @module ol/format/Feature
 */




/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */
/**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */
var FeatureFormat = /** @class */ (function () {
    function FeatureFormat() {
        /**
         * @protected
         * @type {import("../proj/Projection.js").default|undefined}
         */
        this.dataProjection = undefined;
        /**
         * @protected
         * @type {import("../proj/Projection.js").default|undefined}
         */
        this.defaultFeatureProjection = undefined;
        /**
         * A list media types supported by the format in descending order of preference.
         * @type {Array<string>}
         */
        this.supportedMediaTypes = null;
    }
    /**
     * Adds the data projection to the read options.
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [opt_options] Options.
     * @return {ReadOptions|undefined} Options.
     * @protected
     */
    FeatureFormat.prototype.getReadOptions = function (source, opt_options) {
        var options;
        if (opt_options) {
            var dataProjection = opt_options.dataProjection
                ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* get */ "m"])(opt_options.dataProjection)
                : this.readProjection(source);
            if (opt_options.extent &&
                dataProjection &&
                dataProjection.getUnits() === _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].TILE_PIXELS) {
                dataProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* get */ "m"])(dataProjection);
                dataProjection.setWorldExtent(opt_options.extent);
            }
            options = {
                dataProjection: dataProjection,
                featureProjection: opt_options.featureProjection,
            };
        }
        return this.adaptOptions(options);
    };
    /**
     * Sets the `dataProjection` on the options, if no `dataProjection`
     * is set.
     * @param {WriteOptions|ReadOptions|undefined} options
     *     Options.
     * @protected
     * @return {WriteOptions|ReadOptions|undefined}
     *     Updated options.
     */
    FeatureFormat.prototype.adaptOptions = function (options) {
        return Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__[/* assign */ "a"])({
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection,
        }, options);
    };
    /**
     * @abstract
     * @return {import("./FormatType.js").default} Format.
     */
    FeatureFormat.prototype.getType = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    /**
     * Read a single feature from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [opt_options] Read options.
     * @return {import("../Feature.js").FeatureLike} Feature.
     */
    FeatureFormat.prototype.readFeature = function (source, opt_options) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    /**
     * Read all features from a source.
     *
     * @abstract
     * @param {Document|Element|ArrayBuffer|Object|string} source Source.
     * @param {ReadOptions} [opt_options] Read options.
     * @return {Array<import("../Feature.js").FeatureLike>} Features.
     */
    FeatureFormat.prototype.readFeatures = function (source, opt_options) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    /**
     * Read a single geometry from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [opt_options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    FeatureFormat.prototype.readGeometry = function (source, opt_options) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    /**
     * Read the projection from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     */
    FeatureFormat.prototype.readProjection = function (source) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    /**
     * Encode a feature in this format.
     *
     * @abstract
     * @param {import("../Feature.js").default} feature Feature.
     * @param {WriteOptions} [opt_options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    FeatureFormat.prototype.writeFeature = function (feature, opt_options) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    /**
     * Encode an array of features in this format.
     *
     * @abstract
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {WriteOptions} [opt_options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    FeatureFormat.prototype.writeFeatures = function (features, opt_options) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    /**
     * Write a single geometry in this format.
     *
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {WriteOptions} [opt_options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();
    };
    return FeatureFormat;
}());
/* harmony default export */ __webpack_exports__["a"] = (FeatureFormat);
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {WriteOptions|ReadOptions} [opt_options] Options.
 * @return {import("../geom/Geometry.js").default} Transformed geometry.
 */
function transformGeometryWithOptions(geometry, write, opt_options) {
    var featureProjection = opt_options
        ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* get */ "m"])(opt_options.featureProjection)
        : null;
    var dataProjection = opt_options
        ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* get */ "m"])(opt_options.dataProjection)
        : null;
    var transformed;
    if (featureProjection &&
        dataProjection &&
        !Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* equivalent */ "i"])(featureProjection, dataProjection)) {
        transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    }
    else {
        transformed = geometry;
    }
    if (write &&
        opt_options &&
        /** @type {WriteOptions} */ (opt_options).decimals !== undefined) {
        var power_1 = Math.pow(10, 
        /** @type {WriteOptions} */ (opt_options).decimals);
        // if decimals option on write, round each coordinate appropriately
        /**
         * @param {Array<number>} coordinates Coordinates.
         * @return {Array<number>} Transformed coordinates.
         */
        var transform = function (coordinates) {
            for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
            }
            return coordinates;
        };
        if (transformed === geometry) {
            transformed = geometry.clone();
        }
        transformed.applyTransform(transform);
    }
    return transformed;
}
/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions} [opt_options] Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */
function transformExtentWithOptions(extent, opt_options) {
    var featureProjection = opt_options
        ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* get */ "m"])(opt_options.featureProjection)
        : null;
    var dataProjection = opt_options
        ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* get */ "m"])(opt_options.dataProjection)
        : null;
    if (featureProjection &&
        dataProjection &&
        !Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* equivalent */ "i"])(featureProjection, dataProjection)) {
        return Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* transformExtent */ "v"])(extent, dataProjection, featureProjection);
    }
    else {
        return extent;
    }
}
//# sourceMappingURL=Feature.js.map

/***/ }),

/***/ "b811":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0621.5b831af1.png";

/***/ }),

/***/ "bae9":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAUxSURBVEhLzVd9aFtVFD+igoiiKCg4NgVFFJQxhP05VAbK1n03rl1EGUUYWuuczlWHVGQFdRv2a+vWJnnvJXlrm33UOoYO69oxnbpWOnAbzqmVtUnfR5M0TdP0Mz/PfbnVrpbSrlP8weXy7sf53XPuOeeeR/9/hHAzBWPLSO97nwLREKn2GVLMNtLs09zqKBjfwXNL5eobgJKW2ygQ38pCL5I+AKobBQWHQIEU9/wdFD1/i/FAAqTH27htlruvE76uZ0lPXKDDGZDaj/vqbWxs7UPZxRQ+vzqE5sgwjncNofxSCnk8fn99L8jPhwmNgQ71nSVP5xIpaQ5Qel6juiQLSmFBnYUKJosOjWMmxHi+ig+xkA/oWEFPDJI3kislzgLecBEdYdN5onCdisNMz0w4FTYfIL8lDvL18RWwBbxdsyD3mc9RQ9ohfeOHfinq+rCN9zvkemKYvOZiyTANDsbuYg+NkJqEq6VPbp8fNp1mzQOsiGqcZ0e9RTJNgdJTSkcyWFBvITGSkVvnh4HRDBaF+M6Fg2rGK5JpEpTOu0k1Y+SNo/aXQbkti/Hx8Tm3ydB+ZY01dlSl5/I/tVYMNzWM4gE+XXosq206nUYgEICiqtA0bdbN6/PhcCiETCYrZ3g8g4WHOdREHlAjyySjhGr4SR9BwbcJZ7FAMpnE/v37UevxwOP1/tV8fBBxmInmU5Rr5g/W1MDL/WTNt3zHjnaII0Xt2SUZJVSrQ5hDuZKWS/l+BgZQw0KEYEGgCo38flRXV6OqqgpV+/Y5/YEDB+CXlhFNkAvNJxMHfmNzB7kpxgnJyDgYvp0HwqTF0dozLJdOIWZBgvjd4mKsyVmJnOXPYNXyp50+d/06fFBSAk2ST0f8jTnCxHzPPqNDsjIqu+/lgRj542izR+TSa4n9wSDKysux0eXCutWrsGLTZqzYXIiVeS9jw5rVeDE/37GEIJ+OuL1XEIu4Ni5LVobHvpMHTKHxGWN64gAT796zBy+sWYX8omLkn4o6+Tn/ZAR5Ba9iU+56VFRWOiafjvisJTVWzJ8kKwO4iUPpkngIdL6LCSQlsTBfUNexZ+9e5OY8D9dbHzoJxnXSgKvZhmvLm8hbtxqVfN/igMKrpxKHOvl+A4Pijr+WrBKq2SgS++vf/50mU6kUKlmLiooKx4ylpaVwb1gL945dcLfG4P7KgLvZhLtwO17a6MInu3c7UVBWVoba2tpriLedY2114dVmuWSUUHqKxHP28NFeyDB24tAwDIS7uxEOhxGJRGCZJqxYHBY/HNbgWLZFY864mBfrunm9ZVlZIQwRzo82chzX8YulGGslo4QWXsR5eoQ8vTj6x5DccmMg3m5SOGcrhk0h8w7JOAmqqVPDGB4/ZoNT7A0BJy088RlrGxK52iyVTFNQe/URrp2GyRND0TyfxAm83cYhpHDTbJvl3yOZpoFibKVjANUY2HshJbdfHz7lqoVDlV8mdirF3CAZZoBqKNSYJd9+rn/OZhfmLW5jL/ZYcJTwhafk55ngt1WHnCuRp/iOjrODzAYnuPhb2sR3KiqPI1z0qcbHUuIc4LffoUOJIapnU3ltLOYDvNeeRBMfoiM6ip/7RnGee+G1O39MYklTlAmZtGGcX6L+GDvrPMpcn/Ek10z1FIiNCo93so/K2ihsRsXI9hrX06K8EfPB+ACvr6HqzoekhHlCtx9z/haCsS/4L+J3CjK5nzUUvWZf4bkmLvoLef5BueNfQDtuJc3aSV+yD2jWR87vzX8KxSpwHpg5g+hPqDGZXFCF/BkAAAAASUVORK5CYII="

/***/ }),

/***/ "bb21":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "bb6c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return inflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return inflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return inflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/inflate
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [opt_coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
    var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        coordinates[i++] = flatCoordinates.slice(j, j + stride);
    }
    coordinates.length = i;
    return coordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [opt_coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
    var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
    var i = 0;
    for (var j = 0, jj = ends.length; j < jj; ++j) {
        var end = ends[j];
        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
        offset = end;
    }
    coordinatess.length = i;
    return coordinatess;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [opt_coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
    var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
    var i = 0;
    for (var j = 0, jj = endss.length; j < jj; ++j) {
        var ends = endss[j];
        coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
        offset = ends[ends.length - 1];
    }
    coordinatesss.length = i;
    return coordinatesss;
}
//# sourceMappingURL=inflate.js.map

/***/ }),

/***/ "bb75":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track02.6ef15bbb.png";

/***/ }),

/***/ "bbec":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./highway/P0010.png": "0f01",
	"./highway/P0011.png": "e83d",
	"./highway/P0012.png": "ed8b",
	"./highway/P0013.png": "e46e",
	"./highway/P0014.png": "3c87",
	"./highway/P0015.png": "ce78",
	"./highway/P0016.png": "575a",
	"./highway/P0020.png": "8505",
	"./highway/P0021.png": "2144",
	"./highway/P0022.png": "d8e0",
	"./highway/P0023.png": "7d49",
	"./highway/P0024.png": "84aa",
	"./highway/P0025.png": "13ca",
	"./highway/P0026.png": "3c16",
	"./highway/P0027.png": "8220",
	"./highway/P0030.png": "a6ee",
	"./highway/P0031.png": "fde4",
	"./highway/P0032.png": "2240",
	"./highway/P0033.png": "c140",
	"./highway/P0040.png": "7c0d",
	"./highway/P0050.png": "06db",
	"./highway/P0051.png": "490c",
	"./highway/P0052.png": "a715",
	"./highway/P0060.png": "fb4f",
	"./highway/P0070.png": "69b7",
	"./highway/P0071.png": "1c32",
	"./highway/P0072.png": "ccc0",
	"./highway/P0073.png": "31ac",
	"./highway/P0074.png": "cace",
	"./highway/P0080.png": "bb21",
	"./highway/P0081.png": "183c",
	"./highway/P0090.png": "1159",
	"./highway/P0091.png": "8fc6",
	"./highway/P0092.png": "33de",
	"./highway/P0093.png": "01f7",
	"./highway/P0094.png": "96dc",
	"./highway/P0095.png": "0aae",
	"./highway/P0100.png": "ed88",
	"./highway/P0102.png": "528b",
	"./highway/P0110.png": "573a",
	"./highway/P0111.png": "9ffa",
	"./highway/P0112.png": "465d",
	"./highway/P0113.png": "b142",
	"./highway/P0120.png": "f721",
	"./highway/P0130.png": "c7cc",
	"./highway/P0131.png": "44a9",
	"./highway/P0140.png": "06a0",
	"./highway/P0141.png": "cc88",
	"./highway/P0142.png": "392c",
	"./highway/P0143.png": "6b08",
	"./highway/P0144.png": "702a",
	"./highway/P0150.png": "75e1",
	"./highway/P0151.png": "182f",
	"./highway/P0160.png": "a7dd",
	"./highway/P0170.png": "c4e1",
	"./highway/P0171.png": "2ea2",
	"./highway/P0172.png": "3419",
	"./highway/P0180.png": "97c6",
	"./highway/P0190.png": "0b9c",
	"./highway/P0191.png": "b4de",
	"./highway/P0200.png": "c19a",
	"./highway/P0201.png": "a37a",
	"./highway/P0202.png": "7d09",
	"./highway/P0210.png": "aabb",
	"./highway/P0211.png": "42f5",
	"./highway/P0220.png": "ce0f",
	"./highway/P0230.png": "db05",
	"./highway/P0240.png": "f534",
	"./highway/P0250.png": "f6f4",
	"./highway/P0260.png": "1d61",
	"./highway/P0270.png": "ec50",
	"./highway/P0271.png": "5b3d",
	"./highway/P0280.png": "4aea",
	"./highway/P0290.png": "843f",
	"./highway/P0300.png": "76c7",
	"./highway/P0310.png": "2909",
	"./highway/P0370.png": "1238",
	"./highway/P0390.png": "d9aa",
	"./highway/P0610.png": "e25d",
	"./highway/P0611.png": "b52d",
	"./highway/P0612.png": "bf3d",
	"./highway/P0620.png": "c26f",
	"./highway/P0621.png": "b811",
	"./highway/P0630.png": "091f",
	"./highway/P0631.png": "9c6a",
	"./highway/P0640.png": "d4b4",
	"./highway/P0650.png": "2815",
	"./highway/P0660.png": "2ede",
	"./highway/P0680.png": "01db",
	"./highway/P0681.png": "bc52",
	"./highway/P0720.png": "33a7",
	"./highway/P0740.png": "30e6",
	"./highway/P0741.png": "29e8",
	"./highway/P0760.png": "1287",
	"./highway/P0780.png": "afd9",
	"./highway/P0820.png": "9670",
	"./highway/P0840.png": "4dae",
	"./highway/P0860.png": "a4c4",
	"./highway/P0880.png": "7371",
	"./pin_01.png": "2efd",
	"./point-03-5.png": "bae9",
	"./point-04-1.png": "3b0c",
	"./point-04-1_1.png": "271d",
	"./point-04-1_2.png": "13b4",
	"./point-04-1_3.png": "83c0",
	"./point-04-1_4.png": "238b",
	"./point-04-2.png": "2b41",
	"./point-04-2_1.png": "399a",
	"./point-04-2_2.png": "fb20",
	"./point-04-2_3.png": "2846",
	"./point-04-3.png": "17f2",
	"./point-04-4.png": "1b14",
	"./point-05-1.png": "734f",
	"./point5_1.png": "eef5",
	"./point5_2.png": "766c",
	"./point5_3.png": "a305",
	"./point5_4.png": "a808",
	"./point5_5.png": "4e9e",
	"./point5_6.png": "5a95",
	"./point5_7.png": "4763",
	"./point5_8_1.png": "de0f",
	"./point5_8_2.png": "eeb0",
	"./point5_8_3.png": "1b84",
	"./point6_alert1.png": "c158",
	"./point6_alert2.png": "74f8",
	"./point_7_1.png": "02de",
	"./point_7_2.png": "c692",
	"./point_7_3.png": "c866",
	"./point_7_4.png": "936b",
	"./point_8_1.png": "b358",
	"./point_8_2.png": "48d6",
	"./point_8_3.png": "40db",
	"./point_8_4.png": "b401",
	"./point_8_5.png": "8322",
	"./rain_normal.png": "be8e",
	"./raw_normal.png": "b6eb",
	"./typhoon-position.png": "57b3",
	"./typhoon.png": "f75d",
	"./typhoon_track01.png": "b052",
	"./typhoon_track02.png": "bb75",
	"./typhoon_track03.png": "a264",
	"./typhoon_track04.png": "ff18",
	"./typhoon_track05.png": "6cdc",
	"./typhoon_track06.png": "3771",
	"./typhoon_track07.png": "4218",
	"./typhoon_track08.png": "7340",
	"./typhoon_track09.png": "e575",
	"./typhoon_track10.png": "5c85"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "bbec";

/***/ }),

/***/ "bc52":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "be8e":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "bef8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return transform2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return translate; });
/**
 * @module ol/geom/flat/transform
 */
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        var x = flatCoordinates[j];
        var y = flatCoordinates[j + 1];
        dest[i++] = transform[0] * x + transform[2] * y + transform[4];
        dest[i++] = transform[1] * x + transform[3] * y + transform[5];
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + deltaX * cos - deltaY * sin;
        dest[i++] = anchorY + deltaX * sin + deltaY * cos;
        for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
        }
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + sx * deltaX;
        dest[i++] = anchorY + sy * deltaY;
        for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
        }
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var i = 0;
    for (var j = offset; j < end; j += stride) {
        dest[i++] = flatCoordinates[j] + deltaX;
        dest[i++] = flatCoordinates[j + 1] + deltaY;
        for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
        }
    }
    if (opt_dest && dest.length != i) {
        dest.length = i;
    }
    return dest;
}
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "bf3d":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0612.dfd63da2.png";

/***/ }),

/***/ "bf62":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/interaction/Property
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    ACTIVE: 'active',
});
//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "c04e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var isObject = __webpack_require__("861d");
var isSymbol = __webpack_require__("d9b5");
var getMethod = __webpack_require__("dc4a");
var ordinaryToPrimitive = __webpack_require__("485a");
var wellKnownSymbol = __webpack_require__("b622");

var TypeError = global.TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "c140":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "c158":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAatJREFUeNq8l71OwzAQxy/lQzAgUtiY2p0hnRlIVgYUNrakbwATI+3IlEegEQ9A6QuER8gbNBNjCWJH3FUOSlLHdbCdv2RZsiz/fB++XCxoqQ84cXCya8v5GazSNudYkjAXpwCHz4H+wXHMccR4iXclMLMuwuG2dAyB70VesATQEKdnUNMY4TNpMEIJGIIezRA+ri/2ONA7jVBSyM5stpglUQJm5JWTrm5xBOYUcV3NkskxCHYYY8PiAMwrqMQYb0JF4RO6UR9jnRcWa3Hxvnsh5fKyq11V6J5zDqfJAvqvL9Czj0Vb16xd0Y6jyYM0+DC4Xc8H/hXsDBaw8q7hJ/9q3C8Ef0+epMFt9nIrV1cqwFmHzKwMTjsEp5VajW95idPAtLX4hof1GMcdWBtvfJ1Y9VoKWhtVUWs0pKpVsZgtTA1aOy2g3A4ELU90VLJ6D4ZQb9s7vtGc5Sk7U6rnslkn4miAemUXCysXbcQxUow5xXTEg0o19Gg9ve3HLc18vaknaKb8J1G6hM/cf1lKQHLnG80Im2v9hWm4RMI84DW504goAVkY/qVfAQYARydvYCPFh48AAAAASUVORK5CYII="

/***/ }),

/***/ "c15b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return add; });
/* unused harmony export remove */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return get; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("38f3");
/**
 * @module ol/proj/transforms
 */

/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};
/**
 * Clear the transform cache.
 */
function clear() {
    transforms = {};
}
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
    var sourceCode = source.getCode();
    var destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) {
        transforms[sourceCode] = {};
    }
    transforms[sourceCode][destinationCode] = transformFn;
}
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
    var sourceCode = source.getCode();
    var destinationCode = destination.getCode();
    var transform = transforms[sourceCode][destinationCode];
    delete transforms[sourceCode][destinationCode];
    if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__[/* isEmpty */ "d"])(transforms[sourceCode])) {
        delete transforms[sourceCode];
    }
    return transform;
}
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
    var transform;
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
        transform = transforms[sourceCode][destinationCode];
    }
    return transform;
}
//# sourceMappingURL=transforms.js.map

/***/ }),

/***/ "c19a":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "c26f":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "c320":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("3900");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("e637");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("cd7e");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("1e8d");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("0999");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/control/FullScreen
 */






var events = [
    'fullscreenchange',
    'webkitfullscreenchange',
    'MSFullscreenChange',
];
/**
 * @enum {string}
 */
var FullScreenEventType = {
    /**
     * Triggered after the map entered fullscreen.
     * @event FullScreenEventType#enterfullscreen
     * @api
     */
    ENTERFULLSCREEN: 'enterfullscreen',
    /**
     * Triggered after the map leave fullscreen.
     * @event FullScreenEventType#leavefullscreen
     * @api
     */
    LEAVEFULLSCREEN: 'leavefullscreen',
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen', import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen'|import("../ObjectEventType").Types, Return>} FullScreenOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-full-screen'] CSS class name.
 * @property {string|Text|HTMLElement} [label='\u2922'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|Text|HTMLElement} [labelActive='\u00d7'] Text label to use for the
 * button when full-screen is active.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [activeClassName=className + '-true'] CSS class name for the button
 * when full-screen is active.
 * @property {string} [inactiveClassName=className + '-false'] CSS class name for the button
 * when full-screen is inactive.
 * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.
 * @property {boolean} [keys=false] Full keyboard access.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {HTMLElement|string} [source] The element to be displayed
 * fullscreen. When not provided, the element containing the map viewport will
 * be displayed fullscreen.
 */
/**
 * @classdesc
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overridden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 *
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](https://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 *
 * @fires FullScreenEventType#enterfullscreen
 * @fires FullScreenEventType#leavefullscreen
 * @api
 */
var FullScreen = /** @class */ (function (_super) {
    __extends(FullScreen, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function FullScreen(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {};
        _this = _super.call(this, {
            element: document.createElement('div'),
            target: options.target,
        }) || this;
        /***
         * @type {FullScreenOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {FullScreenOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {FullScreenOnSignature<void>}
         */
        _this.un;
        /**
         * @private
         * @type {string}
         */
        _this.cssClassName_ =
            options.className !== undefined ? options.className : 'ol-full-screen';
        /**
         * @private
         * @type {Array<import("../events.js").EventsKey>}
         */
        _this.documentListeners_ = [];
        /**
         * @private
         * @type {Array<string>}
         */
        _this.activeClassName_ =
            options.activeClassName !== undefined
                ? options.activeClassName.split(' ')
                : [_this.cssClassName_ + '-true'];
        /**
         * @private
         * @type {Array<string>}
         */
        _this.inactiveClassName_ =
            options.inactiveClassName !== undefined
                ? options.inactiveClassName.split(' ')
                : [_this.cssClassName_ + '-false'];
        var label = options.label !== undefined ? options.label : '\u2922';
        /**
         * @private
         * @type {Text|HTMLElement}
         */
        _this.labelNode_ =
            typeof label === 'string' ? document.createTextNode(label) : label;
        var labelActive = options.labelActive !== undefined ? options.labelActive : '\u00d7';
        /**
         * @private
         * @type {Text|HTMLElement}
         */
        _this.labelActiveNode_ =
            typeof labelActive === 'string'
                ? document.createTextNode(labelActive)
                : labelActive;
        /**
         * @private
         * @type {HTMLElement}
         */
        _this.button_ = document.createElement('button');
        var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';
        _this.button_.setAttribute('type', 'button');
        _this.button_.title = tipLabel;
        _this.button_.appendChild(_this.labelNode_);
        _this.button_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CLICK, _this.handleClick_.bind(_this), false);
        _this.element.className = "".concat(_this.cssClassName_, " ").concat(_css_js__WEBPACK_IMPORTED_MODULE_3__[/* CLASS_UNSELECTABLE */ "e"], " ").concat(_css_js__WEBPACK_IMPORTED_MODULE_3__[/* CLASS_CONTROL */ "b"]);
        _this.element.appendChild(_this.button_);
        /**
         * @private
         * @type {boolean}
         */
        _this.keys_ = options.keys !== undefined ? options.keys : false;
        /**
         * @private
         * @type {HTMLElement|string|undefined}
         */
        _this.source_ = options.source;
        /**
         * @type {boolean}
         * @private
         */
        _this.isInFullscreen_ = false;
        /**
         * @private
         */
        _this.boundHandleMapTargetChange_ = _this.handleMapTargetChange_.bind(_this);
        return _this;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    FullScreen.prototype.handleClick_ = function (event) {
        event.preventDefault();
        this.handleFullScreen_();
    };
    /**
     * @private
     */
    FullScreen.prototype.handleFullScreen_ = function () {
        var map = this.getMap();
        if (!map) {
            return;
        }
        var doc = map.getOwnerDocument();
        if (!isFullScreenSupported(doc)) {
            return;
        }
        if (isFullScreen(doc)) {
            exitFullScreen(doc);
        }
        else {
            var element = void 0;
            if (this.source_) {
                element =
                    typeof this.source_ === 'string'
                        ? doc.getElementById(this.source_)
                        : this.source_;
            }
            else {
                element = map.getTargetElement();
            }
            if (this.keys_) {
                requestFullScreenWithKeys(element);
            }
            else {
                requestFullScreen(element);
            }
        }
    };
    /**
     * @private
     */
    FullScreen.prototype.handleFullScreenChange_ = function () {
        var map = this.getMap();
        if (!map) {
            return;
        }
        var wasInFullscreen = this.isInFullscreen_;
        this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
        if (wasInFullscreen !== this.isInFullscreen_) {
            this.setClassName_(this.button_, this.isInFullscreen_);
            if (this.isInFullscreen_) {
                Object(_dom_js__WEBPACK_IMPORTED_MODULE_5__[/* replaceNode */ "g"])(this.labelActiveNode_, this.labelNode_);
                this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
            }
            else {
                Object(_dom_js__WEBPACK_IMPORTED_MODULE_5__[/* replaceNode */ "g"])(this.labelNode_, this.labelActiveNode_);
                this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
            }
            map.updateSize();
        }
    };
    /**
     * @param {HTMLElement} element Target element
     * @param {boolean} fullscreen True if fullscreen class name should be active
     * @private
     */
    FullScreen.prototype.setClassName_ = function (element, fullscreen) {
        var _a, _b, _c;
        var activeClassName = this.activeClassName_;
        var inactiveClassName = this.inactiveClassName_;
        var nextClassName = fullscreen ? activeClassName : inactiveClassName;
        (_a = element.classList).remove.apply(_a, activeClassName);
        (_b = element.classList).remove.apply(_b, inactiveClassName);
        (_c = element.classList).add.apply(_c, nextClassName);
    };
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default|null} map Map.
     * @api
     */
    FullScreen.prototype.setMap = function (map) {
        var oldMap = this.getMap();
        if (oldMap) {
            oldMap.removeChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].TARGET, this.boundHandleMapTargetChange_);
        }
        _super.prototype.setMap.call(this, map);
        this.handleMapTargetChange_();
        if (map) {
            map.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].TARGET, this.boundHandleMapTargetChange_);
        }
    };
    /**
     * @private
     */
    FullScreen.prototype.handleMapTargetChange_ = function () {
        var listeners = this.documentListeners_;
        for (var i = 0, ii = listeners.length; i < ii; ++i) {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_4__[/* unlistenByKey */ "c"])(listeners[i]);
        }
        listeners.length = 0;
        var map = this.getMap();
        if (map) {
            var doc = map.getOwnerDocument();
            if (isFullScreenSupported(doc)) {
                this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_3__[/* CLASS_UNSUPPORTED */ "f"]);
            }
            else {
                this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_3__[/* CLASS_UNSUPPORTED */ "f"]);
            }
            for (var i = 0, ii = events.length; i < ii; ++i) {
                listeners.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_4__[/* listen */ "a"])(doc, events[i], this.handleFullScreenChange_, this));
            }
            this.handleFullScreenChange_();
        }
    };
    return FullScreen;
}(_Control_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * @param {Document} doc The root document to check.
 * @return {boolean} Fullscreen is supported by the current platform.
 */
function isFullScreenSupported(doc) {
    var body = doc.body;
    return !!(body['webkitRequestFullscreen'] ||
        (body['msRequestFullscreen'] && doc['msFullscreenEnabled']) ||
        (body.requestFullscreen && doc.fullscreenEnabled));
}
/**
 * @param {Document} doc The root document to check.
 * @return {boolean} Element is currently in fullscreen.
 */
function isFullScreen(doc) {
    return !!(doc['webkitIsFullScreen'] ||
        doc['msFullscreenElement'] ||
        doc.fullscreenElement);
}
/**
 * Request to fullscreen an element.
 * @param {HTMLElement} element Element to request fullscreen
 */
function requestFullScreen(element) {
    if (element.requestFullscreen) {
        element.requestFullscreen();
    }
    else if (element['msRequestFullscreen']) {
        element['msRequestFullscreen']();
    }
    else if (element['webkitRequestFullscreen']) {
        element['webkitRequestFullscreen']();
    }
}
/**
 * Request to fullscreen an element with keyboard input.
 * @param {HTMLElement} element Element to request fullscreen
 */
function requestFullScreenWithKeys(element) {
    if (element['webkitRequestFullscreen']) {
        element['webkitRequestFullscreen']();
    }
    else {
        requestFullScreen(element);
    }
}
/**
 * Exit fullscreen.
 * @param {Document} doc The document to exit fullscren from
 */
function exitFullScreen(doc) {
    if (doc.exitFullscreen) {
        doc.exitFullscreen();
    }
    else if (doc['msExitFullscreen']) {
        doc['msExitFullscreen']();
    }
    else if (doc['webkitExitFullscreen']) {
        doc['webkitExitFullscreen']();
    }
}
/* harmony default export */ __webpack_exports__["a"] = (FullScreen);
//# sourceMappingURL=FullScreen.js.map

/***/ }),

/***/ "c430":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "c4e1":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "c560":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return intersectsLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return intersectsLineStringArray; });
/* unused harmony export intersectsLinearRing */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return intersectsLinearRingArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return intersectsLinearRingMultiArray; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0af5");
/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fd4d");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("25f1");
/**
 * @module ol/geom/flat/intersectsextent
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
    var coordinatesExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* extendFlatCoordinates */ "r"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* createEmpty */ "j"])(), flatCoordinates, offset, end, stride);
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* intersects */ "E"])(extent, coordinatesExtent)) {
        return false;
    }
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* containsExtent */ "g"])(extent, coordinatesExtent)) {
        return true;
    }
    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
        return true;
    }
    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
        return true;
    }
    return Object(_segments_js__WEBPACK_IMPORTED_MODULE_1__[/* forEach */ "a"])(flatCoordinates, offset, end, stride, 
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function (point1, point2) {
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__[/* intersectsSegment */ "F"])(extent, point1, point2);
    });
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
            return true;
        }
        offset = ends[i];
    }
    return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
        return true;
    }
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_2__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
        return true;
    }
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_2__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
        return true;
    }
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_2__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
        return true;
    }
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_2__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
        return true;
    }
    return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
        return false;
    }
    if (ends.length === 1) {
        return true;
    }
    for (var i = 1, ii = ends.length; i < ii; ++i) {
        if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_2__[/* linearRingContainsExtent */ "a"])(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
            if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                return false;
            }
        }
    }
    return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
            return true;
        }
        offset = ends[ends.length - 1];
    }
    return false;
}
//# sourceMappingURL=intersectsextent.js.map

/***/ }),

/***/ "c65b":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__("40d5");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "c692":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAMgSURBVEhLtZdNa1NBFIZfix+1bdI7k2JtqxV3KhbBjSIoiriSoi5cuFFRitWl4k/oDxA3gv/AheBCQXHjpiBGKbRQET+a3Hz09iM11jZNGju+J5mLLU1tGu498HJJmDnPzJmZc2awVTPoapmCc2YK+nYG6r4HfXMG+qQBttsmwVkWnXumEbs3Df3Kg0ploZcy0Cv8mupXFTiACbZ5noO+8Q2q3XZtzOJ0QGdDnNFMCR1mATEzS00SKFBfhFb+X6SKlTbKnYZ6+AzYaV3VbwnoCxz91zKBs3Scpji7ujRHuO33aQIdx63LzS0FNfiTnX9RWwGulvSTCMxBLyShr1jXG5sLdWeJHRjehqG+pL/MXiaRgNNvEevNRexsPiCoLx/OsC/w92GL+mfcRBFumuQ8GwUF9SX+CvTLJYzz2DVZZNX459Afboigoau1XJmUGrBI4DPaOpgM8rJ7a3UISrKMKejvY/4xy8C5WwohxLUkOz0L56IFq9eSHGo1DFqSYPh9ihF0tjLu2WqSaAlZrZVwE/wRaTinOeOi18RU2H3EePv7jLfvaPCi38m9hwzzPQeg0gSrgTTajBc9YMpJ16wsFqjFEFQwpfgI87oiODon6/sgI2DnoFkpFEyYVv6R9MF5nl99K42I8SK9pjQyaspuOjQV376rgDOI5lhr9QnOeklKW7a522R391DyDVgt9NvcZdOxcvEF2EWwyxIoIaAiISpqK556b8+xfiEH2z9rYUkSlCQqpufHPvi6PdihSm4rUoRctJ+rgMdZmTgaT8pXrQ5BSaDczKNrKpQcK7muhJmvJaoEX7XIqknFIHRM1jpo+Kq1fWNxa82Fc4y7uyAhDwoufiTEPEYe7149FrXekohdljtSEHAfysn8dnnpt4iNLYHYJd4O5+W6UsthvZLwEpqZgDplXW9uSTh9DM/wMjecLWV1yT8yclMl9CVfFb3W5ZZsG18Eg6zV4/4rQQYhpU1SrLwo5CtpUDJSkYMUKNvHp6CuWR+NWxzYkUOsn4AnBH3gWynF2eWY+vKc4SwHkOAjbpg31UfcG+dtt/8Y8BeHVQDsX2qcEAAAAABJRU5ErkJggg=="

/***/ }),

/***/ "c6b6":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "c6cd":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var setGlobal = __webpack_require__("ce4e");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "c7cc":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "c807":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ModifyEvent */
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e300");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("183a");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("cef7");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("01d4");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("4cdf");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("f623");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("0b2d");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("f403");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("4105");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("4a7d");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("a43f");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("3e6b");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("5831");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("06f8");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("0af5");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("a568");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("6c77");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("9f5e");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("5bc3");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("256f");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("1300");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/interaction/Modify
 */





















/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CIRCUMFERENCE_INDEX = 1;
var tempExtent = [0, 0, 0, 0];
var tempSegment = [];
/**
 * @enum {string}
 */
var ModifyEventType = {
    /**
     * Triggered upon feature modification start
     * @event ModifyEvent#modifystart
     * @api
     */
    MODIFYSTART: 'modifystart',
    /**
     * Triggered upon feature modification end
     * @event ModifyEvent#modifyend
     * @api
     */
    MODIFYEND: 'modifyend',
};
/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {import("../Feature").FeatureLike} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition.singleClick} with
 * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */
var ModifyEvent = /** @class */ (function (_super) {
    __extends(ModifyEvent, _super);
    /**
     * @param {ModifyEventType} type Type.
     * @param {Collection<import("../Feature").FeatureLike>} features
     * The features modified.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     */
    function ModifyEvent(type, features, mapBrowserEvent) {
        var _this = _super.call(this, type) || this;
        /**
         * The features being modified.
         * @type {Collection<import("../Feature").FeatureLike>}
         * @api
         */
        _this.features = features;
        /**
         * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
         * @type {import("../MapBrowserEvent.js").default}
         * @api
         */
        _this.mapBrowserEvent = mapBrowserEvent;
        return _this;
    }
    return ModifyEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]));

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */
/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
var Modify = /** @class */ (function (_super) {
    __extends(Modify, _super);
    /**
     * @param {Options} options Options.
     */
    function Modify(options) {
        var _this = _super.call(this, /** @type {import("./Pointer.js").Options} */ (options)) || this;
        /***
         * @type {ModifyOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {ModifyOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {ModifyOnSignature<void>}
         */
        _this.un;
        /** @private */
        _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */
        _this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_13__[/* primaryAction */ "i"];
        /**
         * @private
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
         * @return {boolean} Combined condition result.
         */
        _this.defaultDeleteCondition_ = function (mapBrowserEvent) {
            return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_13__[/* altKeyOnly */ "b"])(mapBrowserEvent) && Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_13__[/* singleClick */ "k"])(mapBrowserEvent);
        };
        /**
         * @type {import("../events/condition.js").Condition}
         * @private
         */
        _this.deleteCondition_ = options.deleteCondition
            ? options.deleteCondition
            : _this.defaultDeleteCondition_;
        /**
         * @type {import("../events/condition.js").Condition}
         * @private
         */
        _this.insertVertexCondition_ = options.insertVertexCondition
            ? options.insertVertexCondition
            : _events_condition_js__WEBPACK_IMPORTED_MODULE_13__[/* always */ "d"];
        /**
         * Editing vertex.
         * @type {Feature<Point>}
         * @private
         */
        _this.vertexFeature_ = null;
        /**
         * Segments intersecting {@link this.vertexFeature_} by segment uid.
         * @type {Object<string, boolean>}
         * @private
         */
        _this.vertexSegments_ = null;
        /**
         * @type {import("../pixel.js").Pixel}
         * @private
         */
        _this.lastPixel_ = [0, 0];
        /**
         * Tracks if the next `singleclick` event should be ignored to prevent
         * accidental deletion right after vertex creation.
         * @type {boolean}
         * @private
         */
        _this.ignoreNextSingleClick_ = false;
        /**
         * @type {Collection<import("../Feature").FeatureLike>}
         * @private
         */
        _this.featuresBeingModified_ = null;
        /**
         * Segment RTree for each layer
         * @type {RBush<SegmentData>}
         * @private
         */
        _this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"]();
        /**
         * @type {number}
         * @private
         */
        _this.pixelTolerance_ =
            options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
         * @type {boolean}
         * @private
         */
        _this.snappedToVertex_ = false;
        /**
         * Indicate whether the interaction is currently changing a feature's
         * coordinates.
         * @type {boolean}
         * @private
         */
        _this.changingFeature_ = false;
        /**
         * @type {Array}
         * @private
         */
        _this.dragSegments_ = [];
        /**
         * Draw overlay where sketch features are drawn.
         * @type {VectorLayer}
         * @private
         */
        _this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"]({
            source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]({
                useSpatialIndex: false,
                wrapX: !!options.wrapX,
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileAnimating: true,
            updateWhileInteracting: true,
        });
        /**
         * @const
         * @private
         * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
         */
        _this.SEGMENT_WRITERS_ = {
            'Point': _this.writePointGeometry_.bind(_this),
            'LineString': _this.writeLineStringGeometry_.bind(_this),
            'LinearRing': _this.writeLineStringGeometry_.bind(_this),
            'Polygon': _this.writePolygonGeometry_.bind(_this),
            'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
            'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
            'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
            'Circle': _this.writeCircleGeometry_.bind(_this),
            'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),
        };
        /**
         * @type {VectorSource}
         * @private
         */
        _this.source_ = null;
        /**
         * @type {boolean|import("../layer/BaseVector").default}
         */
        _this.hitDetection_ = null;
        var features;
        if (options.features) {
            features = options.features;
        }
        else if (options.source) {
            _this.source_ = options.source;
            features = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](_this.source_.getFeatures());
            _this.source_.addEventListener(_source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"].ADDFEATURE, _this.handleSourceAdd_.bind(_this));
            _this.source_.addEventListener(_source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"].REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
        }
        if (!features) {
            throw new Error('The modify interaction requires features, a source or a layer');
        }
        if (options.hitDetection) {
            _this.hitDetection_ = options.hitDetection;
        }
        /**
         * @type {Collection<import("../Feature.js").FeatureLike>}
         * @private
         */
        _this.features_ = features;
        _this.features_.forEach(_this.addFeature_.bind(_this));
        _this.features_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ADD, _this.handleFeatureAdd_.bind(_this));
        _this.features_.addEventListener(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REMOVE, _this.handleFeatureRemove_.bind(_this));
        /**
         * @type {import("../MapBrowserEvent.js").default}
         * @private
         */
        _this.lastPointerEvent_ = null;
        /**
         * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
         * @type {Array<number>}
         */
        _this.delta_ = [0, 0];
        /**
         * @private
         */
        _this.snapToPointer_ =
            options.snapToPointer === undefined
                ? !_this.hitDetection_
                : options.snapToPointer;
        return _this;
    }
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    Modify.prototype.addFeature_ = function (feature) {
        var geometry = feature.getGeometry();
        if (geometry) {
            var writer = this.SEGMENT_WRITERS_[geometry.getType()];
            if (writer) {
                writer(feature, geometry);
            }
        }
        var map = this.getMap();
        if (map && map.isRendered() && this.getActive()) {
            this.handlePointerAtPixel_(this.lastPixel_, map);
        }
        feature.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].CHANGE, this.boundHandleFeatureChange_);
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
     * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
     * @private
     */
    Modify.prototype.willModifyFeatures_ = function (evt, segments) {
        if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();
            var features = this.featuresBeingModified_.getArray();
            for (var i = 0, ii = segments.length; i < ii; ++i) {
                var segment = segments[i];
                for (var s = 0, ss = segment.length; s < ss; ++s) {
                    var feature = segment[s].feature;
                    if (feature && features.indexOf(feature) === -1) {
                        this.featuresBeingModified_.push(feature);
                    }
                }
            }
            if (this.featuresBeingModified_.getLength() === 0) {
                this.featuresBeingModified_ = null;
            }
            else {
                this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
            }
        }
    };
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    Modify.prototype.removeFeature_ = function (feature) {
        this.removeFeatureSegmentData_(feature);
        // Remove the vertex feature if the collection of candidate features is empty.
        if (this.vertexFeature_ && this.features_.getLength() === 0) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        feature.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].CHANGE, this.boundHandleFeatureChange_);
    };
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    Modify.prototype.removeFeatureSegmentData_ = function (feature) {
        var rBush = this.rBush_;
        /** @type {Array<SegmentData>} */
        var nodesToRemove = [];
        rBush.forEach(
        /**
         * @param {SegmentData} node RTree node.
         */
        function (node) {
            if (feature === node.feature) {
                nodesToRemove.push(node);
            }
        });
        for (var i = nodesToRemove.length - 1; i >= 0; --i) {
            var nodeToRemove = nodesToRemove[i];
            for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
                if (this.dragSegments_[j][0] === nodeToRemove) {
                    this.dragSegments_.splice(j, 1);
                }
            }
            rBush.remove(nodeToRemove);
        }
    };
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
    Modify.prototype.setActive = function (active) {
        if (this.vertexFeature_ && !active) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        _super.prototype.setActive.call(this, active);
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */
    Modify.prototype.setMap = function (map) {
        this.overlay_.setMap(map);
        _super.prototype.setMap.call(this, map);
    };
    /**
     * Get the overlay layer that this interaction renders the modification point or vertex to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */
    Modify.prototype.getOverlay = function () {
        return this.overlay_;
    };
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    Modify.prototype.handleSourceAdd_ = function (event) {
        if (event.feature) {
            this.features_.push(event.feature);
        }
    };
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    Modify.prototype.handleSourceRemove_ = function (event) {
        if (event.feature) {
            this.features_.remove(event.feature);
        }
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */
    Modify.prototype.handleFeatureAdd_ = function (evt) {
        this.addFeature_(/** @type {Feature} */ (evt.element));
    };
    /**
     * @param {import("../events/Event.js").default} evt Event.
     * @private
     */
    Modify.prototype.handleFeatureChange_ = function (evt) {
        if (!this.changingFeature_) {
            var feature = /** @type {Feature} */ (evt.target);
            this.removeFeature_(feature);
            this.addFeature_(feature);
        }
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */
    Modify.prototype.handleFeatureRemove_ = function (evt) {
        var feature = /** @type {Feature} */ (evt.element);
        this.removeFeature_(feature);
    };
    /**
     * @param {Feature} feature Feature
     * @param {Point} geometry Geometry.
     * @private
     */
    Modify.prototype.writePointGeometry_ = function (feature, geometry) {
        var coordinates = geometry.getCoordinates();
        /** @type {SegmentData} */
        var segmentData = {
            feature: feature,
            geometry: geometry,
            segment: [coordinates, coordinates],
        };
        this.rBush_.insert(geometry.getExtent(), segmentData);
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
     * @private
     */
    Modify.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
        var points = geometry.getCoordinates();
        for (var i = 0, ii = points.length; i < ii; ++i) {
            var coordinates = points[i];
            /** @type {SegmentData} */
            var segmentData = {
                feature: feature,
                geometry: geometry,
                depth: [i],
                index: i,
                segment: [coordinates, coordinates],
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/LineString.js").default} geometry Geometry.
     * @private
     */
    Modify.prototype.writeLineStringGeometry_ = function (feature, geometry) {
        var coordinates = geometry.getCoordinates();
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
            var segment = coordinates.slice(i, i + 2);
            /** @type {SegmentData} */
            var segmentData = {
                feature: feature,
                geometry: geometry,
                index: i,
                segment: segment,
            };
            this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(segment), segmentData);
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
     * @private
     */
    Modify.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
        var lines = geometry.getCoordinates();
        for (var j = 0, jj = lines.length; j < jj; ++j) {
            var coordinates = lines[j];
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                var segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */
                var segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [j],
                    index: i,
                    segment: segment,
                };
                this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(segment), segmentData);
            }
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/Polygon.js").default} geometry Geometry.
     * @private
     */
    Modify.prototype.writePolygonGeometry_ = function (feature, geometry) {
        var rings = geometry.getCoordinates();
        for (var j = 0, jj = rings.length; j < jj; ++j) {
            var coordinates = rings[j];
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                var segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */
                var segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [j],
                    index: i,
                    segment: segment,
                };
                this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(segment), segmentData);
            }
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @private
     */
    Modify.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
        var polygons = geometry.getCoordinates();
        for (var k = 0, kk = polygons.length; k < kk; ++k) {
            var rings = polygons[k];
            for (var j = 0, jj = rings.length; j < jj; ++j) {
                var coordinates = rings[j];
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var segment = coordinates.slice(i, i + 2);
                    /** @type {SegmentData} */
                    var segmentData = {
                        feature: feature,
                        geometry: geometry,
                        depth: [j, k],
                        index: i,
                        segment: segment,
                    };
                    this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(segment), segmentData);
                }
            }
        }
    };
    /**
     * We convert a circle into two segments.  The segment at index
     * {@link CIRCLE_CENTER_INDEX} is the
     * circle's center (a point).  The segment at index
     * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
     * the circumference, and is not a line segment.
     *
     * @param {Feature} feature Feature.
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @private
     */
    Modify.prototype.writeCircleGeometry_ = function (feature, geometry) {
        var coordinates = geometry.getCenter();
        /** @type {SegmentData} */
        var centerSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CENTER_INDEX,
            segment: [coordinates, coordinates],
        };
        /** @type {SegmentData} */
        var circumferenceSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CIRCUMFERENCE_INDEX,
            segment: [coordinates, coordinates],
        };
        var featureSegments = [centerSegmentData, circumferenceSegmentData];
        centerSegmentData.featureSegments = featureSegments;
        circumferenceSegmentData.featureSegments = featureSegments;
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* createOrUpdateFromCoordinate */ "m"])(coordinates), centerSegmentData);
        var circleGeometry = /** @type {import("../geom/Geometry.js").default} */ (geometry);
        var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* getUserProjection */ "q"])();
        if (userProjection && this.getMap()) {
            var projection = this.getMap().getView().getProjection();
            circleGeometry = circleGeometry
                .clone()
                .transform(userProjection, projection);
            circleGeometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_18__[/* fromCircle */ "b"])(
            /** @type {import("../geom/Circle.js").default} */ (circleGeometry)).transform(projection, userProjection);
        }
        this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @private
     */
    Modify.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
        var geometries = geometry.getGeometriesArray();
        for (var i = 0; i < geometries.length; ++i) {
            var geometry_1 = geometries[i];
            var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
            writer(feature, geometry_1);
        }
    };
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {Array<import("../Feature").FeatureLike>} features The features being modified.
     * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
     * @return {Feature} Vertex feature.
     * @private
     */
    Modify.prototype.createOrUpdateVertexFeature_ = function (coordinates, features, geometries) {
        var vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
            vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"](coordinates));
            this.vertexFeature_ = vertexFeature;
            this.overlay_.getSource().addFeature(vertexFeature);
        }
        else {
            var geometry = vertexFeature.getGeometry();
            geometry.setCoordinates(coordinates);
        }
        vertexFeature.set('features', features);
        vertexFeature.set('geometries', geometries);
        return vertexFeature;
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
    Modify.prototype.handleEvent = function (mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) {
            return true;
        }
        this.lastPointerEvent_ = mapBrowserEvent;
        var handled;
        if (!mapBrowserEvent.map.getView().getInteracting() &&
            mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].POINTERMOVE &&
            !this.handlingDownUpSequence) {
            this.handlePointerMove_(mapBrowserEvent);
        }
        if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
            if (mapBrowserEvent.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].SINGLECLICK ||
                !this.ignoreNextSingleClick_) {
                handled = this.removePoint();
            }
            else {
                handled = true;
            }
        }
        if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].SINGLECLICK) {
            this.ignoreNextSingleClick_ = false;
        }
        return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     */
    Modify.prototype.handleDragEvent = function (evt) {
        this.ignoreNextSingleClick_ = false;
        this.willModifyFeatures_(evt, this.dragSegments_);
        var vertex = [
            evt.coordinate[0] + this.delta_[0],
            evt.coordinate[1] + this.delta_[1],
        ];
        var features = [];
        var geometries = [];
        for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
            var dragSegment = this.dragSegments_[i];
            var segmentData = dragSegment[0];
            var feature = segmentData.feature;
            if (features.indexOf(feature) === -1) {
                features.push(feature);
            }
            var geometry = segmentData.geometry;
            if (geometries.indexOf(geometry) === -1) {
                geometries.push(geometry);
            }
            var depth = segmentData.depth;
            var coordinates = void 0;
            var segment = segmentData.segment;
            var index = dragSegment[1];
            while (vertex.length < geometry.getStride()) {
                vertex.push(segment[index][vertex.length]);
            }
            switch (geometry.getType()) {
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].POINT:
                    coordinates = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_POINT:
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index] = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LINE_STRING:
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_LINE_STRING:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].POLYGON:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_POLYGON:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CIRCLE:
                    segment[0] = vertex;
                    segment[1] = vertex;
                    if (segmentData.index === CIRCLE_CENTER_INDEX) {
                        this.changingFeature_ = true;
                        geometry.setCenter(vertex);
                        this.changingFeature_ = false;
                    }
                    else {
                        // We're dragging the circle's circumference:
                        this.changingFeature_ = true;
                        var projection = evt.map.getView().getProjection();
                        var radius = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* distance */ "c"])(Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(geometry.getCenter(), projection), Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(vertex, projection));
                        var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* getUserProjection */ "q"])();
                        if (userProjection) {
                            var circleGeometry = geometry
                                .clone()
                                .transform(userProjection, projection);
                            circleGeometry.setRadius(radius);
                            radius = circleGeometry
                                .transform(projection, userProjection)
                                .getRadius();
                        }
                        geometry.setRadius(radius);
                        this.changingFeature_ = false;
                    }
                    break;
                default:
                // pass
            }
            if (coordinates) {
                this.setGeometryCoordinates_(geometry, coordinates);
            }
        }
        this.createOrUpdateVertexFeature_(vertex, features, geometries);
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     */
    Modify.prototype.handleDownEvent = function (evt) {
        if (!this.condition_(evt)) {
            return false;
        }
        var pixelCoordinate = evt.coordinate;
        this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
        this.dragSegments_.length = 0;
        this.featuresBeingModified_ = null;
        var vertexFeature = this.vertexFeature_;
        if (vertexFeature) {
            var projection = evt.map.getView().getProjection();
            var insertVertices = [];
            var vertex = vertexFeature.getGeometry().getCoordinates();
            var vertexExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])([vertex]);
            var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
            var componentSegments = {};
            segmentDataMatches.sort(compareIndexes);
            for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
                var segmentDataMatch = segmentDataMatches[i];
                var segment = segmentDataMatch.segment;
                var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_20__[/* getUid */ "c"])(segmentDataMatch.geometry);
                var depth = segmentDataMatch.depth;
                if (depth) {
                    uid += '-' + depth.join('-'); // separate feature components
                }
                if (!componentSegments[uid]) {
                    componentSegments[uid] = new Array(2);
                }
                if (segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CIRCLE &&
                    segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                    if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* equals */ "d"])(closestVertex, vertex) &&
                        !componentSegments[uid][0]) {
                        this.dragSegments_.push([segmentDataMatch, 0]);
                        componentSegments[uid][0] = segmentDataMatch;
                    }
                    continue;
                }
                if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* equals */ "d"])(segment[0], vertex) &&
                    !componentSegments[uid][0]) {
                    this.dragSegments_.push([segmentDataMatch, 0]);
                    componentSegments[uid][0] = segmentDataMatch;
                    continue;
                }
                if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* equals */ "d"])(segment[1], vertex) &&
                    !componentSegments[uid][1]) {
                    // prevent dragging closed linestrings by the connecting node
                    if ((segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LINE_STRING ||
                        segmentDataMatch.geometry.getType() ===
                            _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_LINE_STRING) &&
                        componentSegments[uid][0] &&
                        componentSegments[uid][0].index === 0) {
                        continue;
                    }
                    this.dragSegments_.push([segmentDataMatch, 1]);
                    componentSegments[uid][1] = segmentDataMatch;
                    continue;
                }
                if (Object(_util_js__WEBPACK_IMPORTED_MODULE_20__[/* getUid */ "c"])(segment) in this.vertexSegments_ &&
                    !componentSegments[uid][0] &&
                    !componentSegments[uid][1] &&
                    this.insertVertexCondition_(evt)) {
                    insertVertices.push(segmentDataMatch);
                }
            }
            if (insertVertices.length) {
                this.willModifyFeatures_(evt, [insertVertices]);
            }
            for (var j = insertVertices.length - 1; j >= 0; --j) {
                this.insertVertex_(insertVertices[j], vertex);
            }
        }
        return !!this.vertexFeature_;
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     */
    Modify.prototype.handleUpEvent = function (evt) {
        for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
            var segmentData = this.dragSegments_[i][0];
            var geometry = segmentData.geometry;
            if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CIRCLE) {
                // Update a circle object in the R* bush:
                var coordinates = geometry.getCenter();
                var centerSegmentData = segmentData.featureSegments[0];
                var circumferenceSegmentData = segmentData.featureSegments[1];
                centerSegmentData.segment[0] = coordinates;
                centerSegmentData.segment[1] = coordinates;
                circumferenceSegmentData.segment[0] = coordinates;
                circumferenceSegmentData.segment[1] = coordinates;
                this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* createOrUpdateFromCoordinate */ "m"])(coordinates), centerSegmentData);
                var circleGeometry = geometry;
                var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* getUserProjection */ "q"])();
                if (userProjection) {
                    var projection = evt.map.getView().getProjection();
                    circleGeometry = circleGeometry
                        .clone()
                        .transform(userProjection, projection);
                    circleGeometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_18__[/* fromCircle */ "b"])(circleGeometry).transform(projection, userProjection);
                }
                this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
            }
            else {
                this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(segmentData.segment), segmentData);
            }
        }
        if (this.featuresBeingModified_) {
            this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
        }
        return false;
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @private
     */
    Modify.prototype.handlePointerMove_ = function (evt) {
        this.lastPixel_ = evt.pixel;
        this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
    };
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel
     * @param {import("../PluggableMap.js").default} map Map.
     * @param {import("../coordinate.js").Coordinate} [opt_coordinate] The pixel Coordinate.
     * @private
     */
    Modify.prototype.handlePointerAtPixel_ = function (pixel, map, opt_coordinate) {
        var _this = this;
        var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
        var projection = map.getView().getProjection();
        var sortByDistance = function (a, b) {
            return (projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -
                projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection));
        };
        /** @type {Array<SegmentData>|undefined} */
        var nodes;
        var hitPointGeometry;
        if (this.hitDetection_) {
            var layerFilter = typeof this.hitDetection_ === 'object'
                ? function (layer) { return layer === _this.hitDetection_; }
                : undefined;
            map.forEachFeatureAtPixel(pixel, function (feature, layer, geometry) {
                geometry =
                    geometry ||
                        /** @type {import("../geom/SimpleGeometry").default} */ (feature.getGeometry());
                if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].POINT &&
                    Object(_array_js__WEBPACK_IMPORTED_MODULE_17__[/* includes */ "d"])(_this.features_.getArray(), feature)) {
                    hitPointGeometry = geometry;
                    var coordinate = geometry.getFlatCoordinates().slice(0, 2);
                    nodes = [
                        {
                            feature: feature,
                            geometry: geometry,
                            segment: [coordinate, coordinate],
                        },
                    ];
                }
                return true;
            }, { layerFilter: layerFilter });
        }
        if (!nodes) {
            var viewExtent = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserExtent */ "k"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* createOrUpdateFromCoordinate */ "m"])(pixelCoordinate, tempExtent), projection);
            var buffer = map.getView().getResolution() * this.pixelTolerance_;
            var box = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* toUserExtent */ "s"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* buffer */ "c"])(viewExtent, buffer, tempExtent), projection);
            nodes = this.rBush_.getInExtent(box);
        }
        if (nodes && nodes.length > 0) {
            var node = nodes.sort(sortByDistance)[0];
            var closestSegment = node.segment;
            var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
            var vertexPixel = map.getPixelFromCoordinate(vertex);
            var dist = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* distance */ "c"])(pixel, vertexPixel);
            if (hitPointGeometry || dist <= this.pixelTolerance_) {
                /** @type {Object<string, boolean>} */
                var vertexSegments = {};
                vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_20__[/* getUid */ "c"])(closestSegment)] = true;
                if (!this.snapToPointer_) {
                    this.delta_[0] = vertex[0] - pixelCoordinate[0];
                    this.delta_[1] = vertex[1] - pixelCoordinate[1];
                }
                if (node.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CIRCLE &&
                    node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    this.snappedToVertex_ = true;
                    this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
                }
                else {
                    var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                    var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                    var squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* squaredDistance */ "h"])(vertexPixel, pixel1);
                    var squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* squaredDistance */ "h"])(vertexPixel, pixel2);
                    dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                    this.snappedToVertex_ = dist <= this.pixelTolerance_;
                    if (this.snappedToVertex_) {
                        vertex =
                            squaredDist1 > squaredDist2
                                ? closestSegment[1]
                                : closestSegment[0];
                    }
                    this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
                    var geometries = {};
                    geometries[Object(_util_js__WEBPACK_IMPORTED_MODULE_20__[/* getUid */ "c"])(node.geometry)] = true;
                    for (var i = 1, ii = nodes.length; i < ii; ++i) {
                        var segment = nodes[i].segment;
                        if ((Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* equals */ "d"])(closestSegment[0], segment[0]) &&
                            Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* equals */ "d"])(closestSegment[1], segment[1])) ||
                            (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* equals */ "d"])(closestSegment[0], segment[1]) &&
                                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* equals */ "d"])(closestSegment[1], segment[0]))) {
                            var geometryUid = Object(_util_js__WEBPACK_IMPORTED_MODULE_20__[/* getUid */ "c"])(nodes[i].geometry);
                            if (!(geometryUid in geometries)) {
                                geometries[geometryUid] = true;
                                vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_20__[/* getUid */ "c"])(segment)] = true;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
                this.vertexSegments_ = vertexSegments;
                return;
            }
        }
        if (this.vertexFeature_) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
    };
    /**
     * @param {SegmentData} segmentData Segment data.
     * @param {import("../coordinate.js").Coordinate} vertex Vertex.
     * @private
     */
    Modify.prototype.insertVertex_ = function (segmentData, vertex) {
        var segment = segmentData.segment;
        var feature = segmentData.feature;
        var geometry = segmentData.geometry;
        var depth = segmentData.depth;
        var index = segmentData.index;
        var coordinates;
        while (vertex.length < geometry.getStride()) {
            vertex.push(0);
        }
        switch (geometry.getType()) {
            case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_LINE_STRING:
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].POLYGON:
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_POLYGON:
                coordinates = geometry.getCoordinates();
                coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                break;
            case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LINE_STRING:
                coordinates = geometry.getCoordinates();
                coordinates.splice(index + 1, 0, vertex);
                break;
            default:
                return;
        }
        this.setGeometryCoordinates_(geometry, coordinates);
        var rTree = this.rBush_;
        rTree.remove(segmentData);
        this.updateSegmentIndices_(geometry, index, depth, 1);
        /** @type {SegmentData} */
        var newSegmentData = {
            segment: [segment[0], vertex],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index,
        };
        rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(newSegmentData.segment), newSegmentData);
        this.dragSegments_.push([newSegmentData, 1]);
        /** @type {SegmentData} */
        var newSegmentData2 = {
            segment: [vertex, segment[1]],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index + 1,
        };
        rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(newSegmentData2.segment), newSegmentData2);
        this.dragSegments_.push([newSegmentData2, 0]);
        this.ignoreNextSingleClick_ = true;
    };
    /**
     * Removes the vertex currently being pointed.
     * @return {boolean} True when a vertex was removed.
     * @api
     */
    Modify.prototype.removePoint = function () {
        if (this.lastPointerEvent_ &&
            this.lastPointerEvent_.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].POINTERDRAG) {
            var evt = this.lastPointerEvent_;
            this.willModifyFeatures_(evt, this.dragSegments_);
            var removed = this.removeVertex_();
            if (this.featuresBeingModified_) {
                this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            }
            this.featuresBeingModified_ = null;
            return removed;
        }
        return false;
    };
    /**
     * Removes a vertex from all matching features.
     * @return {boolean} True when a vertex was removed.
     * @private
     */
    Modify.prototype.removeVertex_ = function () {
        var dragSegments = this.dragSegments_;
        var segmentsByFeature = {};
        var deleted = false;
        var component, coordinates, dragSegment, geometry, i, index, left;
        var newIndex, right, segmentData, uid;
        for (i = dragSegments.length - 1; i >= 0; --i) {
            dragSegment = dragSegments[i];
            segmentData = dragSegment[0];
            uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_20__[/* getUid */ "c"])(segmentData.feature);
            if (segmentData.depth) {
                // separate feature components
                uid += '-' + segmentData.depth.join('-');
            }
            if (!(uid in segmentsByFeature)) {
                segmentsByFeature[uid] = {};
            }
            if (dragSegment[1] === 0) {
                segmentsByFeature[uid].right = segmentData;
                segmentsByFeature[uid].index = segmentData.index;
            }
            else if (dragSegment[1] == 1) {
                segmentsByFeature[uid].left = segmentData;
                segmentsByFeature[uid].index = segmentData.index + 1;
            }
        }
        for (uid in segmentsByFeature) {
            right = segmentsByFeature[uid].right;
            left = segmentsByFeature[uid].left;
            index = segmentsByFeature[uid].index;
            newIndex = index - 1;
            if (left !== undefined) {
                segmentData = left;
            }
            else {
                segmentData = right;
            }
            if (newIndex < 0) {
                newIndex = 0;
            }
            geometry = segmentData.geometry;
            coordinates = geometry.getCoordinates();
            component = coordinates;
            deleted = false;
            switch (geometry.getType()) {
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_LINE_STRING:
                    if (coordinates[segmentData.depth[0]].length > 2) {
                        coordinates[segmentData.depth[0]].splice(index, 1);
                        deleted = true;
                    }
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LINE_STRING:
                    if (coordinates.length > 2) {
                        coordinates.splice(index, 1);
                        deleted = true;
                    }
                    break;
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].MULTI_POLYGON:
                    component = component[segmentData.depth[1]];
                /* falls through */
                case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].POLYGON:
                    component = component[segmentData.depth[0]];
                    if (component.length > 4) {
                        if (index == component.length - 1) {
                            index = 0;
                        }
                        component.splice(index, 1);
                        deleted = true;
                        if (index === 0) {
                            // close the ring again
                            component.pop();
                            component.push(component[0]);
                            newIndex = component.length - 1;
                        }
                    }
                    break;
                default:
                // pass
            }
            if (deleted) {
                this.setGeometryCoordinates_(geometry, coordinates);
                var segments = [];
                if (left !== undefined) {
                    this.rBush_.remove(left);
                    segments.push(left.segment[0]);
                }
                if (right !== undefined) {
                    this.rBush_.remove(right);
                    segments.push(right.segment[1]);
                }
                if (left !== undefined && right !== undefined) {
                    /** @type {SegmentData} */
                    var newSegmentData = {
                        depth: segmentData.depth,
                        feature: segmentData.feature,
                        geometry: segmentData.geometry,
                        index: newIndex,
                        segment: segments,
                    };
                    this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_14__[/* boundingExtent */ "b"])(newSegmentData.segment), newSegmentData);
                }
                this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                if (this.vertexFeature_) {
                    this.overlay_.getSource().removeFeature(this.vertexFeature_);
                    this.vertexFeature_ = null;
                }
                dragSegments.length = 0;
            }
        }
        return deleted;
    };
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {Array} coordinates Coordinates.
     * @private
     */
    Modify.prototype.setGeometryCoordinates_ = function (geometry, coordinates) {
        this.changingFeature_ = true;
        geometry.setCoordinates(coordinates);
        this.changingFeature_ = false;
    };
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} index Index.
     * @param {Array<number>|undefined} depth Depth.
     * @param {number} delta Delta (1 or -1).
     * @private
     */
    Modify.prototype.updateSegmentIndices_ = function (geometry, index, depth, delta) {
        this.rBush_.forEachInExtent(geometry.getExtent(), function (segmentDataMatch) {
            if (segmentDataMatch.geometry === geometry &&
                (depth === undefined ||
                    segmentDataMatch.depth === undefined ||
                    Object(_array_js__WEBPACK_IMPORTED_MODULE_17__[/* equals */ "b"])(segmentDataMatch.depth, depth)) &&
                segmentDataMatch.index > index) {
                segmentDataMatch.index += delta;
            }
        });
    };
    return Modify;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "b"]));
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */
function compareIndexes(a, b) {
    return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */
function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
    var geometry = segmentData.geometry;
    if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CIRCLE) {
        var circleGeometry = /** @type {import("../geom/Circle.js").default} */ (geometry);
        if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
            var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* getUserProjection */ "q"])();
            if (userProjection) {
                circleGeometry = /** @type {import("../geom/Circle.js").default} */ (circleGeometry.clone().transform(userProjection, projection));
            }
            var distanceToCenterSquared = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* squaredDistance */ "h"])(circleGeometry.getCenter(), Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(pointCoordinates, projection));
            var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
            return distanceToCircumference * distanceToCircumference;
        }
    }
    var coordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(pointCoordinates, projection);
    tempSegment[0] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(segmentData.segment[0], projection);
    tempSegment[1] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(segmentData.segment[1], projection);
    return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* squaredDistanceToSegment */ "i"])(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */
function closestOnSegmentData(pointCoordinates, segmentData, projection) {
    var geometry = segmentData.geometry;
    if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CIRCLE &&
        segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
        var circleGeometry = /** @type {import("../geom/Circle.js").default} */ (geometry);
        var userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* getUserProjection */ "q"])();
        if (userProjection) {
            circleGeometry = /** @type {import("../geom/Circle.js").default} */ (circleGeometry.clone().transform(userProjection, projection));
        }
        return Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* toUserCoordinate */ "r"])(circleGeometry.getClosestPoint(Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(pointCoordinates, projection)), projection);
    }
    var coordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(pointCoordinates, projection);
    tempSegment[0] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(segmentData.segment[0], projection);
    tempSegment[1] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* fromUserCoordinate */ "j"])(segmentData.segment[1], projection);
    return Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__[/* toUserCoordinate */ "r"])(Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_15__[/* closestOnSegment */ "b"])(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
    var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_16__[/* createEditingStyle */ "b"])();
    return function (feature, resolution) {
        return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].POINT];
    };
}
/* harmony default export */ __webpack_exports__["a"] = (Modify);
//# sourceMappingURL=Modify.js.map

/***/ }),

/***/ "c866":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACKSURBVEhL7dE9CgIxFEXhgxaijSZjI4wLsbFxCXaWLttyfhtlQCGdxJdgbRewuB/c+vB4iIiI/NSzWz1w+zu+Lr3UucHiG64uAR8GXNGNtsk6DZtjDo/4a2Qbn1RF97K9rdOxPuXwgD8HqrbHFZ1d3U7W6XCHHI4wT39uqJellzrWm+WwiIj8MfgAEWnhnbKUnq0AAAAASUVORK5CYII="

/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8d2":
/***/ (function(module, exports, __webpack_require__) {

var PROPER_FUNCTION_NAME = __webpack_require__("5e77").PROPER;
var fails = __webpack_require__("d039");
var whitespaces = __webpack_require__("5899");

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]()
      || non[METHOD_NAME]() !== non
      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
  });
};


/***/ }),

/***/ "ca42":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return easeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return easeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return inAndOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return linear; });
/* unused harmony export upAndDown */
/**
 * @module ol/easing
 */
/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
    return Math.pow(t, 3);
}
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
    return 1 - easeIn(1 - t);
}
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
}
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
    return t;
}
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
    if (t < 0.5) {
        return inAndOut(2 * t);
    }
    else {
        return 1 - inAndOut(2 * (t - 0.5));
    }
}
//# sourceMappingURL=easing.js.map

/***/ }),

/***/ "ca84":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var hasOwn = __webpack_require__("1a2d");
var toIndexedObject = __webpack_require__("fc6a");
var indexOf = __webpack_require__("4d64").indexOf;
var hiddenKeys = __webpack_require__("d012");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "cace":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/P0074.bf89e7aa.png";

/***/ }),

/***/ "cc12":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "cc88":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "ccc0":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAGCUlEQVR4nIWVeWyU5xHGf/Ptenfxrtf3hfHJKYwxCVcMpUGOiQkVIYKUwyVVldpKsZTQNgFXTSsobakqRKpgNUkjKKhHwpHKoASaFAhqcEsIxKh2jQPY5rDxBcb22ux6r2/6x9oWCYTOaP56n3me95tv3hkxTRMAEWHESoHVg77A/IZrtzPPtfS4b/YO0dLRj2G1KCMwMxiWrFQ32UkxPJqb7CnITWqLdznOAoeADwFUFVHVUeJyYMsfjzdO2P33epq7BkiLiyZ3Qjzj453k5ySR4LSDCKjSO+Sn6fptOvq8NLffofPOXTKTXJSXFrBheWG7BdkK7BkV2HGupeeV0lf2kxIbzQ/XzGP2xBQGh4Nc7Rzg3JVuLt/y0N07BIYBpklaoos52UnMnJhMWmw0cS4756/0sPPAWdp7PNRsf5bSWVk7RVUruvq9b6eveYMd5d9k3ZIZ7Hj3Uw6daabj6m3ic5IonpmJCNitFgyLMBwI4/OHON3UwcC12+CIYnx6LN8umsTmssd453gjm177iIsHKxFVbfrBW6em3bjl4eDmZaSsfhNf7yDEO2HAS+VzC/h9xWIeZBv31rLrT7URbDAM/V4c8U4Gal7kyS01ZCXHIKZptpVsPZxRubSA9840s7/mAqTGgAKqGCKRugtIIASm0rzneQIhk8WbDtA54AObNXIuoF0enl87j5LCLHafaMQAeuxWQ1q6Brjc0Q8x9jFyEcEMm5i+AKY3QLizn5+tLyInxc1T247QebMPcVgBBVUwFZw2Pm+9hS8QwmY1xBCRS1nJMdijLGKzWgRTBRBEREGwGIIjShCRcdlJsnXNfKk+9h9pbWgXEp2CRrCIiIoIpkp2cozc8vgkPzPRNFR1x7zJacFBX1AfyUtWgmEF9D4fDujKb0xRQH9bU6e4HSqRLh9zASWsOmdiijbc6NWpGXF9hohcWJyf0dLUfkeyklyRG6kK8pUIq6xdOElCYVNutvUKNqsoX8YokdzsFLd03rkrSwqz6g2AvLTYk15/iIwEF4yLitQSGXMUsAg+f4jGtl4YDo780QiK0QiFscSNwxAwRMhJcR8efWjzf3Hg7KfxTjt/rb3MZxdugMsRmQoCOuQH04wIwVgT4HIgUQZjw6Dfy4on85mUGkuS28FPVs4Zbx05Oltekt/4472n88sWTeGzfzWDy46GFXwBfvdiCRMSXQRNZfCuH0XIS3Pz8r5aGi52gHOk80JhVhdNovpYPTVVy94HOq2jsygj0VXtdNjeSo9zavrkVDp7PJH+tkdx8N/NRNuj6OsdoiAzgX2bnuLdTy5x9drtCAbA52fW3Fx8wRD5mQmSFu/coaoY9zzMPS99a2b3++evysvPzAbPMIggNgtn6q5z8kgdabHjqCp7jBXbjlD2078xFDIRmyWSfddP1TOPsufERfnR07MuAKcBrPeM6dCs3ORf26zGrsxEp0zOz+BKaw/qtIM3wM4tKyidk0Np1UHa2u5AqhsGh1FDYGiY4uLpdPV5yU1xk5+Z+NLoCjBUldEAqrd/Z8G1vR838cv1RYo/pPR79fWqZVqYl6wzyv6gbd0eJd6pDAd12eNTNSbaplgt+uqq2br34yaqyx8/AdSOchojj3Bs4aTGRa9fOC2dxhu9UrFuvmCa8kLpDCnZcjgCsluFIb/Exo2To68ul8EBr1RvXCJvfNggG5bOICHG8b3R24vIlxbOvba7dNuR71eUTGfXB/U8OzeHR6alE2UIpoKhEEI59MllxGqQkejiVEM7x37+dCXw5r1EXycg3f3epuXbP5j6541LqHj9H5z+/Dq47GC1gD8EgRCVq2ZTXDCBqr+c4Yvq9futFmPdfURfIwAw+WR923+/u+u4bfeGYlo6+jl6rpW+wWEmpsay9onpXO/s5zeH66h7bd351LjoBUDwPoHRpf/AzxApau0eOL5y62HnlMwEls7NI8Zp41qXh/dONREf4+Dor1bVWQxZqKrDD+R4mMCIyCTg7Xf+eWnRR+evWr3+oCa7o2XVosmeJwqz9gEbH1KFh5boq/Yc8ALgADqAzcAX/y/pf4XXslvcRteyAAAAAElFTkSuQmCC"

/***/ }),

/***/ "cd7e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return CLASS_HIDDEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return CLASS_SELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return CLASS_UNSELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return CLASS_UNSUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CLASS_CONTROL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CLASS_COLLAPSED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getFontParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return cssOpacity; });
/**
 * @module ol/css
 */
/**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */
/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
var CLASS_SELECTABLE = 'ol-selectable';
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSELECTABLE = 'ol-unselectable';
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSUPPORTED = 'ol-unsupported';
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
var CLASS_CONTROL = 'ol-control';
/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
var CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */
var fontRegEx = new RegExp([
    '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
    '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
    '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
    '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
    '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
].join(''), 'i');
var fontRegExMatchIndex = [
    'style',
    'variant',
    'weight',
    'size',
    'lineHeight',
    'family',
];
/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters|null} The font parameters (or null if the input spec is invalid).
 */
var getFontParameters = function (fontSpec) {
    var match = fontSpec.match(fontRegEx);
    if (!match) {
        return null;
    }
    var style = /** @type {FontParameters} */ ({
        lineHeight: 'normal',
        size: '1.2em',
        style: 'normal',
        weight: 'normal',
        variant: 'normal',
    });
    for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
        var value = match[i + 1];
        if (value !== undefined) {
            style[fontRegExMatchIndex[i]] = value;
        }
    }
    style.families = style.family.split(/,\s?/);
    return style;
};
/**
 * @param {number} opacity Opacity (0..1).
 * @return {string} CSS opacity.
 */
function cssOpacity(opacity) {
    return opacity === 1 ? '' : String(Math.round(opacity * 100) / 100);
}
//# sourceMappingURL=css.js.map

/***/ }),

/***/ "cdf9":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var newPromiseCapability = __webpack_require__("f069");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "ce0f":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "ce2c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/ImageState.js
var ImageState = __webpack_require__("869f");

// EXTERNAL MODULE: ./node_modules/ol/style/Image.js
var Image = __webpack_require__("ab35");

// EXTERNAL MODULE: ./node_modules/ol/color.js
var ol_color = __webpack_require__("5c38");

// EXTERNAL MODULE: ./node_modules/ol/colorlike.js
var colorlike = __webpack_require__("e98d");

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__("0999");

// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js
var canvas = __webpack_require__("ddea");

// CONCATENATED MODULE: ./node_modules/ol/style/RegularShape.js
/**
 * @module ol/style/RegularShape
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 */
/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */
/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape_RegularShape = /** @class */ (function (_super) {
    __extends(RegularShape, _super);
    /**
     * @param {Options} options Options.
     */
    function RegularShape(options) {
        var _this = this;
        /**
         * @type {boolean}
         */
        var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        _this = _super.call(this, {
            opacity: 1,
            rotateWithView: rotateWithView,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            scale: options.scale !== undefined ? options.scale : 1,
            displacement: options.displacement !== undefined ? options.displacement : [0, 0],
        }) || this;
        /**
         * @private
         * @type {Object<number, HTMLCanvasElement>}
         */
        _this.canvas_ = undefined;
        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        _this.hitDetectionCanvas_ = null;
        /**
         * @private
         * @type {import("./Fill.js").default}
         */
        _this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
         * @private
         * @type {Array<number>}
         */
        _this.origin_ = [0, 0];
        /**
         * @private
         * @type {number}
         */
        _this.points_ = options.points;
        /**
         * @protected
         * @type {number}
         */
        _this.radius_ =
            options.radius !== undefined ? options.radius : options.radius1;
        /**
         * @private
         * @type {number|undefined}
         */
        _this.radius2_ = options.radius2;
        /**
         * @private
         * @type {number}
         */
        _this.angle_ = options.angle !== undefined ? options.angle : 0;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */
        _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
         * @private
         * @type {import("../size.js").Size}
         */
        _this.size_ = null;
        /**
         * @private
         * @type {RenderOptions}
         */
        _this.renderOptions_ = null;
        _this.render();
        return _this;
    }
    /**
     * Clones the style.
     * @return {RegularShape} The cloned style.
     * @api
     */
    RegularShape.prototype.clone = function () {
        var scale = this.getScale();
        var style = new RegularShape({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            points: this.getPoints(),
            radius: this.getRadius(),
            radius2: this.getRadius2(),
            angle: this.getAngle(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            displacement: this.getDisplacement().slice(),
        });
        style.setOpacity(this.getOpacity());
        return style;
    };
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */
    RegularShape.prototype.getAnchor = function () {
        var size = this.size_;
        if (!size) {
            return null;
        }
        var displacement = this.getDisplacement();
        return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];
    };
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */
    RegularShape.prototype.getAngle = function () {
        return this.angle_;
    };
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    RegularShape.prototype.getFill = function () {
        return this.fill_;
    };
    /**
     * @return {HTMLCanvasElement} Image element.
     */
    RegularShape.prototype.getHitDetectionImage = function () {
        if (!this.hitDetectionCanvas_) {
            this.createHitDetectionCanvas_(this.renderOptions_);
        }
        return this.hitDetectionCanvas_;
    };
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     */
    RegularShape.prototype.getImage = function (pixelRatio) {
        var image = this.canvas_[pixelRatio];
        if (!image) {
            var renderOptions = this.renderOptions_;
            var context = Object(dom["a" /* createCanvasContext2D */])(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
            this.draw_(renderOptions, context, pixelRatio);
            image = context.canvas;
            this.canvas_[pixelRatio] = image;
        }
        return image;
    };
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    RegularShape.prototype.getPixelRatio = function (pixelRatio) {
        return pixelRatio;
    };
    /**
     * @return {import("../size.js").Size} Image size.
     */
    RegularShape.prototype.getImageSize = function () {
        return this.size_;
    };
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    RegularShape.prototype.getImageState = function () {
        return ImageState["a" /* default */].LOADED;
    };
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */
    RegularShape.prototype.getOrigin = function () {
        return this.origin_;
    };
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */
    RegularShape.prototype.getPoints = function () {
        return this.points_;
    };
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */
    RegularShape.prototype.getRadius = function () {
        return this.radius_;
    };
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */
    RegularShape.prototype.getRadius2 = function () {
        return this.radius2_;
    };
    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     */
    RegularShape.prototype.getSize = function () {
        return this.size_;
    };
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    RegularShape.prototype.getStroke = function () {
        return this.stroke_;
    };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    RegularShape.prototype.listenImageChange = function (listener) { };
    /**
     * Load not yet loaded URI.
     */
    RegularShape.prototype.load = function () { };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    RegularShape.prototype.unlistenImageChange = function (listener) { };
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */
    RegularShape.prototype.calculateLineJoinSize_ = function (lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 ||
            this.points_ === Infinity ||
            (lineJoin !== 'bevel' && lineJoin !== 'miter')) {
            return strokeWidth;
        }
        // m  | ^
        // i  | |\                  .
        // t >|  #\
        // e  | |\ \              .
        // r      \s\
        //      |  \t\          .                 .
        //          \r\                      .   .
        //      |    \o\      .          .  . . .
        //          e \k\            .  .    . .
        //      |      \e\  .    .  .       . .
        //       d      \ \  .  .          . .
        //      | _ _a_ _\#  .            . .
        //   r1          / `             . .
        //      |                       . .
        //       b     /               . .
        //      |                     . .
        //           / r2            . .
        //      |                        .   .
        //         /                           .   .
        //      |α                                   .   .
        //       /                                         .   .
        //      ° center
        var r1 = this.radius_;
        var r2 = this.radius2_ === undefined ? r1 : this.radius2_;
        if (r1 < r2) {
            var tmp = r1;
            r1 = r2;
            r2 = tmp;
        }
        var points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
        var alpha = (2 * Math.PI) / points;
        var a = r2 * Math.sin(alpha);
        var b = Math.sqrt(r2 * r2 - a * a);
        var d = r1 - b;
        var e = Math.sqrt(a * a + d * d);
        var miterRatio = e / a;
        if (lineJoin === 'miter' && miterRatio <= miterLimit) {
            return miterRatio * strokeWidth;
        }
        // Calculate the distnce from center to the stroke corner where
        // it was cut short because of the miter limit.
        //              l
        //        ----+---- <= distance from center to here is maxr
        //       /####|k ##\
        //      /#####^#####\
        //     /#### /+\# s #\
        //    /### h/+++\# t #\
        //   /### t/+++++\# r #\
        //  /### a/+++++++\# o #\
        // /### p/++ fill +\# k #\
        ///#### /+++++^+++++\# e #\
        //#####/+++++/+\+++++\#####\
        var k = strokeWidth / 2 / miterRatio;
        var l = (strokeWidth / 2) * (d / e);
        var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        var bevelAdd = maxr - r1;
        if (this.radius2_ === undefined || lineJoin === 'bevel') {
            return bevelAdd * 2;
        }
        // If outer miter is over the miter limit the inner miter may reach through the
        // center and be longer than the bevel, same calculation as above but swap r1 / r2.
        var aa = r1 * Math.sin(alpha);
        var bb = Math.sqrt(r1 * r1 - aa * aa);
        var dd = r2 - bb;
        var ee = Math.sqrt(aa * aa + dd * dd);
        var innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
            var innerLength = (innerMiterRatio * strokeWidth) / 2 - r2 - r1;
            return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
    };
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */
    RegularShape.prototype.createRenderOptions = function () {
        var lineJoin = canvas["g" /* defaultLineJoin */];
        var miterLimit = 0;
        var lineDash = null;
        var lineDashOffset = 0;
        var strokeStyle;
        var strokeWidth = 0;
        if (this.stroke_) {
            strokeStyle = this.stroke_.getColor();
            if (strokeStyle === null) {
                strokeStyle = canvas["k" /* defaultStrokeStyle */];
            }
            strokeStyle = Object(colorlike["a" /* asColorLike */])(strokeStyle);
            strokeWidth = this.stroke_.getWidth();
            if (strokeWidth === undefined) {
                strokeWidth = canvas["h" /* defaultLineWidth */];
            }
            lineDash = this.stroke_.getLineDash();
            lineDashOffset = this.stroke_.getLineDashOffset();
            lineJoin = this.stroke_.getLineJoin();
            if (lineJoin === undefined) {
                lineJoin = canvas["g" /* defaultLineJoin */];
            }
            miterLimit = this.stroke_.getMiterLimit();
            if (miterLimit === undefined) {
                miterLimit = canvas["i" /* defaultMiterLimit */];
            }
        }
        var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        var size = Math.ceil(2 * maxRadius + add);
        return {
            strokeStyle: strokeStyle,
            strokeWidth: strokeWidth,
            size: size,
            lineDash: lineDash,
            lineDashOffset: lineDashOffset,
            lineJoin: lineJoin,
            miterLimit: miterLimit,
        };
    };
    /**
     * @protected
     */
    RegularShape.prototype.render = function () {
        this.renderOptions_ = this.createRenderOptions();
        var size = this.renderOptions_.size;
        this.canvas_ = {};
        this.size_ = [size, size];
    };
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */
    RegularShape.prototype.draw_ = function (renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
            var color = this.fill_.getColor();
            if (color === null) {
                color = canvas["b" /* defaultFillStyle */];
            }
            context.fillStyle = Object(colorlike["a" /* asColorLike */])(color);
            context.fill();
        }
        if (this.stroke_) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (context.setLineDash && renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    };
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     */
    RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
        if (this.fill_) {
            var color = this.fill_.getColor();
            // determine if fill is transparent (or pattern or gradient)
            var opacity = 0;
            if (typeof color === 'string') {
                color = Object(ol_color["a" /* asArray */])(color);
            }
            if (color === null) {
                opacity = 1;
            }
            else if (Array.isArray(color)) {
                opacity = color.length === 4 ? color[3] : 1;
            }
            if (opacity === 0) {
                // if a transparent fill style is set, create an extra hit-detection image
                // with a default fill style
                var context = Object(dom["a" /* createCanvasContext2D */])(renderOptions.size, renderOptions.size);
                this.hitDetectionCanvas_ = context.canvas;
                this.drawHitDetectionCanvas_(renderOptions, context);
            }
        }
        if (!this.hitDetectionCanvas_) {
            this.hitDetectionCanvas_ = this.getImage(1);
        }
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */
    RegularShape.prototype.createPath_ = function (context) {
        var points = this.points_;
        var radius = this.radius_;
        if (points === Infinity) {
            context.arc(0, 0, radius, 0, 2 * Math.PI);
        }
        else {
            var radius2 = this.radius2_ === undefined ? radius : this.radius2_;
            if (this.radius2_ !== undefined) {
                points *= 2;
            }
            var startAngle = this.angle_ - Math.PI / 2;
            var step = (2 * Math.PI) / points;
            for (var i = 0; i < points; i++) {
                var angle0 = startAngle + i * step;
                var radiusC = i % 2 === 0 ? radius : radius2;
                context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
            }
            context.closePath();
        }
    };
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */
    RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context) {
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = canvas["b" /* defaultFillStyle */];
        context.fill();
        if (this.stroke_) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    };
    return RegularShape;
}(Image["a" /* default */]));
/* harmony default export */ var style_RegularShape = (RegularShape_RegularShape);
//# sourceMappingURL=RegularShape.js.map
// CONCATENATED MODULE: ./node_modules/ol/style/Circle.js
/**
 * @module ol/style/Circle
 */
var Circle_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 */
/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle = /** @class */ (function (_super) {
    Circle_extends(CircleStyle, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function CircleStyle(opt_options) {
        var options = opt_options ? opt_options : {};
        return _super.call(this, {
            points: Infinity,
            fill: options.fill,
            radius: options.radius,
            stroke: options.stroke,
            scale: options.scale !== undefined ? options.scale : 1,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
            displacement: options.displacement !== undefined ? options.displacement : [0, 0],
        }) || this;
    }
    /**
     * Clones the style.
     * @return {CircleStyle} The cloned style.
     * @api
     */
    CircleStyle.prototype.clone = function () {
        var scale = this.getScale();
        var style = new CircleStyle({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            radius: this.getRadius(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
        });
        style.setOpacity(this.getOpacity());
        return style;
    };
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */
    CircleStyle.prototype.setRadius = function (radius) {
        this.radius_ = radius;
        this.render();
    };
    return CircleStyle;
}(style_RegularShape));
/* harmony default export */ var Circle = __webpack_exports__["a"] = (CircleStyle);
//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "ce4e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "ce78":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "cef7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export stopPropagation */
/* unused harmony export preventDefault */
/**
 * @module ol/events/Event
 */
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var BaseEvent = /** @class */ (function () {
    /**
     * @param {string} type Type.
     */
    function BaseEvent(type) {
        /**
         * @type {boolean}
         */
        this.propagationStopped;
        /**
         * @type {boolean}
         */
        this.defaultPrevented;
        /**
         * The event type.
         * @type {string}
         * @api
         */
        this.type = type;
        /**
         * The event target.
         * @type {Object}
         * @api
         */
        this.target = null;
    }
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */
    BaseEvent.prototype.preventDefault = function () {
        this.defaultPrevented = true;
    };
    /**
     * Stop event propagation.
     * @api
     */
    BaseEvent.prototype.stopPropagation = function () {
        this.propagationStopped = true;
    };
    return BaseEvent;
}());
/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
    evt.stopPropagation();
}
/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
    evt.preventDefault();
}
/* harmony default export */ __webpack_exports__["a"] = (BaseEvent);
//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "d012":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "d039":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "d066":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "d1e7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "d202":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/style/IconOrigin
 */
/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    /**
     * Origin is at bottom left
     * @api
     */
    BOTTOM_LEFT: 'bottom-left',
    /**
     * Origin is at bottom right
     * @api
     */
    BOTTOM_RIGHT: 'bottom-right',
    /**
     * Origin is at top left
     * @api
     */
    TOP_LEFT: 'top-left',
    /**
     * Origin is at top right
     * @api
     */
    TOP_RIGHT: 'top-right',
});
//# sourceMappingURL=IconOrigin.js.map

/***/ }),

/***/ "d2bb":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var uncurryThis = __webpack_require__("e330");
var anObject = __webpack_require__("825a");
var aPossiblePrototype = __webpack_require__("3bbe");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "d352":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("01d4");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8f37");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("f623");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("0af5");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("1e8d");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/GeometryCollection
 */





/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry~Geometry} objects.
 *
 * @api
 */
var GeometryCollection = /** @class */ (function (_super) {
    __extends(GeometryCollection, _super);
    /**
     * @param {Array<Geometry>} [opt_geometries] Geometries.
     */
    function GeometryCollection(opt_geometries) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {Array<Geometry>}
         */
        _this.geometries_ = opt_geometries ? opt_geometries : null;
        /**
         * @type {Array<import("../events.js").EventsKey>}
         */
        _this.changeEventsKeys_ = [];
        _this.listenGeometriesChange_();
        return _this;
    }
    /**
     * @private
     */
    GeometryCollection.prototype.unlistenGeometriesChange_ = function () {
        this.changeEventsKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__[/* unlistenByKey */ "c"]);
        this.changeEventsKeys_.length = 0;
    };
    /**
     * @private
     */
    GeometryCollection.prototype.listenGeometriesChange_ = function () {
        if (!this.geometries_) {
            return;
        }
        for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
            this.changeEventsKeys_.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_4__[/* listen */ "a"])(this.geometries_[i], _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].CHANGE, this.changed, this));
        }
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!GeometryCollection} Clone.
     * @api
     */
    GeometryCollection.prototype.clone = function () {
        var geometryCollection = new GeometryCollection(null);
        geometryCollection.setGeometries(this.geometries_);
        geometryCollection.applyProperties(this);
        return geometryCollection;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* closestSquaredDistanceXY */ "e"])(this.getExtent(), x, y)) {
            return minSquaredDistance;
        }
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
        }
        return minSquaredDistance;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    GeometryCollection.prototype.containsXY = function (x, y) {
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            if (geometries[i].containsXY(x, y)) {
                return true;
            }
        }
        return false;
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    GeometryCollection.prototype.computeExtent = function (extent) {
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* createOrUpdateEmpty */ "l"])(extent);
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* extend */ "p"])(extent, geometries[i].getExtent());
        }
        return extent;
    };
    /**
     * Return the geometries that make up this geometry collection.
     * @return {Array<Geometry>} Geometries.
     * @api
     */
    GeometryCollection.prototype.getGeometries = function () {
        return cloneGeometries(this.geometries_);
    };
    /**
     * @return {Array<Geometry>} Geometries.
     */
    GeometryCollection.prototype.getGeometriesArray = function () {
        return this.geometries_;
    };
    /**
     * @return {Array<Geometry>} Geometries.
     */
    GeometryCollection.prototype.getGeometriesArrayRecursive = function () {
        /** @type {Array<Geometry>} */
        var geometriesArray = [];
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            if (geometries[i].getType() === this.getType()) {
                geometriesArray = geometriesArray.concat(
                /** @type {GeometryCollection} */ (geometries[i]).getGeometriesArrayRecursive());
            }
            else {
                geometriesArray.push(geometries[i]);
            }
        }
        return geometriesArray;
    };
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {GeometryCollection} Simplified GeometryCollection.
     */
    GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 ||
            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {
            return this;
        }
        var simplifiedGeometries = [];
        var geometries = this.geometries_;
        var simplified = false;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            var geometry = geometries[i];
            var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
            simplifiedGeometries.push(simplifiedGeometry);
            if (simplifiedGeometry !== geometry) {
                simplified = true;
            }
        }
        if (simplified) {
            var simplifiedGeometryCollection = new GeometryCollection(null);
            simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
            return simplifiedGeometryCollection;
        }
        else {
            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
            return this;
        }
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    GeometryCollection.prototype.getType = function () {
        return _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].GEOMETRY_COLLECTION;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    GeometryCollection.prototype.intersectsExtent = function (extent) {
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            if (geometries[i].intersectsExtent(extent)) {
                return true;
            }
        }
        return false;
    };
    /**
     * @return {boolean} Is empty.
     */
    GeometryCollection.prototype.isEmpty = function () {
        return this.geometries_.length === 0;
    };
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    GeometryCollection.prototype.rotate = function (angle, anchor) {
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            geometries[i].rotate(angle, anchor);
        }
        this.changed();
    };
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {
        var anchor = opt_anchor;
        if (!anchor) {
            anchor = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__[/* getCenter */ "w"])(this.getExtent());
        }
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            geometries[i].scale(sx, opt_sy, anchor);
        }
        this.changed();
    };
    /**
     * Set the geometries that make up this geometry collection.
     * @param {Array<Geometry>} geometries Geometries.
     * @api
     */
    GeometryCollection.prototype.setGeometries = function (geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
    };
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    GeometryCollection.prototype.setGeometriesArray = function (geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
    };
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */
    GeometryCollection.prototype.applyTransform = function (transformFn) {
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            geometries[i].applyTransform(transformFn);
        }
        this.changed();
    };
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    GeometryCollection.prototype.translate = function (deltaX, deltaY) {
        var geometries = this.geometries_;
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
            geometries[i].translate(deltaX, deltaY);
        }
        this.changed();
    };
    /**
     * Clean up.
     */
    GeometryCollection.prototype.disposeInternal = function () {
        this.unlistenGeometriesChange_();
        _super.prototype.disposeInternal.call(this);
    };
    return GeometryCollection;
}(_Geometry_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]));
/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */
function cloneGeometries(geometries) {
    var clonedGeometries = [];
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
        clonedGeometries.push(geometries[i].clone());
    }
    return clonedGeometries;
}
/* harmony default export */ __webpack_exports__["a"] = (GeometryCollection);
//# sourceMappingURL=GeometryCollection.js.map

/***/ }),

/***/ "d3b7":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var redefine = __webpack_require__("6eeb");
var toString = __webpack_require__("b041");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "d44e":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("9bf2").f;
var hasOwn = __webpack_require__("1a2d");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "d4b4":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "d4c3":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");
var global = __webpack_require__("da84");

module.exports = /ipad|iphone|ipod/i.test(userAgent) && global.Pebble !== undefined;


/***/ }),

/***/ "d6d6":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

var TypeError = global.TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ "d784":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var uncurryThis = __webpack_require__("e330");
var redefine = __webpack_require__("6eeb");
var regexpExec = __webpack_require__("9263");
var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var createNonEnumerableProperty = __webpack_require__("9112");

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });

    redefine(String.prototype, KEY, methods[0]);
    redefine(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "d81d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $map = __webpack_require__("b727").map;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "d8e0":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "d9aa":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "d9b5":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var isCallable = __webpack_require__("1626");
var isPrototypeOf = __webpack_require__("3a9b");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var Object = global.Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));
};


/***/ }),

/***/ "da5c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/Disposable
 */
/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable = /** @class */ (function () {
    function Disposable() {
        /**
         * The object has already been disposed.
         * @type {boolean}
         * @protected
         */
        this.disposed = false;
    }
    /**
     * Clean up.
     */
    Disposable.prototype.dispose = function () {
        if (!this.disposed) {
            this.disposed = true;
            this.disposeInternal();
        }
    };
    /**
     * Extension point for disposable objects.
     * @protected
     */
    Disposable.prototype.disposeInternal = function () { };
    return Disposable;
}());
/* harmony default export */ __webpack_exports__["a"] = (Disposable);
//# sourceMappingURL=Disposable.js.map

/***/ }),

/***/ "da84":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "db05":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "dc07":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createOrUpdate; });
/**
 * @module ol/TileRange
 */
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange = /** @class */ (function () {
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     */
    function TileRange(minX, maxX, minY, maxY) {
        /**
         * @type {number}
         */
        this.minX = minX;
        /**
         * @type {number}
         */
        this.maxX = maxX;
        /**
         * @type {number}
         */
        this.minY = minY;
        /**
         * @type {number}
         */
        this.maxY = maxY;
    }
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */
    TileRange.prototype.contains = function (tileCoord) {
        return this.containsXY(tileCoord[1], tileCoord[2]);
    };
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */
    TileRange.prototype.containsTileRange = function (tileRange) {
        return (this.minX <= tileRange.minX &&
            tileRange.maxX <= this.maxX &&
            this.minY <= tileRange.minY &&
            tileRange.maxY <= this.maxY);
    };
    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */
    TileRange.prototype.containsXY = function (x, y) {
        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    };
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */
    TileRange.prototype.equals = function (tileRange) {
        return (this.minX == tileRange.minX &&
            this.minY == tileRange.minY &&
            this.maxX == tileRange.maxX &&
            this.maxY == tileRange.maxY);
    };
    /**
     * @param {TileRange} tileRange Tile range.
     */
    TileRange.prototype.extend = function (tileRange) {
        if (tileRange.minX < this.minX) {
            this.minX = tileRange.minX;
        }
        if (tileRange.maxX > this.maxX) {
            this.maxX = tileRange.maxX;
        }
        if (tileRange.minY < this.minY) {
            this.minY = tileRange.minY;
        }
        if (tileRange.maxY > this.maxY) {
            this.maxY = tileRange.maxY;
        }
    };
    /**
     * @return {number} Height.
     */
    TileRange.prototype.getHeight = function () {
        return this.maxY - this.minY + 1;
    };
    /**
     * @return {import("./size.js").Size} Size.
     */
    TileRange.prototype.getSize = function () {
        return [this.getWidth(), this.getHeight()];
    };
    /**
     * @return {number} Width.
     */
    TileRange.prototype.getWidth = function () {
        return this.maxX - this.minX + 1;
    };
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */
    TileRange.prototype.intersects = function (tileRange) {
        return (this.minX <= tileRange.maxX &&
            this.maxX >= tileRange.minX &&
            this.minY <= tileRange.maxY &&
            this.maxY >= tileRange.minY);
    };
    return TileRange;
}());
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
    if (tileRange !== undefined) {
        tileRange.minX = minX;
        tileRange.maxX = maxX;
        tileRange.minY = minY;
        tileRange.maxY = maxY;
        return tileRange;
    }
    else {
        return new TileRange(minX, maxX, minY, maxY);
    }
}
/* harmony default export */ __webpack_exports__["b"] = (TileRange);
//# sourceMappingURL=TileRange.js.map

/***/ }),

/***/ "dc4a":
/***/ (function(module, exports, __webpack_require__) {

var aCallable = __webpack_require__("59ed");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ "ddea":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return defaultFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return defaultFillStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultLineCap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return defaultLineDash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return defaultLineDashOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return defaultLineJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return defaultMiterLimit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return defaultStrokeStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return defaultTextAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return defaultTextBaseline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return defaultPadding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return defaultLineWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return checkedFonts; });
/* unused harmony export labelCache */
/* unused harmony export textHeights */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return registerFont; });
/* unused harmony export measureTextHeight */
/* unused harmony export measureTextWidth */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return measureAndCacheTextWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return getTextDimensions; });
/* unused harmony export rotateAtOffset */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return drawImageOrLabel; });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0ec0");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("617d");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0999");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("cd7e");
/**
 * @module ol/render/canvas
 */






/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle FillStyle.
 */
/**
 * @typedef Label
 * @property {number} width Width.
 * @property {number} height Height.
 * @property {Array<string|number>} contextInstructions ContextInstructions.
 */
/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle] Current FillStyle.
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle] Current StrokeStyle.
 * @property {CanvasLineCap} [currentLineCap] Current LineCap.
 * @property {Array<number>} currentLineDash Current LineDash.
 * @property {number} [currentLineDashOffset] Current LineDashOffset.
 * @property {CanvasLineJoin} [currentLineJoin] Current LineJoin.
 * @property {number} [currentLineWidth] Current LineWidth.
 * @property {number} [currentMiterLimit] Current MiterLimit.
 * @property {number} [lastStroke] Last stroke.
 * @property {import("../colorlike.js").ColorLike} [fillStyle] FillStyle.
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {CanvasLineCap} [lineCap] LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} [lineDashOffset] LineDashOffset.
 * @property {CanvasLineJoin} [lineJoin] LineJoin.
 * @property {number} [lineWidth] LineWidth.
 * @property {number} [miterLimit] MiterLimit.
 */
/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} lineWidth LineWidth.
 * @property {number} miterLimit MiterLimit.
 * @property {import("../colorlike.js").ColorLike} strokeStyle StrokeStyle.
 */
/**
 * @typedef {Object} TextState
 * @property {string} font Font.
 * @property {string} [textAlign] TextAlign.
 * @property {string} textBaseline TextBaseline.
 * @property {string} [placement] Placement.
 * @property {number} [maxAngle] MaxAngle.
 * @property {boolean} [overflow] Overflow.
 * @property {import("../style/Fill.js").default} [backgroundFill] BackgroundFill.
 * @property {import("../style/Stroke.js").default} [backgroundStroke] BackgroundStroke.
 * @property {import("../size.js").Size} [scale] Scale.
 * @property {Array<number>} [padding] Padding.
 */
/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */
/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */
/**
 * @const
 * @type {string}
 */
var defaultFont = '10px sans-serif';
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */
var defaultFillStyle = '#000';
/**
 * @const
 * @type {CanvasLineCap}
 */
var defaultLineCap = 'round';
/**
 * @const
 * @type {Array<number>}
 */
var defaultLineDash = [];
/**
 * @const
 * @type {number}
 */
var defaultLineDashOffset = 0;
/**
 * @const
 * @type {CanvasLineJoin}
 */
var defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */
var defaultMiterLimit = 10;
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */
var defaultStrokeStyle = '#000';
/**
 * @const
 * @type {string}
 */
var defaultTextAlign = 'center';
/**
 * @const
 * @type {string}
 */
var defaultTextBaseline = 'middle';
/**
 * @const
 * @type {Array<number>}
 */
var defaultPadding = [0, 0, 0, 0];
/**
 * @const
 * @type {number}
 */
var defaultLineWidth = 1;
/**
 * @type {BaseObject}
 */
var checkedFonts = new _Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]();
/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:ol/structs/LRUCache~LRUCache#setSize cache.setSize()}.
 * Deprecated - there is no label cache any more.
 * @type {?}
 * @api
 * @deprecated
 */
var labelCache = new _events_Target_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]();
labelCache.setSize = function () {
    console.warn('labelCache is deprecated.'); //eslint-disable-line
};
/**
 * @type {CanvasRenderingContext2D}
 */
var measureContext = null;
/**
 * @type {string}
 */
var measureFont;
/**
 * @type {!Object<string, number>}
 */
var textHeights = {};
/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
var registerFont = (function () {
    var retries = 100;
    var size = '32px ';
    var referenceFonts = ['monospace', 'serif'];
    var len = referenceFonts.length;
    var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
    var interval, referenceWidth;
    /**
     * @param {string} fontStyle Css font-style
     * @param {string} fontWeight Css font-weight
     * @param {*} fontFamily Css font-family
     * @return {boolean} Font with style and weight is available
     */
    function isAvailable(fontStyle, fontWeight, fontFamily) {
        var available = true;
        for (var i = 0; i < len; ++i) {
            var referenceFont = referenceFonts[i];
            referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
            if (fontFamily != referenceFont) {
                var width = measureTextWidth(fontStyle +
                    ' ' +
                    fontWeight +
                    ' ' +
                    size +
                    fontFamily +
                    ',' +
                    referenceFont, text);
                // If width and referenceWidth are the same, then the fallback was used
                // instead of the font we wanted, so the font is not available.
                available = available && width != referenceWidth;
            }
        }
        if (available) {
            return true;
        }
        return false;
    }
    function check() {
        var done = true;
        var fonts = checkedFonts.getKeys();
        for (var i = 0, ii = fonts.length; i < ii; ++i) {
            var font = fonts[i];
            if (checkedFonts.get(font) < retries) {
                if (isAvailable.apply(this, font.split('\n'))) {
                    Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[/* clear */ "b"])(textHeights);
                    // Make sure that loaded fonts are picked up by Safari
                    measureContext = null;
                    measureFont = undefined;
                    checkedFonts.set(font, retries);
                }
                else {
                    checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                    done = false;
                }
            }
        }
        if (done) {
            clearInterval(interval);
            interval = undefined;
        }
    }
    return function (fontSpec) {
        var font = Object(_css_js__WEBPACK_IMPORTED_MODULE_5__[/* getFontParameters */ "h"])(fontSpec);
        if (!font) {
            return;
        }
        var families = font.families;
        for (var i = 0, ii = families.length; i < ii; ++i) {
            var family = families[i];
            var key = font.style + '\n' + font.weight + '\n' + family;
            if (checkedFonts.get(key) === undefined) {
                checkedFonts.set(key, retries, true);
                if (!isAvailable(font.style, font.weight, family)) {
                    checkedFonts.set(key, 0, true);
                    if (interval === undefined) {
                        interval = setInterval(check, 32);
                    }
                }
            }
        }
    };
})();
/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */
var measureTextHeight = (function () {
    /**
     * @type {HTMLDivElement}
     */
    var measureElement;
    return function (fontSpec) {
        var height = textHeights[fontSpec];
        if (height == undefined) {
            if (_has_js__WEBPACK_IMPORTED_MODULE_2__[/* WORKER_OFFSCREEN_CANVAS */ "g"]) {
                var font = Object(_css_js__WEBPACK_IMPORTED_MODULE_5__[/* getFontParameters */ "h"])(fontSpec);
                var metrics = measureText(fontSpec, 'Žg');
                var lineHeight = isNaN(Number(font.lineHeight))
                    ? 1.2
                    : Number(font.lineHeight);
                height =
                    lineHeight *
                        (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
            }
            else {
                if (!measureElement) {
                    measureElement = document.createElement('div');
                    measureElement.innerHTML = 'M';
                    measureElement.style.minHeight = '0';
                    measureElement.style.maxHeight = 'none';
                    measureElement.style.height = 'auto';
                    measureElement.style.padding = '0';
                    measureElement.style.border = 'none';
                    measureElement.style.position = 'absolute';
                    measureElement.style.display = 'block';
                    measureElement.style.left = '-99999px';
                }
                measureElement.style.font = fontSpec;
                document.body.appendChild(measureElement);
                height = measureElement.offsetHeight;
                document.body.removeChild(measureElement);
            }
            textHeights[fontSpec] = height;
        }
        return height;
    };
})();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */
function measureText(font, text) {
    if (!measureContext) {
        measureContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[/* createCanvasContext2D */ "a"])(1, 1);
    }
    if (font != measureFont) {
        measureContext.font = font;
        measureFont = measureContext.font;
    }
    return measureContext.measureText(text);
}
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
    return measureText(font, text).width;
}
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */
function measureAndCacheTextWidth(font, text, cache) {
    if (text in cache) {
        return cache[text];
    }
    var width = measureTextWidth(font, text);
    cache[text] = width;
    return width;
}
/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */
function getTextDimensions(baseStyle, chunks) {
    var widths = [];
    var heights = [];
    var lineWidths = [];
    var width = 0;
    var lineWidth = 0;
    var height = 0;
    var lineHeight = 0;
    for (var i = 0, ii = chunks.length; i <= ii; i += 2) {
        var text = chunks[i];
        if (text === '\n' || i === ii) {
            width = Math.max(width, lineWidth);
            lineWidths.push(lineWidth);
            lineWidth = 0;
            height += lineHeight;
            continue;
        }
        var font = chunks[i + 1] || baseStyle.font;
        var currentWidth = measureTextWidth(font, text);
        widths.push(currentWidth);
        lineWidth += currentWidth;
        var currentHeight = measureTextHeight(font);
        heights.push(currentHeight);
        lineHeight = Math.max(lineHeight, currentHeight);
    }
    return { width: width, height: height, widths: widths, heights: heights, lineWidths: lineWidths };
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
    if (rotation !== 0) {
        context.translate(offsetX, offsetY);
        context.rotate(rotation);
        context.translate(-offsetX, -offsetY);
    }
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */
function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
    context.save();
    if (opacity !== 1) {
        context.globalAlpha *= opacity;
    }
    if (transform) {
        context.setTransform.apply(context, transform);
    }
    if ( /** @type {*} */(labelOrImage).contextInstructions) {
        // label
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        executeLabelInstructions(/** @type {Label} */ (labelOrImage), context);
    }
    else if (scale[0] < 0 || scale[1] < 0) {
        // flipped image
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        context.drawImage(
        /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, 0, 0, w, h);
    }
    else {
        // if image not flipped translate and scale can be avoided
        context.drawImage(
        /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
    }
    context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */
function executeLabelInstructions(label, context) {
    var contextInstructions = label.contextInstructions;
    for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
        if (Array.isArray(contextInstructions[i + 1])) {
            context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
        }
        else {
            context[contextInstructions[i]] = contextInstructions[i + 1];
        }
    }
}
//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "de0f":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAM3SURBVEhL7ZVbSNNRHMcnXTRDeoh668mHJr0o2moWS1FINnsp660gI8h5SdR0jrDZpiudrtyt3byg1kwlJ+TC0CxpeWF5QZ0oBr4svGSYTjB13/7n9KfHENz/zQ8czvn/v7/f+XJ+/3POn7fPbgkEAqEAjjHtEPuKOxiTg2bnUHGerutTurJ1/oa8cSld1fat0NT93tY5JGXDgo/21cenifktCBc9QohQjrCEEvDOyRCR+BgSeRssHQOZbGhwydS8meGdlyPikhzJ2Rakl7XipsKBoxdkCGXMi41dH9jQ4FKof9sXmlCKU2IligxdMLz+jHxtJ45clOHElQqo6nua2NDg0ujy5EXfsSIkOhf2zmGUGl1odH1FeOJDxEtr8e6L9xobGlyYnXz8rrrt5wFhMS7nWCG49QySXBtOpj5BTnXHLLP5DrOhwcfl8V1NuN/4m3daCt6ZbPD4WUiVOdanlwJn2ZDg0d3dfc9ut9ebzeZ6u/WFRdfg/BV724AwwQMkZtlgbupYMJv0JqIT+vr6rrOpe6OmpqZzY2MD29vb2NraYioK/PDvwD3xHf6/j9jZ2aH68vIyNBrNczZ1b+h0updkUgLprVYLGurssFuMqK+1wWg0wu/3U311dRWVlZVqNnVvEOPNzU068cLCAmJjY1FSUgI+n097gUAAr9dL9ZWVFe6M4+PjSTlpX1VVBZFIhKmpKapzZkxKKpfLyeTUWK1Wo6ioCIuLi1TnzHh9fR0Gg4GuVCgUory8HIxOK0HgzHh4mLmxSkuhUCgQFxdHV0/GzBGiOmfGPp8PHo8Ho6OjmJ6extjYGB3Pz89TndNvTMz6+/vpTu7t7cXAwMC/882Z8dzcHFJSUlBWVgaxWAyTyYSkpCT09PRQnTPjkZERaiiVSpGRkQHmVoNEIoHb7aY6p6WOiopCcnIy9Ho90tLSUFBQgJmZGapzZsz8MBAZGUmPESl3TEwMHc/Okr8ih8Zra2vUqLm5GXV1dfRIKZVKjI+PU50zY8Lg4CDa29uh1WqhUqno9cnJN66urm6ns+4CcrMx12gVm7o3mNVVtLS0TDocjon/NSaGtEmn05nLpu7DwuP9AWguY1cSHdaJAAAAAElFTkSuQmCC"

/***/ }),

/***/ "df4c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/layer/Property
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    OPACITY: 'opacity',
    VISIBLE: 'visible',
    EXTENT: 'extent',
    Z_INDEX: 'zIndex',
    MAX_RESOLUTION: 'maxResolution',
    MIN_RESOLUTION: 'minResolution',
    MAX_ZOOM: 'maxZoom',
    MIN_ZOOM: 'minZoom',
    SOURCE: 'source',
    MAP: 'map',
});
//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "df75":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "e25d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAFu0lEQVR4nIWWfWzV5RXHP+e+9Lbee/vea5X2try0RQq2oTAgpaWpYlF0KYyhYYwtK/LWocnSmaghGp1zkxiiZJPAMJCpNcO0JKzUyHTMQtCVt1oL5ZbKS0tfvb30cvt+e8/+6O92lVV3kpP8nuf3PN/zfb7nPOf3k1AoBICIYFgJsP7O0OiSxuvfpp5t7Y1u997haqcfsZhVBBTQsXFJdzlxJzpYODPJv2BmYlucI/JL4AjwMYCqIqoaBt4MvPTuiaaUA7WNXO4dID4hlrTUBO6Ps5Odnki8IxKYCNB3Z5hLN7x0+gJ80+bF2+tjVlwkW0rms+2JnHYz8jJwMBxg99nWnoqSig9xJMZT/lQ+jycrro4W5GYrfo+HgMdDoLvXgBccyS4cGRlEZ2YScs+mN3UuNR0h9laextveQ9Xr6yjJdb8pqvp09+3B/cnr/8TLO1axK8/B5d+/RkvVUfp6vASBsHgmwxUYN+YUsADxrgQyflLKvOdf5NXzAV7641Eu/a0cUdXL2/d9NrfZF+SfZRm8786if2SMewAzEAKG+a/ZjPmwDRtrbMAQ4IywsLH7OkvfukhWrBWTqjo8XX7dtCpHG7eUq39kTJ2gZtAx0BBozs6duq6+XjdcvaqJeXk6auR5ADSjtFQL9+zRcVA7qH80qJd2PKObVi/Sdt+gmoAes9Uq315vx9fSgs1gFgQioqMpbWhg6dtvY3O5UFVGvV4w2C595RWKqquZs3kzQeMkEUDv+YtIIIDZahWLiFxJS3IuNNtsYo6ImKAGjAGPVldzT2oq77tcdPX2YgbsQKRBoOvMGXyNjUQmJU3mSQGnO4WOgSDzU+NCJlXdvWx24lhnyKqJOQ/quCFNYlqaJhcXq9/j0RXvvafbb97UtVVV6l6xQodBLaAttbXa39ysFodDARVQBU3Ky9OGNp8+cF+MzyQiF4qyZ7Q2t/WJZVaGCEgQJC43VwCJz80Vs80mnadPiys/X0pOnpQ5a9bIMIgVxGSziYZCYhSbmEA0M1u6+gKyMif1KwvArOSYT0eHhuZ2PbgcOxAAhjs7Afi4oICG+nqsgBUoDwSYX1HBlepqJlGNLjAOxACXkudh6+gn3RV91GJI99clKTHlp6IcFCzI5OtGD13nzuH3eFj1+edk19QQCoWIzczEarfTtGcPZgPQGh2N1elEgVEga2UBe/vtPDbPBnDEZAT4cutDWU0nWm9z3y/KJhI9Ps6xxYu5VllJcmEhM4qLGevv5+STT+L56CNsxgW7dfw4rYcPYzEuYcympzl1pZtfFWUdAzplSrPbunFf3b612YlqL11CR98dMKppslsZIJFTxiNGeZqBB7LS+eqdT/iiuUMObV9RqKp1pilrD1aUZHX/pXlAFvzmWUYMhpFTPOoucIy6jzTkynhhF2/V3ZDnVs+/ANQBmEQknKRg7kzXawnBQU4VbZLMlHtlGESMyjAZz9zlAjIEsmhprhy4d7nkxArz3AnPGKowKVF4ouf2wLUnDp5PP3J/m57Y8LNJbb/PxpnoQ4vrzvBwjVcuvFD8jzhn1MrwZ2DyBOFSc8XaNz6eFsXuqIWysmyDDExhq1M8PB4EWb33DdlyEXm+yE2cM+qXk+xFpiV3ete6RQebmq5xZtsfyC9cjD98wikeAvzA+t/u4I2MtUT0e9lasmAHcOs7aKo6nUu3L9A898W/a2tbr9YXLdM/gx4AfRd0v+E3d5bp4fpbmvLrSh0LBiunw/q+AKhqxmcNN0Zit32gn5z9Rjv3vqn/fuxhrVuWpw0bf6r9x6r09dpmdZUd0m5foF5VrdPhfCfJd5uILLvWdfvEj1+tsc+YNYNHfjSbaLuN6139VH36NW5biOO/W3PeZDLlq+rwtBg/FMAIMgfY/8G/rhTUnrthGRwZU1d0lKxbPsf/UI77EPDslB+H/93/Qy/vsp8DW5m4Vx3Ac0Dz/9v0HyM5szdAJ9rJAAAAAElFTkSuQmCC"

/***/ }),

/***/ "e269":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ObjectEvent */
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cef7");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7b4f");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("35a7");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("1300");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Object
 */





/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
var ObjectEvent = /** @class */ (function (_super) {
    __extends(ObjectEvent, _super);
    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */
    function ObjectEvent(type, key, oldValue) {
        var _this = _super.call(this, type) || this;
        /**
         * The name of the property whose value is changing.
         * @type {string}
         * @api
         */
        _this.key = key;
        /**
         * The old value. To get the new value use `e.target.get(e.key)` where
         * `e` is the event object.
         * @type {*}
         * @api
         */
        _this.oldValue = oldValue;
        return _this;
    }
    return ObjectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
var BaseObject = /** @class */ (function (_super) {
    __extends(BaseObject, _super);
    /**
     * @param {Object<string, *>} [opt_values] An object with key-value pairs.
     */
    function BaseObject(opt_values) {
        var _this = _super.call(this) || this;
        /***
         * @type {ObjectOnSignature<import("./events").EventsKey>}
         */
        _this.on;
        /***
         * @type {ObjectOnSignature<import("./events").EventsKey>}
         */
        _this.once;
        /***
         * @type {ObjectOnSignature<void>}
         */
        _this.un;
        // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
        // the same as the order in which they were created.  This also helps to
        // ensure that object properties are always added in the same order, which
        // helps many JavaScript engines generate faster code.
        Object(_util_js__WEBPACK_IMPORTED_MODULE_4__[/* getUid */ "c"])(_this);
        /**
         * @private
         * @type {Object<string, *>}
         */
        _this.values_ = null;
        if (opt_values !== undefined) {
            _this.setProperties(opt_values);
        }
        return _this;
    }
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */
    BaseObject.prototype.get = function (key) {
        var value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
            value = this.values_[key];
        }
        return value;
    };
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */
    BaseObject.prototype.getKeys = function () {
        return (this.values_ && Object.keys(this.values_)) || [];
    };
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */
    BaseObject.prototype.getProperties = function () {
        return (this.values_ && Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[/* assign */ "a"])({}, this.values_)) || {};
    };
    /**
     * @return {boolean} The object has properties.
     */
    BaseObject.prototype.hasProperties = function () {
        return !!this.values_;
    };
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */
    BaseObject.prototype.notify = function (key, oldValue) {
        var eventType;
        eventType = "change:".concat(key);
        if (this.hasListener(eventType)) {
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
    };
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    BaseObject.prototype.addChangeListener = function (key, listener) {
        this.addEventListener("change:".concat(key), listener);
    };
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    BaseObject.prototype.removeChangeListener = function (key, listener) {
        this.removeEventListener("change:".concat(key), listener);
    };
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [opt_silent] Update without triggering an event.
     * @api
     */
    BaseObject.prototype.set = function (key, value, opt_silent) {
        var values = this.values_ || (this.values_ = {});
        if (opt_silent) {
            values[key] = value;
        }
        else {
            var oldValue = values[key];
            values[key] = value;
            if (oldValue !== value) {
                this.notify(key, oldValue);
            }
        }
    };
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [opt_silent] Update without triggering an event.
     * @api
     */
    BaseObject.prototype.setProperties = function (values, opt_silent) {
        for (var key in values) {
            this.set(key, values[key], opt_silent);
        }
    };
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */
    BaseObject.prototype.applyProperties = function (source) {
        if (!source.values_) {
            return;
        }
        Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[/* assign */ "a"])(this.values_ || (this.values_ = {}), source.values_);
    };
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [opt_silent] Unset without triggering an event.
     * @api
     */
    BaseObject.prototype.unset = function (key, opt_silent) {
        if (this.values_ && key in this.values_) {
            var oldValue = this.values_[key];
            delete this.values_[key];
            if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__[/* isEmpty */ "d"])(this.values_)) {
                this.values_ = null;
            }
            if (!opt_silent) {
                this.notify(key, oldValue);
            }
        }
    };
    return BaseObject;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (BaseObject);
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "e2cc":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("6eeb");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "e300":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CollectionEvent */
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("835b");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("e269");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("183a");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("cef7");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Collection
 */




/**
 * @enum {string}
 * @private
 */
var Property = {
    LENGTH: 'length',
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */
var CollectionEvent = /** @class */ (function (_super) {
    __extends(CollectionEvent, _super);
    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {*} [opt_element] Element.
     * @param {number} [opt_index] The index of the added or removed element.
     */
    function CollectionEvent(type, opt_element, opt_index) {
        var _this = _super.call(this, type) || this;
        /**
         * The element that is added to or removed from the collection.
         * @type {*}
         * @api
         */
        _this.element = opt_element;
        /**
         * The index of the added or removed element.
         * @type {number}
         * @api
         */
        _this.index = opt_index;
        return _this;
    }
    return CollectionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]));

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */
/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
var Collection = /** @class */ (function (_super) {
    __extends(Collection, _super);
    /**
     * @param {Array<T>} [opt_array] Array.
     * @param {Options} [opt_options] Collection options.
     */
    function Collection(opt_array, opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {CollectionOnSignature<import("./events").EventsKey>}
         */
        _this.on;
        /***
         * @type {CollectionOnSignature<import("./events").EventsKey>}
         */
        _this.once;
        /***
         * @type {CollectionOnSignature<void>}
         */
        _this.un;
        var options = opt_options || {};
        /**
         * @private
         * @type {boolean}
         */
        _this.unique_ = !!options.unique;
        /**
         * @private
         * @type {!Array<T>}
         */
        _this.array_ = opt_array ? opt_array : [];
        if (_this.unique_) {
            for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                _this.assertUnique_(_this.array_[i], i);
            }
        }
        _this.updateLength_();
        return _this;
    }
    /**
     * Remove all elements from the collection.
     * @api
     */
    Collection.prototype.clear = function () {
        while (this.getLength() > 0) {
            this.pop();
        }
    };
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */
    Collection.prototype.extend = function (arr) {
        for (var i = 0, ii = arr.length; i < ii; ++i) {
            this.push(arr[i]);
        }
        return this;
    };
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */
    Collection.prototype.forEach = function (f) {
        var array = this.array_;
        for (var i = 0, ii = array.length; i < ii; ++i) {
            f(array[i], i, array);
        }
    };
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */
    Collection.prototype.getArray = function () {
        return this.array_;
    };
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */
    Collection.prototype.item = function (index) {
        return this.array_[index];
    };
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */
    Collection.prototype.getLength = function () {
        return this.get(Property.LENGTH);
    };
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    Collection.prototype.insertAt = function (index, elem) {
        if (this.unique_) {
            this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ADD, elem, index));
    };
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */
    Collection.prototype.pop = function () {
        return this.removeAt(this.getLength() - 1);
    };
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */
    Collection.prototype.push = function (elem) {
        if (this.unique_) {
            this.assertUnique_(elem);
        }
        var n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
    };
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */
    Collection.prototype.remove = function (elem) {
        var arr = this.array_;
        for (var i = 0, ii = arr.length; i < ii; ++i) {
            if (arr[i] === elem) {
                return this.removeAt(i);
            }
        }
        return undefined;
    };
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */
    Collection.prototype.removeAt = function (index) {
        var prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].REMOVE, prev, index));
        return prev;
    };
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    Collection.prototype.setAt = function (index, elem) {
        var n = this.getLength();
        if (index < n) {
            if (this.unique_) {
                this.assertUnique_(elem, index);
            }
            var prev = this.array_[index];
            this.array_[index] = elem;
            this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].REMOVE, prev, index));
            this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ADD, elem, index));
        }
        else {
            for (var j = n; j < index; ++j) {
                this.insertAt(j, undefined);
            }
            this.insertAt(index, elem);
        }
    };
    /**
     * @private
     */
    Collection.prototype.updateLength_ = function () {
        this.set(Property.LENGTH, this.array_.length);
    };
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [opt_except] Optional index to ignore.
     */
    Collection.prototype.assertUnique_ = function (elem, opt_except) {
        for (var i = 0, ii = this.array_.length; i < ii; ++i) {
            if (this.array_[i] === elem && i !== opt_except) {
                throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](58);
            }
        }
    };
    return Collection;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (Collection);
//# sourceMappingURL=Collection.js.map

/***/ }),

/***/ "e330":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__("40d5");

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "e46e":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "e575":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track09.a3e2d5b7.png";

/***/ }),

/***/ "e637":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/MapProperty
 */
/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    LAYERGROUP: 'layergroup',
    SIZE: 'size',
    TARGET: 'target',
    VIEW: 'view',
});
//# sourceMappingURL=MapProperty.js.map

/***/ }),

/***/ "e667":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "e6cf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IS_PURE = __webpack_require__("c430");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var call = __webpack_require__("c65b");
var NativePromise = __webpack_require__("fea9");
var redefine = __webpack_require__("6eeb");
var redefineAll = __webpack_require__("e2cc");
var setPrototypeOf = __webpack_require__("d2bb");
var setToStringTag = __webpack_require__("d44e");
var setSpecies = __webpack_require__("2626");
var aCallable = __webpack_require__("59ed");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var anInstance = __webpack_require__("19aa");
var inspectSource = __webpack_require__("8925");
var iterate = __webpack_require__("2266");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var speciesConstructor = __webpack_require__("4840");
var task = __webpack_require__("2cf4").set;
var microtask = __webpack_require__("b575");
var promiseResolve = __webpack_require__("cdf9");
var hostReportErrors = __webpack_require__("44de");
var newPromiseCapabilityModule = __webpack_require__("f069");
var perform = __webpack_require__("e667");
var Queue = __webpack_require__("01b4");
var InternalStateModule = __webpack_require__("69f3");
var isForced = __webpack_require__("94ca");
var wellKnownSymbol = __webpack_require__("b622");
var IS_BROWSER = __webpack_require__("6069");
var IS_NODE = __webpack_require__("605d");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';

var getInternalState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var NativePromisePrototype = NativePromise && NativePromise.prototype;
var PromiseConstructor = NativePromise;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;

var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var SUBCLASSING = false;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromisePrototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = new PromiseConstructor(function (resolve) { resolve(1); });
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
  if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && isCallable(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call(then, value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    call(Internal, this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromisePrototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    // eslint-disable-next-line unicorn/no-thenable -- safe
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable(onRejected) && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      if (state.state == PENDING) state.reactions.add(reaction);
      else microtask(function () {
        callReaction(reaction, state);
      });
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;

    if (!SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });

      // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
      redefine(NativePromisePrototype, 'catch', PromisePrototype['catch'], { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    call(capability.reject, undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function (promise) {
        call($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "e83d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "e893":
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__("1a2d");
var ownKeys = __webpack_require__("56ef");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "e8b5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ "e95a":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "e98d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return asColorLike; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5c38");
/**
 * @module ol/colorlike
 */

/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */
/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
    if (Array.isArray(color)) {
        return Object(_color_js__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "c"])(color);
    }
    else {
        return color;
    }
}
//# sourceMappingURL=colorlike.js.map

/***/ }),

/***/ "ec50":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "ed88":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "ed8b":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "eeb0":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAMnSURBVEhL7ZVfSFpRHMeDYA+DPfc4WAT1GEWsHmJRD1FPg8Zet7eSBnsQYm6EkSas1M0yKzNro6Yxyf5CLs0WhWbOdPlnthatJstZrKXZn6vfnXt2n0eg960P3HsO9/s753t/59zzuznXXBUAuYHYzt10On2be8Q/xOzWoHvKMeydRt8nc9y973/ISfyx+HX9kcSudcxE1kjSQBwMRLa+hM4zLScvlMeFZZfZ4MfHhh07nJFNTMxOpsxm86+3I29SM2s2LB36oXGYVsi73ODCs8erlXdTe8wRzfRJc3MqLy9vOT8//2xhzkKfqZzjSCaTd7jw7GH8bBWOha2I/jnE82ciFBQUbBYWFh4uWm3w/d6BasXgJ/43ufDsQSbNldr1X9yREMQvWtHcKPhRda8q+WHegqGteax+993nQrOPet20sJP4ifQ5g2+xfZyfnwNMGjrfHLOXPivgwrKDxWJp1Ol0wz09PUPjsxOBXpcJetcEZEsj6YF1M/o/mTFke382pB0cGybY7fYH3NDMUKlUU6enp2AYBhdJkiEhjn8tS4q9McAFyT4Wi6Grq+s1NzQzuru7x1hTOj9p+/v7oRsYhFKhgHZAC426FycnJ1Q/Pj5GZ2enjBuaGawx3UvCwcEBSkpK0NraCvJF07asrAzBYJDqR0dH/BlXVFSwy0lbuVyOyspKBAIBqvNmnEgkIBKJ2MmpsUwmQ0tLC6LRKNV5M47H41Cr1TTT8vJydHR0gOh0JVh4M3a5XGhra4NYLEZpaSnNnu2TI0R13owjkQjcbjc2NjYQCoXg9Xppf3d3l+q87jFrtry8TL9km80Gh8OBy8tLqvNmvL29jdraWkilUtTV1UGj0aC6uhpWq5XqvBl7PB5qKBAI0NTUBFLVUF9fj9XVVarzutRFRUWoqakBqd1oaGiAUChEOBymOm/G5IcB8vOnx4hd7uLiYtrf2tqiOm/GbE1mjUZHR6HX6+mRam9vh8/nozpvxixOpxMmkwlKpRISiYSWT172WKFQmOisV4CtbKSMyrmhmUGye2k0Gv0Gg2HzfxeJYS//5OTkU27oNRw5OX8B3dqSJw+GN2cAAAAASUVORK5CYII="

/***/ }),

/***/ "eef5":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "f069":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aCallable = __webpack_require__("59ed");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "f36a":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "f403":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f623");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9abc");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0af5");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("abb7");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("7fc9");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/Point
 */





/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point = /** @class */ (function (_super) {
    __extends(Point, _super);
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */
    function Point(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        _this.setCoordinates(coordinates, opt_layout);
        return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     */
    Point.prototype.clone = function () {
        var point = new Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        var flatCoordinates = this.flatCoordinates;
        var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__[/* squaredDistance */ "i"])(x, y, flatCoordinates[0], flatCoordinates[1]);
        if (squaredDistance < minSquaredDistance) {
            var stride = this.stride;
            for (var i = 0; i < stride; ++i) {
                closestPoint[i] = flatCoordinates[i];
            }
            closestPoint.length = stride;
            return squaredDistance;
        }
        else {
            return minSquaredDistance;
        }
    };
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     */
    Point.prototype.getCoordinates = function () {
        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    Point.prototype.computeExtent = function (extent) {
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* createOrUpdateFromCoordinate */ "m"])(this.flatCoordinates, extent);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    Point.prototype.getType = function () {
        return _GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINT;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    Point.prototype.intersectsExtent = function (extent) {
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* containsXY */ "h"])(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    };
    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */
    Point.prototype.setCoordinates = function (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 0);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__[/* deflateCoordinate */ "a"])(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return Point;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]));
/* harmony default export */ __webpack_exports__["a"] = (Point);
//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "f534":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "f5dd":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fced");
/**
 * @module ol/proj/Projection
 */

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution getPointResolution()} function will be used.
 */
/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */
var Projection = /** @class */ (function () {
    /**
     * @param {Options} options Projection options.
     */
    function Projection(options) {
        /**
         * @private
         * @type {string}
         */
        this.code_ = options.code;
        /**
         * Units of projected coordinates. When set to `TILE_PIXELS`, a
         * `this.extent_` and `this.worldExtent_` must be configured properly for each
         * tile.
         * @private
         * @type {import("./Units.js").default}
         */
        this.units_ = /** @type {import("./Units.js").default} */ (options.units);
        /**
         * Validity extent of the projection in projected coordinates. For projections
         * with `TILE_PIXELS` units, this is the extent of the tile in
         * tile pixel space.
         * @private
         * @type {import("../extent.js").Extent}
         */
        this.extent_ = options.extent !== undefined ? options.extent : null;
        /**
         * Extent of the world in EPSG:4326. For projections with
         * `TILE_PIXELS` units, this is the extent of the tile in
         * projected coordinate space.
         * @private
         * @type {import("../extent.js").Extent}
         */
        this.worldExtent_ =
            options.worldExtent !== undefined ? options.worldExtent : null;
        /**
         * @private
         * @type {string}
         */
        this.axisOrientation_ =
            options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
        /**
         * @private
         * @type {boolean}
         */
        this.global_ = options.global !== undefined ? options.global : false;
        /**
         * @private
         * @type {boolean}
         */
        this.canWrapX_ = !!(this.global_ && this.extent_);
        /**
         * @private
         * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
         */
        this.getPointResolutionFunc_ = options.getPointResolution;
        /**
         * @private
         * @type {import("../tilegrid/TileGrid.js").default}
         */
        this.defaultTileGrid_ = null;
        /**
         * @private
         * @type {number|undefined}
         */
        this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    Projection.prototype.canWrapX = function () {
        return this.canWrapX_;
    };
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    Projection.prototype.getCode = function () {
        return this.code_;
    };
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    Projection.prototype.getExtent = function () {
        return this.extent_;
    };
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").default} Units.
     * @api
     */
    Projection.prototype.getUnits = function () {
        return this.units_;
    };
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    Projection.prototype.getMetersPerUnit = function () {
        return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__[/* METERS_PER_UNIT */ "a"][this.units_];
    };
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    Projection.prototype.getWorldExtent = function () {
        return this.worldExtent_;
    };
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    Projection.prototype.getAxisOrientation = function () {
        return this.axisOrientation_;
    };
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    Projection.prototype.isGlobal = function () {
        return this.global_;
    };
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    Projection.prototype.setGlobal = function (global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
    };
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
    Projection.prototype.getDefaultTileGrid = function () {
        return this.defaultTileGrid_;
    };
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
    Projection.prototype.setDefaultTileGrid = function (tileGrid) {
        this.defaultTileGrid_ = tileGrid;
    };
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    Projection.prototype.setExtent = function (extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
    };
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
    Projection.prototype.setWorldExtent = function (worldExtent) {
        this.worldExtent_ = worldExtent;
    };
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
    Projection.prototype.setGetPointResolution = function (func) {
        this.getPointResolutionFunc_ = func;
    };
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
    Projection.prototype.getPointResolutionFunc = function () {
        return this.getPointResolutionFunc_;
    };
    return Projection;
}());
/* harmony default export */ __webpack_exports__["a"] = (Projection);
//# sourceMappingURL=Projection.js.map

/***/ }),

/***/ "f5df":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var isCallable = __webpack_require__("1626");
var classofRaw = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var Object = global.Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "f623":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @module ol/geom/GeometryType
 */
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
    POINT: 'Point',
    LINE_STRING: 'LineString',
    LINEAR_RING: 'LinearRing',
    POLYGON: 'Polygon',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon',
    GEOMETRY_COLLECTION: 'GeometryCollection',
    CIRCLE: 'Circle',
});
//# sourceMappingURL=GeometryType.js.map

/***/ }),

/***/ "f6f4":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "f721":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "f75d":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "f772":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5692");
var uid = __webpack_require__("90e3");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "f822":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f623");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9abc");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0af5");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("abb7");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("bef8");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/geom/Circle
 */





/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
var Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    /**
     * @param {!import("../coordinate.js").Coordinate} center Center.
     *     For internal use, flat coordinates in combination with `opt_layout` and no
     *     `opt_radius` are also accepted.
     * @param {number} [opt_radius] Radius.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */
    function Circle(center, opt_radius, opt_layout) {
        var _this = _super.call(this) || this;
        if (opt_layout !== undefined && opt_radius === undefined) {
            _this.setFlatCoordinates(opt_layout, center);
        }
        else {
            var radius = opt_radius ? opt_radius : 0;
            _this.setCenterAndRadius(center, radius, opt_layout);
        }
        return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Circle} Clone.
     * @api
     */
    Circle.prototype.clone = function () {
        var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);
        circle.applyProperties(this);
        return circle;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
        var flatCoordinates = this.flatCoordinates;
        var dx = x - flatCoordinates[0];
        var dy = y - flatCoordinates[1];
        var squaredDistance = dx * dx + dy * dy;
        if (squaredDistance < minSquaredDistance) {
            if (squaredDistance === 0) {
                for (var i = 0; i < this.stride; ++i) {
                    closestPoint[i] = flatCoordinates[i];
                }
            }
            else {
                var delta = this.getRadius() / Math.sqrt(squaredDistance);
                closestPoint[0] = flatCoordinates[0] + delta * dx;
                closestPoint[1] = flatCoordinates[1] + delta * dy;
                for (var i = 2; i < this.stride; ++i) {
                    closestPoint[i] = flatCoordinates[i];
                }
            }
            closestPoint.length = this.stride;
            return squaredDistance;
        }
        else {
            return minSquaredDistance;
        }
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    Circle.prototype.containsXY = function (x, y) {
        var flatCoordinates = this.flatCoordinates;
        var dx = x - flatCoordinates[0];
        var dy = y - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
    };
    /**
     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @return {import("../coordinate.js").Coordinate} Center.
     * @api
     */
    Circle.prototype.getCenter = function () {
        return this.flatCoordinates.slice(0, this.stride);
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    Circle.prototype.computeExtent = function (extent) {
        var flatCoordinates = this.flatCoordinates;
        var radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* createOrUpdate */ "k"])(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
    };
    /**
     * Return the radius of the circle.
     * @return {number} Radius.
     * @api
     */
    Circle.prototype.getRadius = function () {
        return Math.sqrt(this.getRadiusSquared_());
    };
    /**
     * @private
     * @return {number} Radius squared.
     */
    Circle.prototype.getRadiusSquared_ = function () {
        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */
    Circle.prototype.getType = function () {
        return _GeometryType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].CIRCLE;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    Circle.prototype.intersectsExtent = function (extent) {
        var circleExtent = this.getExtent();
        if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* intersects */ "E"])(extent, circleExtent)) {
            var center = this.getCenter();
            if (extent[0] <= center[0] && extent[2] >= center[0]) {
                return true;
            }
            if (extent[1] <= center[1] && extent[3] >= center[1]) {
                return true;
            }
            return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__[/* forEachCorner */ "s"])(extent, this.intersectsCoordinate.bind(this));
        }
        return false;
    };
    /**
     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @api
     */
    Circle.prototype.setCenter = function (center) {
        var stride = this.stride;
        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        var flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for (var i = 1; i < stride; ++i) {
            flatCoordinates[stride + i] = center[i];
        }
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
    };
    /**
     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
     * number) of the circle.
     * @param {!import("../coordinate.js").Coordinate} center Center.
     * @param {number} radius Radius.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */
    Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {
        this.setLayout(opt_layout, center, 0);
        if (!this.flatCoordinates) {
            this.flatCoordinates = [];
        }
        /** @type {Array<number>} */
        var flatCoordinates = this.flatCoordinates;
        var offset = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__[/* deflateCoordinate */ "a"])(flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset++] = flatCoordinates[0] + radius;
        for (var i = 1, ii = this.stride; i < ii; ++i) {
            flatCoordinates[offset++] = flatCoordinates[i];
        }
        flatCoordinates.length = offset;
        this.changed();
    };
    Circle.prototype.getCoordinates = function () {
        return null;
    };
    Circle.prototype.setCoordinates = function (coordinates, opt_layout) { };
    /**
     * Set the radius of the circle. The radius is in the units of the projection.
     * @param {number} radius Radius.
     * @api
     */
    Circle.prototype.setRadius = function (radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
    };
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    Circle.prototype.rotate = function (angle, anchor) {
        var center = this.getCenter();
        var stride = this.getStride();
        this.setCenter(Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* rotate */ "a"])(center, 0, center.length, stride, angle, anchor, center));
        this.changed();
    };
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    Circle.prototype.translate = function (deltaX, deltaY) {
        var center = this.getCenter();
        var stride = this.getStride();
        this.setCenter(Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* translate */ "d"])(center, 0, center.length, stride, deltaX, deltaY, center));
        this.changed();
    };
    return Circle;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]));
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */
Circle.prototype.transform;
/* harmony default export */ __webpack_exports__["a"] = (Circle);
//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var setPublicPath_src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (setPublicPath_src) {
    __webpack_require__.p = setPublicPath_src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.values.js
var es_object_values = __webpack_require__("07ac");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("e6cf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("498a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__("1276");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__("466d");

// EXTERNAL MODULE: ./src/styles/wg-ol.css
var wg_ol = __webpack_require__("7e6d");

// EXTERNAL MODULE: ./node_modules/ol/Map.js + 8 modules
var Map = __webpack_require__("5eee");

// EXTERNAL MODULE: ./node_modules/ol/View.js + 3 modules
var View = __webpack_require__("a2c7");

// EXTERNAL MODULE: ./node_modules/ol/Feature.js
var Feature = __webpack_require__("4cdf");

// EXTERNAL MODULE: ./node_modules/ol/layer/Tile.js + 3 modules
var Tile = __webpack_require__("480c");

// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js
var Layer = __webpack_require__("1af9");

// CONCATENATED MODULE: ./node_modules/ol/layer/BaseImage.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/BaseImage
 */

/**
 * @template {import("../source/Image.js").default} ImageSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {ImageSourceType} [source] Source for this layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<ImageSourceType, RendererType>}
 * @api
 */
var BaseImageLayer = /** @class */ (function (_super) {
    __extends(BaseImageLayer, _super);
    /**
     * @param {Options<ImageSourceType>} [opt_options] Layer options.
     */
    function BaseImageLayer(opt_options) {
        var options = opt_options ? opt_options : {};
        return _super.call(this, options) || this;
    }
    return BaseImageLayer;
}(Layer["a" /* default */]));
/* harmony default export */ var BaseImage = (BaseImageLayer);
//# sourceMappingURL=BaseImage.js.map
// EXTERNAL MODULE: ./node_modules/ol/renderer/canvas/Layer.js + 1 modules
var canvas_Layer = __webpack_require__("137e");

// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js
var ViewHint = __webpack_require__("496f");

// EXTERNAL MODULE: ./node_modules/ol/reproj/common.js
var common = __webpack_require__("a504");

// EXTERNAL MODULE: ./node_modules/ol/renderer/canvas/common.js
var canvas_common = __webpack_require__("0b0e");

// EXTERNAL MODULE: ./node_modules/ol/transform.js
var ol_transform = __webpack_require__("a896");

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var ol_obj = __webpack_require__("38f3");

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__("0af5");

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules
var ol_proj = __webpack_require__("256f");

// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/ImageLayer.js
var ImageLayer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/renderer/canvas/ImageLayer
 */








/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var ImageLayer_CanvasImageLayerRenderer = /** @class */ (function (_super) {
    ImageLayer_extends(CanvasImageLayerRenderer, _super);
    /**
     * @param {import("../../layer/Image.js").default} imageLayer Image layer.
     */
    function CanvasImageLayerRenderer(imageLayer) {
        var _this = _super.call(this, imageLayer) || this;
        /**
         * @protected
         * @type {?import("../../ImageBase.js").default}
         */
        _this.image_ = null;
        return _this;
    }
    /**
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     */
    CanvasImageLayerRenderer.prototype.getImage = function () {
        return !this.image_ ? null : this.image_.getImage();
    };
    /**
     * Determine whether render should be called.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        var pixelRatio = frameState.pixelRatio;
        var viewState = frameState.viewState;
        var viewResolution = viewState.resolution;
        var imageSource = this.getLayer().getSource();
        var hints = frameState.viewHints;
        var renderedExtent = frameState.extent;
        if (layerState.extent !== undefined) {
            renderedExtent = Object(ol_extent["A" /* getIntersection */])(renderedExtent, Object(ol_proj["k" /* fromUserExtent */])(layerState.extent, viewState.projection));
        }
        if (!hints[ViewHint["a" /* default */].ANIMATING] &&
            !hints[ViewHint["a" /* default */].INTERACTING] &&
            !Object(ol_extent["G" /* isEmpty */])(renderedExtent)) {
            if (imageSource) {
                var projection = viewState.projection;
                if (!common["a" /* ENABLE_RASTER_REPROJECTION */]) {
                    var sourceProjection = imageSource.getProjection();
                    if (sourceProjection) {
                        projection = sourceProjection;
                    }
                }
                var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
                if (image && this.loadImage(image)) {
                    this.image_ = image;
                }
                else {
                    this.image_ = null;
                }
            }
            else {
                this.image_ = null;
            }
        }
        return !!this.image_;
    };
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     */
    CanvasImageLayerRenderer.prototype.getData = function (pixel) {
        var frameState = this.frameState;
        if (!frameState) {
            return null;
        }
        var layer = this.getLayer();
        var coordinate = Object(ol_transform["a" /* apply */])(frameState.pixelToCoordinateTransform, pixel.slice());
        var layerExtent = layer.getExtent();
        if (layerExtent) {
            if (!Object(ol_extent["f" /* containsCoordinate */])(layerExtent, coordinate)) {
                return null;
            }
        }
        var imageExtent = this.image_.getExtent();
        var img = this.image_.getImage();
        var imageMapWidth = Object(ol_extent["D" /* getWidth */])(imageExtent);
        var col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));
        if (col < 0 || col >= img.width) {
            return null;
        }
        var imageMapHeight = Object(ol_extent["z" /* getHeight */])(imageExtent);
        var row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));
        if (row < 0 || row >= img.height) {
            return null;
        }
        return this.getImageData(img, col, row);
    };
    /**
     * Render the layer.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */
    CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {
        var image = this.image_;
        var imageExtent = image.getExtent();
        var imageResolution = image.getResolution();
        var imagePixelRatio = image.getPixelRatio();
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        var pixelRatio = frameState.pixelRatio;
        var viewState = frameState.viewState;
        var viewCenter = viewState.center;
        var viewResolution = viewState.resolution;
        var size = frameState.size;
        var scale = (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);
        var width = Math.round(size[0] * pixelRatio);
        var height = Math.round(size[1] * pixelRatio);
        var rotation = viewState.rotation;
        if (rotation) {
            var size_1 = Math.round(Math.sqrt(width * width + height * height));
            width = size_1;
            height = size_1;
        }
        // set forward and inverse pixel transforms
        Object(ol_transform["b" /* compose */])(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
        Object(ol_transform["d" /* makeInverse */])(this.inversePixelTransform, this.pixelTransform);
        var canvasTransform = Object(ol_transform["g" /* toString */])(this.pixelTransform);
        this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
        var context = this.context;
        var canvas = context.canvas;
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
        }
        else if (!this.containerReused) {
            context.clearRect(0, 0, width, height);
        }
        // clipped rendering if layer extent is set
        var clipped = false;
        var render = true;
        if (layerState.extent) {
            var layerExtent = Object(ol_proj["k" /* fromUserExtent */])(layerState.extent, viewState.projection);
            render = Object(ol_extent["E" /* intersects */])(layerExtent, frameState.extent);
            clipped = render && !Object(ol_extent["g" /* containsExtent */])(layerExtent, frameState.extent);
            if (clipped) {
                this.clipUnrotated(context, frameState, layerExtent);
            }
        }
        var img = image.getImage();
        var transform = Object(ol_transform["b" /* compose */])(this.tempTransform, width / 2, height / 2, scale, scale, 0, (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution, (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution);
        this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;
        var dw = img.width * transform[0];
        var dh = img.height * transform[3];
        if (!this.getLayer().getSource().getInterpolate()) {
            Object(ol_obj["a" /* assign */])(context, canvas_common["a" /* IMAGE_SMOOTHING_DISABLED */]);
        }
        this.preRender(context, frameState);
        if (render && dw >= 0.5 && dh >= 0.5) {
            var dx = transform[4];
            var dy = transform[5];
            var opacity = layerState.opacity;
            var previousAlpha = void 0;
            if (opacity !== 1) {
                previousAlpha = context.globalAlpha;
                context.globalAlpha = opacity;
            }
            context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
            if (opacity !== 1) {
                context.globalAlpha = previousAlpha;
            }
        }
        this.postRender(context, frameState);
        if (clipped) {
            context.restore();
        }
        Object(ol_obj["a" /* assign */])(context, canvas_common["b" /* IMAGE_SMOOTHING_ENABLED */]);
        if (canvasTransform !== canvas.style.transform) {
            canvas.style.transform = canvasTransform;
        }
        return this.container;
    };
    return CanvasImageLayerRenderer;
}(canvas_Layer["a" /* default */]));
/* harmony default export */ var canvas_ImageLayer = (ImageLayer_CanvasImageLayerRenderer);
//# sourceMappingURL=ImageLayer.js.map
// CONCATENATED MODULE: ./node_modules/ol/layer/Image.js
var Image_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/layer/Image
 */


/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Image.js").default} ImageSourceType
 * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}
 * @api
 */
var Image_ImageLayer = /** @class */ (function (_super) {
    Image_extends(ImageLayer, _super);
    /**
     * @param {import("./BaseImage.js").Options<ImageSourceType>} [opt_options] Layer options.
     */
    function ImageLayer(opt_options) {
        return _super.call(this, opt_options) || this;
    }
    ImageLayer.prototype.createRenderer = function () {
        return new canvas_ImageLayer(this);
    };
    /**
     * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
     * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
     * source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     */
    ImageLayer.prototype.getData = function (pixel) {
        return _super.prototype.getData.call(this, pixel);
    };
    return ImageLayer;
}(BaseImage));
/* harmony default export */ var layer_Image = (Image_ImageLayer);
//# sourceMappingURL=Image.js.map
// EXTERNAL MODULE: ./node_modules/ol/layer/Vector.js + 18 modules
var Vector = __webpack_require__("3e6b");

// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js
var EventType = __webpack_require__("01d4");

// EXTERNAL MODULE: ./node_modules/ol/ImageTile.js
var ImageTile = __webpack_require__("7f98");

// EXTERNAL MODULE: ./node_modules/ol/reproj/Tile.js
var reproj_Tile = __webpack_require__("2efc");

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__("92fa");

// CONCATENATED MODULE: ./node_modules/ol/structs/LRUCache.js
/**
 * @module ol/structs/LRUCache
 */

/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Object} newer Newer.
 * @property {Object} older Older.
 * @property {*} value_ Value.
 */
/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
var LRUCache_LRUCache = /** @class */ (function () {
    /**
     * @param {number} [opt_highWaterMark] High water mark.
     */
    function LRUCache(opt_highWaterMark) {
        /**
         * Desired max cache size after expireCache(). If set to 0, no cache entries
         * will be pruned at all.
         * @type {number}
         */
        this.highWaterMark =
            opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
        /**
         * @private
         * @type {number}
         */
        this.count_ = 0;
        /**
         * @private
         * @type {!Object<string, Entry>}
         */
        this.entries_ = {};
        /**
         * @private
         * @type {?Entry}
         */
        this.oldest_ = null;
        /**
         * @private
         * @type {?Entry}
         */
        this.newest_ = null;
    }
    /**
     * @return {boolean} Can expire cache.
     */
    LRUCache.prototype.canExpireCache = function () {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    };
    /**
     * Expire the cache.
     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
     */
    LRUCache.prototype.expireCache = function (keep) {
        while (this.canExpireCache()) {
            this.pop();
        }
    };
    /**
     * FIXME empty description for jsdoc
     */
    LRUCache.prototype.clear = function () {
        this.count_ = 0;
        this.entries_ = {};
        this.oldest_ = null;
        this.newest_ = null;
    };
    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */
    LRUCache.prototype.containsKey = function (key) {
        return this.entries_.hasOwnProperty(key);
    };
    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */
    LRUCache.prototype.forEach = function (f) {
        var entry = this.oldest_;
        while (entry) {
            f(entry.value_, entry.key_, this);
            entry = entry.newer;
        }
    };
    /**
     * @param {string} key Key.
     * @param {*} [opt_options] Options (reserved for subclasses).
     * @return {T} Value.
     */
    LRUCache.prototype.get = function (key, opt_options) {
        var entry = this.entries_[key];
        Object(asserts["a" /* assert */])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) {
            return entry.value_;
        }
        else if (entry === this.oldest_) {
            this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
            this.oldest_.older = null;
        }
        else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
    };
    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */
    LRUCache.prototype.remove = function (key) {
        var entry = this.entries_[key];
        Object(asserts["a" /* assert */])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) {
            this.newest_ = /** @type {Entry} */ (entry.older);
            if (this.newest_) {
                this.newest_.newer = null;
            }
        }
        else if (entry === this.oldest_) {
            this.oldest_ = /** @type {Entry} */ (entry.newer);
            if (this.oldest_) {
                this.oldest_.older = null;
            }
        }
        else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        delete this.entries_[key];
        --this.count_;
        return entry.value_;
    };
    /**
     * @return {number} Count.
     */
    LRUCache.prototype.getCount = function () {
        return this.count_;
    };
    /**
     * @return {Array<string>} Keys.
     */
    LRUCache.prototype.getKeys = function () {
        var keys = new Array(this.count_);
        var i = 0;
        var entry;
        for (entry = this.newest_; entry; entry = entry.older) {
            keys[i++] = entry.key_;
        }
        return keys;
    };
    /**
     * @return {Array<T>} Values.
     */
    LRUCache.prototype.getValues = function () {
        var values = new Array(this.count_);
        var i = 0;
        var entry;
        for (entry = this.newest_; entry; entry = entry.older) {
            values[i++] = entry.value_;
        }
        return values;
    };
    /**
     * @return {T} Last value.
     */
    LRUCache.prototype.peekLast = function () {
        return this.oldest_.value_;
    };
    /**
     * @return {string} Last key.
     */
    LRUCache.prototype.peekLastKey = function () {
        return this.oldest_.key_;
    };
    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */
    LRUCache.prototype.peekFirstKey = function () {
        return this.newest_.key_;
    };
    /**
     * @return {T} value Value.
     */
    LRUCache.prototype.pop = function () {
        var entry = this.oldest_;
        delete this.entries_[entry.key_];
        if (entry.newer) {
            entry.newer.older = null;
        }
        this.oldest_ = /** @type {Entry} */ (entry.newer);
        if (!this.oldest_) {
            this.newest_ = null;
        }
        --this.count_;
        return entry.value_;
    };
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    LRUCache.prototype.replace = function (key, value) {
        this.get(key); // update `newest_`
        this.entries_[key].value_ = value;
    };
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    LRUCache.prototype.set = function (key, value) {
        Object(asserts["a" /* assert */])(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
        var entry = {
            key_: key,
            newer: null,
            older: this.newest_,
            value_: value,
        };
        if (!this.newest_) {
            this.oldest_ = entry;
        }
        else {
            this.newest_.newer = entry;
        }
        this.newest_ = entry;
        this.entries_[key] = entry;
        ++this.count_;
    };
    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */
    LRUCache.prototype.setSize = function (size) {
        this.highWaterMark = size;
    };
    return LRUCache;
}());
/* harmony default export */ var structs_LRUCache = (LRUCache_LRUCache);
//# sourceMappingURL=LRUCache.js.map
// EXTERNAL MODULE: ./node_modules/ol/tilecoord.js
var tilecoord = __webpack_require__("2c30");

// CONCATENATED MODULE: ./node_modules/ol/TileCache.js
var TileCache_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/TileCache
 */


var TileCache_TileCache = /** @class */ (function (_super) {
    TileCache_extends(TileCache, _super);
    function TileCache() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
    TileCache.prototype.expireCache = function (usedTiles) {
        while (this.canExpireCache()) {
            var tile = this.peekLast();
            if (tile.getKey() in usedTiles) {
                break;
            }
            else {
                this.pop().release();
            }
        }
    };
    /**
     * Prune all tiles from the cache that don't have the same z as the newest tile.
     */
    TileCache.prototype.pruneExceptNewestZ = function () {
        if (this.getCount() === 0) {
            return;
        }
        var key = this.peekFirstKey();
        var tileCoord = Object(tilecoord["b" /* fromKey */])(key);
        var z = tileCoord[0];
        this.forEach(function (tile) {
            if (tile.tileCoord[0] !== z) {
                this.remove(Object(tilecoord["c" /* getKey */])(tile.tileCoord));
                tile.release();
            }
        }.bind(this));
    };
    return TileCache;
}(structs_LRUCache));
/* harmony default export */ var ol_TileCache = (TileCache_TileCache);
//# sourceMappingURL=TileCache.js.map
// EXTERNAL MODULE: ./node_modules/ol/TileState.js
var TileState = __webpack_require__("acc1");

// CONCATENATED MODULE: ./node_modules/ol/source/TileEventType.js
/**
 * @module ol/source/TileEventType
 */
/**
 * @enum {string}
 */
/* harmony default export */ var TileEventType = ({
    /**
     * Triggered when a tile starts loading.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
     * @api
     */
    TILELOADSTART: 'tileloadstart',
    /**
     * Triggered when a tile finishes loading, either when its data is loaded,
     * or when loading was aborted because the tile is no longer needed.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadend
     * @api
     */
    TILELOADEND: 'tileloadend',
    /**
     * Triggered if tile loading results in an error.
     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
     * @api
     */
    TILELOADERROR: 'tileloaderror',
});
/**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */
//# sourceMappingURL=TileEventType.js.map
// EXTERNAL MODULE: ./node_modules/ol/events/Event.js
var Event = __webpack_require__("cef7");

// EXTERNAL MODULE: ./node_modules/ol/source/Source.js
var Source = __webpack_require__("ff80");

// EXTERNAL MODULE: ./node_modules/ol/util.js
var util = __webpack_require__("1300");

// EXTERNAL MODULE: ./node_modules/ol/tilegrid.js
var ol_tilegrid = __webpack_require__("089b");

// EXTERNAL MODULE: ./node_modules/ol/size.js
var ol_size = __webpack_require__("345d");

// CONCATENATED MODULE: ./node_modules/ol/source/Tile.js
var Tile_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/source/Tile
 */










/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./State.js").default} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
var Tile_TileSource = /** @class */ (function (_super) {
    Tile_extends(TileSource, _super);
    /**
     * @param {Options} options SourceTile source options.
     */
    function TileSource(options) {
        var _this = _super.call(this, {
            attributions: options.attributions,
            attributionsCollapsible: options.attributionsCollapsible,
            projection: options.projection,
            state: options.state,
            wrapX: options.wrapX,
            interpolate: options.interpolate,
        }) || this;
        /***
         * @type {TileSourceOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {TileSourceOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {TileSourceOnSignature<void>}
         */
        _this.un;
        /**
         * @private
         * @type {boolean}
         */
        _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
        /**
         * @private
         * @type {number}
         */
        _this.tilePixelRatio_ =
            options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
        /**
         * @type {import("../tilegrid/TileGrid.js").default|null}
         */
        _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
        var tileSize = [256, 256];
        if (_this.tileGrid) {
            Object(ol_size["c" /* toSize */])(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);
        }
        /**
         * @protected
         * @type {import("../TileCache.js").default}
         */
        _this.tileCache = new ol_TileCache(options.cacheSize || 0);
        /**
         * @protected
         * @type {import("../size.js").Size}
         */
        _this.tmpSize = [0, 0];
        /**
         * @private
         * @type {string}
         */
        _this.key_ = options.key || '';
        /**
         * @protected
         * @type {import("../Tile.js").Options}
         */
        _this.tileOptions = {
            transition: options.transition,
            interpolate: options.interpolate,
        };
        /**
         * zDirection hint, read by the renderer. Indicates which resolution should be used
         * by a renderer if the views resolution does not match any resolution of the tile source.
         * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
         * will be used. If -1, the nearest higher resolution will be used.
         * @type {number|import("../array.js").NearestDirectionFunction}
         */
        _this.zDirection = options.zDirection ? options.zDirection : 0;
        return _this;
    }
    /**
     * @return {boolean} Can expire cache.
     */
    TileSource.prototype.canExpireCache = function () {
        return this.tileCache.canExpireCache();
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
    TileSource.prototype.expireCache = function (projection, usedTiles) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (tileCache) {
            tileCache.expireCache(usedTiles);
        }
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {number} z Zoom level.
     * @param {import("../TileRange.js").default} tileRange Tile range.
     * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
     *     loaded tile.  If the callback returns `false`, the tile will not be
     *     considered loaded.
     * @return {boolean} The tile range is fully covered with loaded tiles.
     */
    TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (!tileCache) {
            return false;
        }
        var covered = true;
        var tile, tileCoordKey, loaded;
        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                tileCoordKey = Object(tilecoord["d" /* getKeyZXY */])(z, x, y);
                loaded = false;
                if (tileCache.containsKey(tileCoordKey)) {
                    tile = /** @type {!import("../Tile.js").default} */ (tileCache.get(tileCoordKey));
                    loaded = tile.getState() === TileState["a" /* default */].LOADED;
                    if (loaded) {
                        loaded = callback(tile) !== false;
                    }
                }
                if (!loaded) {
                    covered = false;
                }
            }
        }
        return covered;
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
    TileSource.prototype.getGutterForProjection = function (projection) {
        return 0;
    };
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
    TileSource.prototype.getKey = function () {
        return this.key_;
    };
    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */
    TileSource.prototype.setKey = function (key) {
        if (this.key_ !== key) {
            this.key_ = key;
            this.changed();
        }
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {boolean} Opaque.
     */
    TileSource.prototype.getOpaque = function (projection) {
        return this.opaque_;
    };
    /**
     * @return {Array<number>|null} Resolutions.
     */
    TileSource.prototype.getResolutions = function () {
        if (!this.tileGrid) {
            return null;
        }
        return this.tileGrid.getResolutions();
    };
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../Tile.js").default} Tile.
     */
    TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
     * @api
     */
    TileSource.prototype.getTileGrid = function () {
        return this.tileGrid;
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
    TileSource.prototype.getTileGridForProjection = function (projection) {
        if (!this.tileGrid) {
            return Object(ol_tilegrid["c" /* getForProjection */])(projection);
        }
        else {
            return this.tileGrid;
        }
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     * @protected
     */
    TileSource.prototype.getTileCacheForProjection = function (projection) {
        Object(asserts["a" /* assert */])(Object(ol_proj["i" /* equivalent */])(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
        );
        return this.tileCache;
    };
    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
    TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
        return this.tilePixelRatio_;
    };
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */
    TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
        var tileGrid = this.getTileGridForProjection(projection);
        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        var tileSize = Object(ol_size["c" /* toSize */])(tileGrid.getTileSize(z), this.tmpSize);
        if (tilePixelRatio == 1) {
            return tileSize;
        }
        else {
            return Object(ol_size["b" /* scale */])(tileSize, tilePixelRatio, this.tmpSize);
        }
    };
    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [opt_projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */
    TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
        var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
        var tileGrid = this.getTileGridForProjection(projection);
        if (this.getWrapX() && projection.isGlobal()) {
            tileCoord = Object(ol_tilegrid["d" /* wrapX */])(tileGrid, tileCoord, projection);
        }
        return Object(tilecoord["f" /* withinExtentAndZ */])(tileCoord, tileGrid) ? tileCoord : null;
    };
    /**
     * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
     * @api
     */
    TileSource.prototype.clear = function () {
        this.tileCache.clear();
    };
    TileSource.prototype.refresh = function () {
        this.clear();
        _super.prototype.refresh.call(this);
    };
    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    TileSource.prototype.updateCacheSize = function (tileCount, projection) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (tileCount > tileCache.highWaterMark) {
            tileCache.highWaterMark = tileCount;
        }
    };
    /**
     * Marks a tile coord as being used, without triggering a load.
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    TileSource.prototype.useTile = function (z, x, y, projection) { };
    return TileSource;
}(Source["a" /* default */]));
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
var TileSourceEvent = /** @class */ (function (_super) {
    Tile_extends(TileSourceEvent, _super);
    /**
     * @param {string} type Type.
     * @param {import("../Tile.js").default} tile The tile.
     */
    function TileSourceEvent(type, tile) {
        var _this = _super.call(this, type) || this;
        /**
         * The tile related to the event.
         * @type {import("../Tile.js").default}
         * @api
         */
        _this.tile = tile;
        return _this;
    }
    return TileSourceEvent;
}(Event["a" /* default */]));

/* harmony default export */ var source_Tile = (Tile_TileSource);
//# sourceMappingURL=Tile.js.map
// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__("7fc9");

// CONCATENATED MODULE: ./node_modules/ol/tileurlfunction.js
/**
 * @module ol/tileurlfunction
 */



/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
    var zRegEx = /\{z\}/g;
    var xRegEx = /\{x\}/g;
    var yRegEx = /\{y\}/g;
    var dashYRegEx = /\{-y\}/g;
    return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
            return undefined;
        }
        else {
            return template
                .replace(zRegEx, tileCoord[0].toString())
                .replace(xRegEx, tileCoord[1].toString())
                .replace(yRegEx, tileCoord[2].toString())
                .replace(dashYRegEx, function () {
                var z = tileCoord[0];
                var range = tileGrid.getFullTileRange(z);
                Object(asserts["a" /* assert */])(range, 55); // The {-y} placeholder requires a tile grid with extent
                var y = range.getHeight() - tileCoord[2] - 1;
                return y.toString();
            });
        }
    });
}
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
    var len = templates.length;
    var tileUrlFunctions = new Array(len);
    for (var i = 0; i < len; ++i) {
        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
    }
    return createFromTileUrlFunctions(tileUrlFunctions);
}
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
    if (tileUrlFunctions.length === 1) {
        return tileUrlFunctions[0];
    }
    return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
            return undefined;
        }
        else {
            var h = Object(tilecoord["e" /* hash */])(tileCoord);
            var index = Object(math["g" /* modulo */])(h, tileUrlFunctions.length);
            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
        }
    });
}
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
    return undefined;
}
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
    var urls = [];
    var match = /\{([a-z])-([a-z])\}/.exec(url);
    if (match) {
        // char range
        var startCharCode = match[1].charCodeAt(0);
        var stopCharCode = match[2].charCodeAt(0);
        var charCode = void 0;
        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
            urls.push(url.replace(match[0], String.fromCharCode(charCode)));
        }
        return urls;
    }
    match = /\{(\d+)-(\d+)\}/.exec(url);
    if (match) {
        // number range
        var stop_1 = parseInt(match[2], 10);
        for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
            urls.push(url.replace(match[0], i.toString()));
        }
        return urls;
    }
    urls.push(url);
    return urls;
}
//# sourceMappingURL=tileurlfunction.js.map
// CONCATENATED MODULE: ./node_modules/ol/source/UrlTile.js
var UrlTile_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/source/UrlTile
 */






/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./State.js").default} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
var UrlTile_UrlTile = /** @class */ (function (_super) {
    UrlTile_extends(UrlTile, _super);
    /**
     * @param {Options} options Image tile options.
     */
    function UrlTile(options) {
        var _this = _super.call(this, {
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            opaque: options.opaque,
            projection: options.projection,
            state: options.state,
            tileGrid: options.tileGrid,
            tilePixelRatio: options.tilePixelRatio,
            wrapX: options.wrapX,
            transition: options.transition,
            interpolate: options.interpolate,
            key: options.key,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection,
        }) || this;
        /**
         * @private
         * @type {boolean}
         */
        _this.generateTileUrlFunction_ =
            _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
        /**
         * @protected
         * @type {import("../Tile.js").LoadFunction}
         */
        _this.tileLoadFunction = options.tileLoadFunction;
        if (options.tileUrlFunction) {
            _this.tileUrlFunction = options.tileUrlFunction;
        }
        /**
         * @protected
         * @type {!Array<string>|null}
         */
        _this.urls = null;
        if (options.urls) {
            _this.setUrls(options.urls);
        }
        else if (options.url) {
            _this.setUrl(options.url);
        }
        /**
         * @private
         * @type {!Object<string, boolean>}
         */
        _this.tileLoadingKeys_ = {};
        return _this;
    }
    /**
     * Return the tile load function of the source.
     * @return {import("../Tile.js").LoadFunction} TileLoadFunction
     * @api
     */
    UrlTile.prototype.getTileLoadFunction = function () {
        return this.tileLoadFunction;
    };
    /**
     * Return the tile URL function of the source.
     * @return {import("../Tile.js").UrlFunction} TileUrlFunction
     * @api
     */
    UrlTile.prototype.getTileUrlFunction = function () {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction
            ? this.tileUrlFunction.bind(this)
            : this.tileUrlFunction;
    };
    /**
     * Return the URLs used for this source.
     * When a tileUrlFunction is used instead of url or urls,
     * null will be returned.
     * @return {!Array<string>|null} URLs.
     * @api
     */
    UrlTile.prototype.getUrls = function () {
        return this.urls;
    };
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    UrlTile.prototype.handleTileChange = function (event) {
        var tile = /** @type {import("../Tile.js").default} */ (event.target);
        var uid = Object(util["c" /* getUid */])(tile);
        var tileState = tile.getState();
        var type;
        if (tileState == TileState["a" /* default */].LOADING) {
            this.tileLoadingKeys_[uid] = true;
            type = TileEventType.TILELOADSTART;
        }
        else if (uid in this.tileLoadingKeys_) {
            delete this.tileLoadingKeys_[uid];
            type =
                tileState == TileState["a" /* default */].ERROR
                    ? TileEventType.TILELOADERROR
                    : tileState == TileState["a" /* default */].LOADED
                        ? TileEventType.TILELOADEND
                        : undefined;
        }
        if (type != undefined) {
            this.dispatchEvent(new TileSourceEvent(type, tile));
        }
    };
    /**
     * Set the tile load function of the source.
     * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @api
     */
    UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
        this.tileCache.clear();
        this.tileLoadFunction = tileLoadFunction;
        this.changed();
    };
    /**
     * Set the tile URL function of the source.
     * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
     * @param {string} [key] Optional new tile key for the source.
     * @api
     */
    UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {
        this.tileUrlFunction = tileUrlFunction;
        this.tileCache.pruneExceptNewestZ();
        if (typeof key !== 'undefined') {
            this.setKey(key);
        }
        else {
            this.changed();
        }
    };
    /**
     * Set the URL to use for requests.
     * @param {string} url URL.
     * @api
     */
    UrlTile.prototype.setUrl = function (url) {
        var urls = expandUrl(url);
        this.urls = urls;
        this.setUrls(urls);
    };
    /**
     * Set the URLs to use for requests.
     * @param {Array<string>} urls URLs.
     * @api
     */
    UrlTile.prototype.setUrls = function (urls) {
        this.urls = urls;
        var key = urls.join('\n');
        if (this.generateTileUrlFunction_) {
            this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
        }
        else {
            this.setKey(key);
        }
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
        return undefined;
    };
    /**
     * Marks a tile coord as being used, without triggering a load.
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     */
    UrlTile.prototype.useTile = function (z, x, y) {
        var tileCoordKey = Object(tilecoord["d" /* getKeyZXY */])(z, x, y);
        if (this.tileCache.containsKey(tileCoordKey)) {
            this.tileCache.get(tileCoordKey);
        }
    };
    return UrlTile;
}(source_Tile));
/* harmony default export */ var source_UrlTile = (UrlTile_UrlTile);
//# sourceMappingURL=UrlTile.js.map
// CONCATENATED MODULE: ./node_modules/ol/source/TileImage.js
var TileImage_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/source/TileImage
 */











/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var TileImage_TileImage = /** @class */ (function (_super) {
    TileImage_extends(TileImage, _super);
    /**
     * @param {!Options} options Image tile options.
     */
    function TileImage(options) {
        var _this = this;
        var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;
        if (options.interpolate !== undefined) {
            interpolate = options.interpolate;
        }
        _this = _super.call(this, {
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            opaque: options.opaque,
            projection: options.projection,
            state: options.state,
            tileGrid: options.tileGrid,
            tileLoadFunction: options.tileLoadFunction
                ? options.tileLoadFunction
                : defaultTileLoadFunction,
            tilePixelRatio: options.tilePixelRatio,
            tileUrlFunction: options.tileUrlFunction,
            url: options.url,
            urls: options.urls,
            wrapX: options.wrapX,
            transition: options.transition,
            interpolate: interpolate,
            key: options.key,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection,
        }) || this;
        /**
         * @protected
         * @type {?string}
         */
        _this.crossOrigin =
            options.crossOrigin !== undefined ? options.crossOrigin : null;
        /**
         * @protected
         * @type {typeof ImageTile}
         */
        _this.tileClass =
            options.tileClass !== undefined ? options.tileClass : ImageTile["a" /* default */];
        /**
         * @protected
         * @type {!Object<string, TileCache>}
         */
        _this.tileCacheForProjection = {};
        /**
         * @protected
         * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
         */
        _this.tileGridForProjection = {};
        /**
         * @private
         * @type {number|undefined}
         */
        _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
        /**
         * @private
         * @type {boolean}
         */
        _this.renderReprojectionEdges_ = false;
        return _this;
    }
    /**
     * @return {boolean} Can expire cache.
     */
    TileImage.prototype.canExpireCache = function () {
        if (!common["a" /* ENABLE_RASTER_REPROJECTION */]) {
            return _super.prototype.canExpireCache.call(this);
        }
        if (this.tileCache.canExpireCache()) {
            return true;
        }
        else {
            for (var key in this.tileCacheForProjection) {
                if (this.tileCacheForProjection[key].canExpireCache()) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */
    TileImage.prototype.expireCache = function (projection, usedTiles) {
        if (!common["a" /* ENABLE_RASTER_REPROJECTION */]) {
            _super.prototype.expireCache.call(this, projection, usedTiles);
            return;
        }
        var usedTileCache = this.getTileCacheForProjection(projection);
        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
        for (var id in this.tileCacheForProjection) {
            var tileCache = this.tileCacheForProjection[id];
            tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
        }
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
    TileImage.prototype.getGutterForProjection = function (projection) {
        if (common["a" /* ENABLE_RASTER_REPROJECTION */] &&
            this.getProjection() &&
            projection &&
            !Object(ol_proj["i" /* equivalent */])(this.getProjection(), projection)) {
            return 0;
        }
        else {
            return this.getGutter();
        }
    };
    /**
     * @return {number} Gutter.
     */
    TileImage.prototype.getGutter = function () {
        return 0;
    };
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
    TileImage.prototype.getKey = function () {
        var key = _super.prototype.getKey.call(this);
        if (!this.getInterpolate()) {
            key += ':disable-interpolation';
        }
        return key;
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {boolean} Opaque.
     */
    TileImage.prototype.getOpaque = function (projection) {
        if (common["a" /* ENABLE_RASTER_REPROJECTION */] &&
            this.getProjection() &&
            projection &&
            !Object(ol_proj["i" /* equivalent */])(this.getProjection(), projection)) {
            return false;
        }
        else {
            return _super.prototype.getOpaque.call(this, projection);
        }
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
    TileImage.prototype.getTileGridForProjection = function (projection) {
        if (!common["a" /* ENABLE_RASTER_REPROJECTION */]) {
            return _super.prototype.getTileGridForProjection.call(this, projection);
        }
        var thisProj = this.getProjection();
        if (this.tileGrid && (!thisProj || Object(ol_proj["i" /* equivalent */])(thisProj, projection))) {
            return this.tileGrid;
        }
        else {
            var projKey = Object(util["c" /* getUid */])(projection);
            if (!(projKey in this.tileGridForProjection)) {
                this.tileGridForProjection[projKey] =
                    Object(ol_tilegrid["c" /* getForProjection */])(projection);
            }
            return this.tileGridForProjection[projKey];
        }
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     */
    TileImage.prototype.getTileCacheForProjection = function (projection) {
        if (!common["a" /* ENABLE_RASTER_REPROJECTION */]) {
            return _super.prototype.getTileCacheForProjection.call(this, projection);
        }
        var thisProj = this.getProjection();
        if (!thisProj || Object(ol_proj["i" /* equivalent */])(thisProj, projection)) {
            return this.tileCache;
        }
        else {
            var projKey = Object(util["c" /* getUid */])(projection);
            if (!(projKey in this.tileCacheForProjection)) {
                this.tileCacheForProjection[projKey] = new ol_TileCache(this.tileCache.highWaterMark);
            }
            return this.tileCacheForProjection[projKey];
        }
    };
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {string} key The key set on the tile.
     * @return {!ImageTile} Tile.
     * @private
     */
    TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
        var tileCoord = [z, x, y];
        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var tileUrl = urlTileCoord
            ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)
            : undefined;
        var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState["a" /* default */].IDLE : TileState["a" /* default */].EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
        tile.key = key;
        tile.addEventListener(EventType["a" /* default */].CHANGE, this.handleTileChange.bind(this));
        return tile;
    };
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     */
    TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
        var sourceProjection = this.getProjection();
        if (!common["a" /* ENABLE_RASTER_REPROJECTION */] ||
            !sourceProjection ||
            !projection ||
            Object(ol_proj["i" /* equivalent */])(sourceProjection, projection)) {
            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
        }
        else {
            var cache = this.getTileCacheForProjection(projection);
            var tileCoord = [z, x, y];
            var tile = void 0;
            var tileCoordKey = Object(tilecoord["c" /* getKey */])(tileCoord);
            if (cache.containsKey(tileCoordKey)) {
                tile = cache.get(tileCoordKey);
            }
            var key = this.getKey();
            if (tile && tile.key == key) {
                return tile;
            }
            else {
                var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
                var targetTileGrid = this.getTileGridForProjection(projection);
                var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                var newTile = new reproj_Tile["a" /* default */](sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
                    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
                }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
                newTile.key = key;
                if (tile) {
                    newTile.interimTile = tile;
                    newTile.refreshInterimChain();
                    cache.replace(tileCoordKey, newTile);
                }
                else {
                    cache.set(tileCoordKey, newTile);
                }
                return newTile;
            }
        }
    };
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {!import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     * @protected
     */
    TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
        var tile = null;
        var tileCoordKey = Object(tilecoord["d" /* getKeyZXY */])(z, x, y);
        var key = this.getKey();
        if (!this.tileCache.containsKey(tileCoordKey)) {
            tile = this.createTile_(z, x, y, pixelRatio, projection, key);
            this.tileCache.set(tileCoordKey, tile);
        }
        else {
            tile = this.tileCache.get(tileCoordKey);
            if (tile.key != key) {
                // The source's params changed. If the tile has an interim tile and if we
                // can use it then we use it. Otherwise we create a new tile.  In both
                // cases we attempt to assign an interim tile to the new tile.
                var interimTile = tile;
                tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                //make the new tile the head of the list,
                if (interimTile.getState() == TileState["a" /* default */].IDLE) {
                    //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
                    tile.interimTile = interimTile.interimTile;
                }
                else {
                    tile.interimTile = interimTile;
                }
                tile.refreshInterimChain();
                this.tileCache.replace(tileCoordKey, tile);
            }
        }
        return tile;
    };
    /**
     * Sets whether to render reprojection edges or not (usually for debugging).
     * @param {boolean} render Render the edges.
     * @api
     */
    TileImage.prototype.setRenderReprojectionEdges = function (render) {
        if (!common["a" /* ENABLE_RASTER_REPROJECTION */] ||
            this.renderReprojectionEdges_ == render) {
            return;
        }
        this.renderReprojectionEdges_ = render;
        for (var id in this.tileCacheForProjection) {
            this.tileCacheForProjection[id].clear();
        }
        this.changed();
    };
    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
    TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
        if (common["a" /* ENABLE_RASTER_REPROJECTION */]) {
            var proj = Object(ol_proj["m" /* get */])(projection);
            if (proj) {
                var projKey = Object(util["c" /* getUid */])(proj);
                if (!(projKey in this.tileGridForProjection)) {
                    this.tileGridForProjection[projKey] = tilegrid;
                }
            }
        }
    };
    return TileImage;
}(source_UrlTile));
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
    /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =
        src;
}
/* harmony default export */ var source_TileImage = (TileImage_TileImage);
//# sourceMappingURL=TileImage.js.map
// CONCATENATED MODULE: ./node_modules/ol/source/XYZ.js
/**
 * @module ol/source/XYZ
 */
var XYZ_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */
var XYZ_XYZ = /** @class */ (function (_super) {
    XYZ_extends(XYZ, _super);
    /**
     * @param {Options} [opt_options] XYZ options.
     */
    function XYZ(opt_options) {
        var options = opt_options || {};
        var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;
        if (options.interpolate !== undefined) {
            interpolate = options.interpolate;
        }
        var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
        var tileGrid = options.tileGrid !== undefined
            ? options.tileGrid
            : Object(ol_tilegrid["a" /* createXYZ */])({
                extent: Object(ol_tilegrid["b" /* extentFromProjection */])(projection),
                maxResolution: options.maxResolution,
                maxZoom: options.maxZoom,
                minZoom: options.minZoom,
                tileSize: options.tileSize,
            });
        return _super.call(this, {
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            crossOrigin: options.crossOrigin,
            interpolate: interpolate,
            opaque: options.opaque,
            projection: projection,
            reprojectionErrorThreshold: options.reprojectionErrorThreshold,
            tileGrid: tileGrid,
            tileLoadFunction: options.tileLoadFunction,
            tilePixelRatio: options.tilePixelRatio,
            tileUrlFunction: options.tileUrlFunction,
            url: options.url,
            urls: options.urls,
            wrapX: options.wrapX !== undefined ? options.wrapX : true,
            transition: options.transition,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection,
        }) || this;
    }
    return XYZ;
}(source_TileImage));
/* harmony default export */ var source_XYZ = (XYZ_XYZ);
//# sourceMappingURL=XYZ.js.map
// CONCATENATED MODULE: ./node_modules/ol/source/OSM.js
/**
 * @module ol/source/OSM
 */
var OSM_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = '&#169; ' +
    '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' +
    'contributors.';
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */
/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
var OSM = /** @class */ (function (_super) {
    OSM_extends(OSM, _super);
    /**
     * @param {Options} [opt_options] Open Street Map options.
     */
    function OSM(opt_options) {
        var options = opt_options || {};
        var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;
        if (options.interpolate !== undefined) {
            interpolate = options.interpolate;
        }
        var attributions;
        if (options.attributions !== undefined) {
            attributions = options.attributions;
        }
        else {
            attributions = [ATTRIBUTION];
        }
        var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
        var url = options.url !== undefined
            ? options.url
            : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        return _super.call(this, {
            attributions: attributions,
            attributionsCollapsible: false,
            cacheSize: options.cacheSize,
            crossOrigin: crossOrigin,
            interpolate: interpolate,
            maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
            opaque: options.opaque !== undefined ? options.opaque : true,
            reprojectionErrorThreshold: options.reprojectionErrorThreshold,
            tileLoadFunction: options.tileLoadFunction,
            transition: options.transition,
            url: url,
            wrapX: options.wrapX,
            zDirection: options.zDirection,
        }) || this;
    }
    return OSM;
}(source_XYZ));
/* harmony default export */ var source_OSM = (OSM);
//# sourceMappingURL=OSM.js.map
// EXTERNAL MODULE: ./node_modules/ol/ImageState.js
var ImageState = __webpack_require__("869f");

// EXTERNAL MODULE: ./node_modules/ol/ImageBase.js
var ImageBase = __webpack_require__("8778");

// EXTERNAL MODULE: ./node_modules/ol/reproj/Triangulation.js
var Triangulation = __webpack_require__("b739");

// EXTERNAL MODULE: ./node_modules/ol/reproj.js
var reproj = __webpack_require__("3c81");

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__("1e8d");

// CONCATENATED MODULE: ./node_modules/ol/reproj/Image.js
var reproj_Image_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/reproj/Image
 */








/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../ImageBase.js").default} FunctionType
 */
/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */
var Image_ReprojImage = /** @class */ (function (_super) {
    reproj_Image_extends(ReprojImage, _super);
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent.
     * @param {number} targetResolution Target resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {FunctionType} getImageFunction
     *     Function returning source images (extent, resolution, pixelRatio).
     * @param {boolean} interpolate Use linear interpolation when resampling.
     */
    function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {
        var _this = this;
        var maxSourceExtent = sourceProj.getExtent();
        var maxTargetExtent = targetProj.getExtent();
        var limitedTargetExtent = maxTargetExtent
            ? Object(ol_extent["A" /* getIntersection */])(targetExtent, maxTargetExtent)
            : targetExtent;
        var targetCenter = Object(ol_extent["w" /* getCenter */])(limitedTargetExtent);
        var sourceResolution = Object(reproj["b" /* calculateSourceResolution */])(sourceProj, targetProj, targetCenter, targetResolution);
        var errorThresholdInPixels = common["b" /* ERROR_THRESHOLD */];
        var triangulation = new Triangulation["a" /* default */](sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
        var sourceExtent = triangulation.calculateSourceExtent();
        var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
        var state = sourceImage ? ImageState["a" /* default */].IDLE : ImageState["a" /* default */].EMPTY;
        var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
        _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
        /**
         * @private
         * @type {import("../proj/Projection.js").default}
         */
        _this.targetProj_ = targetProj;
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */
        _this.maxSourceExtent_ = maxSourceExtent;
        /**
         * @private
         * @type {!import("./Triangulation.js").default}
         */
        _this.triangulation_ = triangulation;
        /**
         * @private
         * @type {number}
         */
        _this.targetResolution_ = targetResolution;
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */
        _this.targetExtent_ = targetExtent;
        /**
         * @private
         * @type {import("../ImageBase.js").default}
         */
        _this.sourceImage_ = sourceImage;
        /**
         * @private
         * @type {number}
         */
        _this.sourcePixelRatio_ = sourcePixelRatio;
        /**
         * @private
         * @type {boolean}
         */
        _this.interpolate_ = interpolate;
        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        _this.canvas_ = null;
        /**
         * @private
         * @type {?import("../events.js").EventsKey}
         */
        _this.sourceListenerKey_ = null;
        return _this;
    }
    /**
     * Clean up.
     */
    ReprojImage.prototype.disposeInternal = function () {
        if (this.state == ImageState["a" /* default */].LOADING) {
            this.unlistenSource_();
        }
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * @return {HTMLCanvasElement} Image.
     */
    ReprojImage.prototype.getImage = function () {
        return this.canvas_;
    };
    /**
     * @return {import("../proj/Projection.js").default} Projection.
     */
    ReprojImage.prototype.getProjection = function () {
        return this.targetProj_;
    };
    /**
     * @private
     */
    ReprojImage.prototype.reproject_ = function () {
        var sourceState = this.sourceImage_.getState();
        if (sourceState == ImageState["a" /* default */].LOADED) {
            var width = Object(ol_extent["D" /* getWidth */])(this.targetExtent_) / this.targetResolution_;
            var height = Object(ol_extent["z" /* getHeight */])(this.targetExtent_) / this.targetResolution_;
            this.canvas_ = Object(reproj["c" /* render */])(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
                {
                    extent: this.sourceImage_.getExtent(),
                    image: this.sourceImage_.getImage(),
                },
            ], 0, undefined, this.interpolate_);
        }
        this.state = sourceState;
        this.changed();
    };
    /**
     * Load not yet loaded URI.
     */
    ReprojImage.prototype.load = function () {
        if (this.state == ImageState["a" /* default */].IDLE) {
            this.state = ImageState["a" /* default */].LOADING;
            this.changed();
            var sourceState = this.sourceImage_.getState();
            if (sourceState == ImageState["a" /* default */].LOADED || sourceState == ImageState["a" /* default */].ERROR) {
                this.reproject_();
            }
            else {
                this.sourceListenerKey_ = Object(events["a" /* listen */])(this.sourceImage_, EventType["a" /* default */].CHANGE, function (e) {
                    var sourceState = this.sourceImage_.getState();
                    if (sourceState == ImageState["a" /* default */].LOADED ||
                        sourceState == ImageState["a" /* default */].ERROR) {
                        this.unlistenSource_();
                        this.reproject_();
                    }
                }, this);
                this.sourceImage_.load();
            }
        }
    };
    /**
     * @private
     */
    ReprojImage.prototype.unlistenSource_ = function () {
        Object(events["c" /* unlistenByKey */])(
        /** @type {!import("../events.js").EventsKey} */ (this.sourceListenerKey_));
        this.sourceListenerKey_ = null;
    };
    return ReprojImage;
}(ImageBase["a" /* default */]));
/* harmony default export */ var reproj_Image = (Image_ReprojImage);
//# sourceMappingURL=Image.js.map
// EXTERNAL MODULE: ./node_modules/ol/array.js
var ol_array = __webpack_require__("9f5e");

// CONCATENATED MODULE: ./node_modules/ol/source/Image.js
var source_Image_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/source/Image
 */









/**
 * @enum {string}
 */
var ImageSourceEventType = {
    /**
     * Triggered when an image starts loading.
     * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
     * @api
     */
    IMAGELOADSTART: 'imageloadstart',
    /**
     * Triggered when an image finishes loading.
     * @event module:ol/source/Image.ImageSourceEvent#imageloadend
     * @api
     */
    IMAGELOADEND: 'imageloadend',
    /**
     * Triggered if image loading results in an error.
     * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
     * @api
     */
    IMAGELOADERROR: 'imageloaderror',
};
/**
 * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes
 */
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */
var ImageSourceEvent = /** @class */ (function (_super) {
    source_Image_extends(ImageSourceEvent, _super);
    /**
     * @param {string} type Type.
     * @param {import("../Image.js").default} image The image.
     */
    function ImageSourceEvent(type, image) {
        var _this = _super.call(this, type) || this;
        /**
         * The image related to the event.
         * @type {import("../Image.js").default}
         * @api
         */
        _this.image = image;
        return _this;
    }
    return ImageSourceEvent;
}(Event["a" /* default */]));

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature
 */
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {Array<number>} [resolutions] Resolutions.
 * @property {import("./State.js").default} [state] State.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 * @abstract
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var Image_ImageSource = /** @class */ (function (_super) {
    source_Image_extends(ImageSource, _super);
    /**
     * @param {Options} options Single image source options.
     */
    function ImageSource(options) {
        var _this = this;
        var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;
        if (options.interpolate !== undefined) {
            interpolate = options.interpolate;
        }
        _this = _super.call(this, {
            attributions: options.attributions,
            projection: options.projection,
            state: options.state,
            interpolate: interpolate,
        }) || this;
        /***
         * @type {ImageSourceOnSignature<import("../events").EventsKey>}
         */
        _this.on;
        /***
         * @type {ImageSourceOnSignature<import("../events").EventsKey>}
         */
        _this.once;
        /***
         * @type {ImageSourceOnSignature<void>}
         */
        _this.un;
        /**
         * @private
         * @type {Array<number>|null}
         */
        _this.resolutions_ =
            options.resolutions !== undefined ? options.resolutions : null;
        /**
         * @private
         * @type {import("../reproj/Image.js").default}
         */
        _this.reprojectedImage_ = null;
        /**
         * @private
         * @type {number}
         */
        _this.reprojectedRevision_ = 0;
        return _this;
    }
    /**
     * @return {Array<number>|null} Resolutions.
     */
    ImageSource.prototype.getResolutions = function () {
        return this.resolutions_;
    };
    /**
     * @protected
     * @param {number} resolution Resolution.
     * @return {number} Resolution.
     */
    ImageSource.prototype.findNearestResolution = function (resolution) {
        if (this.resolutions_) {
            var idx = Object(ol_array["f" /* linearFindNearest */])(this.resolutions_, resolution, 0);
            resolution = this.resolutions_[idx];
        }
        return resolution;
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../ImageBase.js").default} Single image.
     */
    ImageSource.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
        var sourceProjection = this.getProjection();
        if (!common["a" /* ENABLE_RASTER_REPROJECTION */] ||
            !sourceProjection ||
            !projection ||
            Object(ol_proj["i" /* equivalent */])(sourceProjection, projection)) {
            if (sourceProjection) {
                projection = sourceProjection;
            }
            return this.getImageInternal(extent, resolution, pixelRatio, projection);
        }
        else {
            if (this.reprojectedImage_) {
                if (this.reprojectedRevision_ == this.getRevision() &&
                    Object(ol_proj["i" /* equivalent */])(this.reprojectedImage_.getProjection(), projection) &&
                    this.reprojectedImage_.getResolution() == resolution &&
                    Object(ol_extent["o" /* equals */])(this.reprojectedImage_.getExtent(), extent)) {
                    return this.reprojectedImage_;
                }
                this.reprojectedImage_.dispose();
                this.reprojectedImage_ = null;
            }
            this.reprojectedImage_ = new reproj_Image(sourceProjection, projection, extent, resolution, pixelRatio, function (extent, resolution, pixelRatio) {
                return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
            }.bind(this), this.getInterpolate());
            this.reprojectedRevision_ = this.getRevision();
            return this.reprojectedImage_;
        }
    };
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../ImageBase.js").default} Single image.
     * @protected
     */
    ImageSource.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Handle image change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    ImageSource.prototype.handleImageChange = function (event) {
        var image = /** @type {import("../Image.js").default} */ (event.target);
        var type;
        switch (image.getState()) {
            case ImageState["a" /* default */].LOADING:
                this.loading = true;
                type = ImageSourceEventType.IMAGELOADSTART;
                break;
            case ImageState["a" /* default */].LOADED:
                this.loading = false;
                type = ImageSourceEventType.IMAGELOADEND;
                break;
            case ImageState["a" /* default */].ERROR:
                this.loading = false;
                type = ImageSourceEventType.IMAGELOADERROR;
                break;
            default:
                return;
        }
        if (this.hasListener(type)) {
            this.dispatchEvent(new ImageSourceEvent(type, image));
        }
    };
    return ImageSource;
}(Source["a" /* default */]));
/**
 * Default image load function for image sources that use import("../Image.js").Image image
 * instances.
 * @param {import("../Image.js").default} image Image.
 * @param {string} src Source.
 */
function defaultImageLoadFunction(image, src) {
    /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;
}
/* harmony default export */ var source_Image = (Image_ImageSource);
//# sourceMappingURL=Image.js.map
// EXTERNAL MODULE: ./node_modules/ol/Image.js
var ol_Image = __webpack_require__("6611");

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var ol_dom = __webpack_require__("0999");

// CONCATENATED MODULE: ./node_modules/ol/source/ImageStatic.js
/**
 * @module ol/source/ImageStatic
 */
var ImageStatic_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} [imageExtent] Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [imageSmoothing=true] Deprecated.  Use the `interpolate` option instead.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("../size.js").Size} [imageSize] Size of the image in pixels. Usually the image size is auto-detected, so this
 * only needs to be set if auto-detection fails for some reason.
 * @property {string} url Image URL.
 */
/**
 * @classdesc
 * A layer source for displaying a single, static image.
 * @api
 */
var ImageStatic_Static = /** @class */ (function (_super) {
    ImageStatic_extends(Static, _super);
    /**
     * @param {Options} options ImageStatic options.
     */
    function Static(options) {
        var _this = this;
        var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
        var /** @type {import("../Image.js").LoadFunction} */ imageLoadFunction = options.imageLoadFunction !== undefined
            ? options.imageLoadFunction
            : defaultImageLoadFunction;
        var interpolate = options.imageSmoothing !== undefined ? options.imageSmoothing : true;
        if (options.interpolate !== undefined) {
            interpolate = options.interpolate;
        }
        _this = _super.call(this, {
            attributions: options.attributions,
            interpolate: interpolate,
            projection: Object(ol_proj["m" /* get */])(options.projection),
        }) || this;
        /**
         * @private
         * @type {string}
         */
        _this.url_ = options.url;
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */
        _this.imageExtent_ = options.imageExtent;
        /**
         * @private
         * @type {import("../Image.js").default}
         */
        _this.image_ = new ol_Image["a" /* default */](_this.imageExtent_, undefined, 1, _this.url_, crossOrigin, imageLoadFunction);
        /**
         * @private
         * @type {import("../size.js").Size|null}
         */
        _this.imageSize_ = options.imageSize ? options.imageSize : null;
        _this.image_.addEventListener(EventType["a" /* default */].CHANGE, _this.handleImageChange.bind(_this));
        return _this;
    }
    /**
     * Returns the image extent
     * @return {import("../extent.js").Extent} image extent.
     * @api
     */
    Static.prototype.getImageExtent = function () {
        return this.imageExtent_;
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
    Static.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
        if (Object(ol_extent["E" /* intersects */])(extent, this.image_.getExtent())) {
            return this.image_;
        }
        return null;
    };
    /**
     * Return the URL used for this image source.
     * @return {string} URL.
     * @api
     */
    Static.prototype.getUrl = function () {
        return this.url_;
    };
    /**
     * @param {import("../events/Event.js").default} evt Event.
     */
    Static.prototype.handleImageChange = function (evt) {
        if (this.image_.getState() == ImageState["a" /* default */].LOADED) {
            var imageExtent = this.image_.getExtent();
            var image = this.image_.getImage();
            var imageWidth = void 0, imageHeight = void 0;
            if (this.imageSize_) {
                imageWidth = this.imageSize_[0];
                imageHeight = this.imageSize_[1];
            }
            else {
                imageWidth = image.width;
                imageHeight = image.height;
            }
            var extentWidth = Object(ol_extent["D" /* getWidth */])(imageExtent);
            var extentHeight = Object(ol_extent["z" /* getHeight */])(imageExtent);
            var xResolution = extentWidth / imageWidth;
            var yResolution = extentHeight / imageHeight;
            var targetWidth = imageWidth;
            var targetHeight = imageHeight;
            if (xResolution > yResolution) {
                targetWidth = Math.round(extentWidth / yResolution);
            }
            else {
                targetHeight = Math.round(extentHeight / xResolution);
            }
            if (targetWidth !== imageWidth || targetHeight !== imageHeight) {
                var context = Object(ol_dom["a" /* createCanvasContext2D */])(targetWidth, targetHeight);
                if (!this.getInterpolate()) {
                    Object(ol_obj["a" /* assign */])(context, canvas_common["a" /* IMAGE_SMOOTHING_DISABLED */]);
                }
                var canvas = context.canvas;
                context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
                this.image_.setImage(canvas);
            }
        }
        _super.prototype.handleImageChange.call(this, evt);
    };
    return Static;
}(source_Image));
/* harmony default export */ var ImageStatic = (ImageStatic_Static);
//# sourceMappingURL=ImageStatic.js.map
// EXTERNAL MODULE: ./node_modules/ol/source/Vector.js + 2 modules
var source_Vector = __webpack_require__("5831");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js
var GeometryType = __webpack_require__("f623");

// EXTERNAL MODULE: ./node_modules/ol/geom/Point.js
var Point = __webpack_require__("f403");

// EXTERNAL MODULE: ./node_modules/ol/coordinate.js
var ol_coordinate = __webpack_require__("a568");

// CONCATENATED MODULE: ./node_modules/ol/source/Cluster.js
/**
 * @module ol/source/Cluster
 */
var Cluster_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [distance=20] Distance in pixels within which features will
 * be clustered together.
 * @property {number} [minDistance=0] Minimum distance in pixels between clusters.
 * Will be capped at the configured distance.
 * By default no minimum distance is guaranteed. This config can be used to avoid
 * overlapping icons. As a tradoff, the cluster feature's position will no longer be
 * the center of all its features.
 * @property {function(Feature):Point} [geometryFunction]
 * Function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Point~Point} as cluster calculation point for the feature. When a
 * feature should not be considered for clustering, the function should return
 * `null`. The default, which works when the underlying source contains point
 * features only, is
 * ```js
 * function(feature) {
 *   return feature.getGeometry();
 * }
 * ```
 * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
 * calculation point for polygons.
 * @property {function(Point, Array<Feature>):Feature} [createCluster]
 * Function that takes the cluster's center {@link module:ol/geom/Point~Point} and an array
 * of {@link module:ol/Feature~Feature} included in this cluster. Must return a
 * {@link module:ol/Feature~Feature} that will be used to render. Default implementation is:
 * ```js
 * function(point, features) {
 *   return new Feature({
 *     geometry: point,
 *     features: features
 *   });
 * }
 * ```
 * @property {VectorSource} [source=null] Source.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */
/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 *
 * If the instance is disposed without also disposing the underlying
 * source `setSource(null)` has to be called to remove the listener reference
 * from the wrapped source.
 * @api
 */
var Cluster_Cluster = /** @class */ (function (_super) {
    Cluster_extends(Cluster, _super);
    /**
     * @param {Options} options Cluster options.
     */
    function Cluster(options) {
        var _this = _super.call(this, {
            attributions: options.attributions,
            wrapX: options.wrapX,
        }) || this;
        /**
         * @type {number|undefined}
         * @protected
         */
        _this.resolution = undefined;
        /**
         * @type {number}
         * @protected
         */
        _this.distance = options.distance !== undefined ? options.distance : 20;
        /**
         * @type {number}
         * @protected
         */
        _this.minDistance = options.minDistance || 0;
        /**
         * @type {number}
         * @protected
         */
        _this.interpolationRatio = 0;
        /**
         * @type {Array<Feature>}
         * @protected
         */
        _this.features = [];
        /**
         * @param {Feature} feature Feature.
         * @return {Point} Cluster calculation point.
         * @protected
         */
        _this.geometryFunction =
            options.geometryFunction ||
                function (feature) {
                    var geometry = /** @type {Point} */ (feature.getGeometry());
                    Object(asserts["a" /* assert */])(geometry.getType() == GeometryType["a" /* default */].POINT, 10); // The default `geometryFunction` can only handle `Point` geometries
                    return geometry;
                };
        /**
         * @type {function(Point, Array<Feature>):Feature}
         * @private
         */
        _this.createCustomCluster_ = options.createCluster;
        /**
         * @type {VectorSource|null}
         * @protected
         */
        _this.source = null;
        /**
         * @private
         */
        _this.boundRefresh_ = _this.refresh.bind(_this);
        _this.updateDistance(_this.distance, _this.minDistance);
        _this.setSource(options.source || null);
        return _this;
    }
    /**
     * Remove all features from the source.
     * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
     * @api
     */
    Cluster.prototype.clear = function (opt_fast) {
        this.features.length = 0;
        _super.prototype.clear.call(this, opt_fast);
    };
    /**
     * Get the distance in pixels between clusters.
     * @return {number} Distance.
     * @api
     */
    Cluster.prototype.getDistance = function () {
        return this.distance;
    };
    /**
     * Get a reference to the wrapped source.
     * @return {VectorSource|null} Source.
     * @api
     */
    Cluster.prototype.getSource = function () {
        return this.source;
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    Cluster.prototype.loadFeatures = function (extent, resolution, projection) {
        this.source.loadFeatures(extent, resolution, projection);
        if (resolution !== this.resolution) {
            this.resolution = resolution;
            this.refresh();
        }
    };
    /**
     * Set the distance within which features will be clusterd together.
     * @param {number} distance The distance in pixels.
     * @api
     */
    Cluster.prototype.setDistance = function (distance) {
        this.updateDistance(distance, this.minDistance);
    };
    /**
     * Set the minimum distance between clusters. Will be capped at the
     * configured distance.
     * @param {number} minDistance The minimum distance in pixels.
     * @api
     */
    Cluster.prototype.setMinDistance = function (minDistance) {
        this.updateDistance(this.distance, minDistance);
    };
    /**
     * The configured minimum distance between clusters.
     * @return {number} The minimum distance in pixels.
     * @api
     */
    Cluster.prototype.getMinDistance = function () {
        return this.minDistance;
    };
    /**
     * Replace the wrapped source.
     * @param {VectorSource|null} source The new source for this instance.
     * @api
     */
    Cluster.prototype.setSource = function (source) {
        if (this.source) {
            this.source.removeEventListener(EventType["a" /* default */].CHANGE, this.boundRefresh_);
        }
        this.source = source;
        if (source) {
            source.addEventListener(EventType["a" /* default */].CHANGE, this.boundRefresh_);
        }
        this.refresh();
    };
    /**
     * Handle the source changing.
     */
    Cluster.prototype.refresh = function () {
        this.clear();
        this.cluster();
        this.addFeatures(this.features);
    };
    /**
     * Update the distances and refresh the source if necessary.
     * @param {number} distance The new distance.
     * @param {number} minDistance The new minimum distance.
     */
    Cluster.prototype.updateDistance = function (distance, minDistance) {
        var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
        var changed = distance !== this.distance || this.interpolationRatio !== ratio;
        this.distance = distance;
        this.minDistance = minDistance;
        this.interpolationRatio = ratio;
        if (changed) {
            this.refresh();
        }
    };
    /**
     * @protected
     */
    Cluster.prototype.cluster = function () {
        if (this.resolution === undefined || !this.source) {
            return;
        }
        var extent = Object(ol_extent["j" /* createEmpty */])();
        var mapDistance = this.distance * this.resolution;
        var features = this.source.getFeatures();
        /** @type {Object<string, true>} */
        var clustered = {};
        for (var i = 0, ii = features.length; i < ii; i++) {
            var feature = features[i];
            if (!(Object(util["c" /* getUid */])(feature) in clustered)) {
                var geometry = this.geometryFunction(feature);
                if (geometry) {
                    var coordinates = geometry.getCoordinates();
                    Object(ol_extent["m" /* createOrUpdateFromCoordinate */])(coordinates, extent);
                    Object(ol_extent["c" /* buffer */])(extent, mapDistance, extent);
                    var neighbors = this.source
                        .getFeaturesInExtent(extent)
                        .filter(function (neighbor) {
                        var uid = Object(util["c" /* getUid */])(neighbor);
                        if (uid in clustered) {
                            return false;
                        }
                        clustered[uid] = true;
                        return true;
                    });
                    this.features.push(this.createCluster(neighbors, extent));
                }
            }
        }
    };
    /**
     * @param {Array<Feature>} features Features
     * @param {import("../extent.js").Extent} extent The searched extent for these features.
     * @return {Feature} The cluster feature.
     * @protected
     */
    Cluster.prototype.createCluster = function (features, extent) {
        var centroid = [0, 0];
        for (var i = features.length - 1; i >= 0; --i) {
            var geometry_1 = this.geometryFunction(features[i]);
            if (geometry_1) {
                Object(ol_coordinate["a" /* add */])(centroid, geometry_1.getCoordinates());
            }
            else {
                features.splice(i, 1);
            }
        }
        Object(ol_coordinate["g" /* scale */])(centroid, 1 / features.length);
        var searchCenter = Object(ol_extent["w" /* getCenter */])(extent);
        var ratio = this.interpolationRatio;
        var geometry = new Point["a" /* default */]([
            centroid[0] * (1 - ratio) + searchCenter[0] * ratio,
            centroid[1] * (1 - ratio) + searchCenter[1] * ratio,
        ]);
        if (this.createCustomCluster_) {
            return this.createCustomCluster_(geometry, features);
        }
        else {
            return new Feature["a" /* default */]({
                geometry: geometry,
                features: features,
            });
        }
    };
    return Cluster;
}(source_Vector["a" /* default */]));
/* harmony default export */ var source_Cluster = (Cluster_Cluster);
//# sourceMappingURL=Cluster.js.map
// EXTERNAL MODULE: ./node_modules/ol/Object.js
var ol_Object = __webpack_require__("e269");

// EXTERNAL MODULE: ./node_modules/ol/MapEventType.js
var MapEventType = __webpack_require__("592d");

// CONCATENATED MODULE: ./node_modules/ol/OverlayPositioning.js
/**
 * @module ol/OverlayPositioning
 */
/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */
/* harmony default export */ var OverlayPositioning = ({
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_CENTER: 'bottom-center',
    BOTTOM_RIGHT: 'bottom-right',
    CENTER_LEFT: 'center-left',
    CENTER_CENTER: 'center-center',
    CENTER_RIGHT: 'center-right',
    TOP_LEFT: 'top-left',
    TOP_CENTER: 'top-center',
    TOP_RIGHT: 'top-right',
});
//# sourceMappingURL=OverlayPositioning.js.map
// EXTERNAL MODULE: ./node_modules/ol/css.js
var css = __webpack_require__("cd7e");

// CONCATENATED MODULE: ./node_modules/ol/Overlay.js
var Overlay_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/Overlay
 */







/**
 * @typedef {Object} Options
 * @property {number|string} [id] Set the overlay id. The overlay id can be used
 * with the {@link module:ol/Map~Map#getOverlayById} method.
 * @property {HTMLElement} [element] The overlay element.
 * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
 * the overlay. The first element in the
 * array is the horizontal offset. A positive value shifts the overlay right.
 * The second element in the array is the vertical offset. A positive value
 * shifts the overlay down.
 * @property {import("./coordinate.js").Coordinate} [position] The overlay position
 * in map projection.
 * @property {import("./OverlayPositioning.js").default} [positioning='top-left'] Defines how
 * the overlay is actually positioned with respect to its `position` property.
 * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, and `'top-right'`.
 * @property {boolean} [stopEvent=true] Whether event propagation to the map
 * viewport should be stopped. If `true` the overlay is placed in the same
 * container as that of the controls (CSS class name
 * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
 * with CSS class name specified by the `className` property.
 * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
 * in the overlay container, or appended. If the overlay is placed in the same
 * container as that of the controls (see the `stopEvent` option) you will
 * probably set `insertFirst` to `true` so the overlay is displayed below the
 * controls.
 * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
 * `setPosition`, so that the overlay is entirely visible in the current viewport?
 * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
 * used to determine the panning parameters; if an object is supplied then other
 * parameters are ignored.
 * @property {PanOptions} [autoPanAnimation] The animation options used to pan
 * the overlay into view. This animation is only used when `autoPan` is enabled.
 * A `duration` and `easing` may be provided to customize the animation.
 * Deprecated and ignored if `autoPan` is supplied as an object.
 * @property {number} [autoPanMargin=20] The margin (in pixels) between the
 * overlay and the borders of the map when autopanning. Deprecated and ignored
 * if `autoPan` is supplied as an object.
 * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
 * autoPan. This is only used when `autoPan` is enabled and has preference over
 * the individual `autoPanMargin` and `autoPanOptions`.
 * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
 * name.
 */
/**
 * @typedef {Object} PanOptions
 * @property {number} [duration=1000] The duration of the animation in
 * milliseconds.
 * @property {function(number):number} [easing] The easing function to use. Can
 * be one from {@link module:ol/easing} or a custom function.
 * Default is {@link module:ol/easing.inAndOut}.
 */
/**
 * @typedef {Object} PanIntoViewOptions
 * @property {PanOptions} [animation={}] The animation parameters for the pan
 * @property {number} [margin=20] The margin (in pixels) between the
 * overlay and the borders of the map when panning into view.
 */
/**
 * @enum {string}
 * @protected
 */
var Property = {
    ELEMENT: 'element',
    MAP: 'map',
    OFFSET: 'offset',
    POSITION: 'position',
    POSITIONING: 'positioning',
};
/**
 * @typedef {import("./ObjectEventType").Types|'change:element'|'change:map'|'change:offset'|'change:position'|
 *   'change:positioning'} OverlayObjectEventTypes
 */
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<OverlayObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature
 */
/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:ol/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'ol/Overlay';
 *
 *     var popup = new Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */
var Overlay_Overlay = /** @class */ (function (_super) {
    Overlay_extends(Overlay, _super);
    /**
     * @param {Options} options Overlay options.
     */
    function Overlay(options) {
        var _this = _super.call(this) || this;
        /***
         * @type {OverlayOnSignature<import("./events").EventsKey>}
         */
        _this.on;
        /***
         * @type {OverlayOnSignature<import("./events").EventsKey>}
         */
        _this.once;
        /***
         * @type {OverlayOnSignature<void>}
         */
        _this.un;
        /**
         * @protected
         * @type {Options}
         */
        _this.options = options;
        /**
         * @protected
         * @type {number|string|undefined}
         */
        _this.id = options.id;
        /**
         * @protected
         * @type {boolean}
         */
        _this.insertFirst =
            options.insertFirst !== undefined ? options.insertFirst : true;
        /**
         * @protected
         * @type {boolean}
         */
        _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
        /**
         * @protected
         * @type {HTMLElement}
         */
        _this.element = document.createElement('div');
        _this.element.className =
            options.className !== undefined
                ? options.className
                : 'ol-overlay-container ' + css["d" /* CLASS_SELECTABLE */];
        _this.element.style.position = 'absolute';
        _this.element.style.pointerEvents = 'auto';
        var autoPan = options.autoPan;
        if (autoPan && 'object' !== typeof autoPan) {
            autoPan = {
                animation: options.autoPanAnimation,
                margin: options.autoPanMargin,
            };
        }
        /**
         * @protected
         * @type {PanIntoViewOptions|false}
         */
        _this.autoPan = /** @type {PanIntoViewOptions} */ (autoPan) || false;
        /**
         * @protected
         * @type {{transform_: string,
         *         visible: boolean}}
         */
        _this.rendered = {
            transform_: '',
            visible: true,
        };
        /**
         * @protected
         * @type {?import("./events.js").EventsKey}
         */
        _this.mapPostrenderListenerKey = null;
        _this.addChangeListener(Property.ELEMENT, _this.handleElementChanged);
        _this.addChangeListener(Property.MAP, _this.handleMapChanged);
        _this.addChangeListener(Property.OFFSET, _this.handleOffsetChanged);
        _this.addChangeListener(Property.POSITION, _this.handlePositionChanged);
        _this.addChangeListener(Property.POSITIONING, _this.handlePositioningChanged);
        if (options.element !== undefined) {
            _this.setElement(options.element);
        }
        _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
        _this.setPositioning(options.positioning !== undefined
            ? /** @type {import("./OverlayPositioning.js").default} */ (options.positioning)
            : OverlayPositioning.TOP_LEFT);
        if (options.position !== undefined) {
            _this.setPosition(options.position);
        }
        return _this;
    }
    /**
     * Get the DOM element of this overlay.
     * @return {HTMLElement|undefined} The Element containing the overlay.
     * @observable
     * @api
     */
    Overlay.prototype.getElement = function () {
        return /** @type {HTMLElement|undefined} */ (this.get(Property.ELEMENT));
    };
    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */
    Overlay.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get the map associated with this overlay.
     * @return {import("./PluggableMap.js").default|null} The map that the
     * overlay is part of.
     * @observable
     * @api
     */
    Overlay.prototype.getMap = function () {
        return /** @type {import("./PluggableMap.js").default|null} */ (this.get(Property.MAP) || null);
    };
    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */
    Overlay.prototype.getOffset = function () {
        return /** @type {Array<number>} */ (this.get(Property.OFFSET));
    };
    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */
    Overlay.prototype.getPosition = function () {
        return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(Property.POSITION));
    };
    /**
     * Get the current positioning of this overlay.
     * @return {import("./OverlayPositioning.js").default} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */
    Overlay.prototype.getPositioning = function () {
        return /** @type {import("./OverlayPositioning.js").default} */ (this.get(Property.POSITIONING));
    };
    /**
     * @protected
     */
    Overlay.prototype.handleElementChanged = function () {
        Object(ol_dom["d" /* removeChildren */])(this.element);
        var element = this.getElement();
        if (element) {
            this.element.appendChild(element);
        }
    };
    /**
     * @protected
     */
    Overlay.prototype.handleMapChanged = function () {
        if (this.mapPostrenderListenerKey) {
            Object(ol_dom["e" /* removeNode */])(this.element);
            Object(events["c" /* unlistenByKey */])(this.mapPostrenderListenerKey);
            this.mapPostrenderListenerKey = null;
        }
        var map = this.getMap();
        if (map) {
            this.mapPostrenderListenerKey = Object(events["a" /* listen */])(map, MapEventType["a" /* default */].POSTRENDER, this.render, this);
            this.updatePixelPosition();
            var container = this.stopEvent
                ? map.getOverlayContainerStopEvent()
                : map.getOverlayContainer();
            if (this.insertFirst) {
                container.insertBefore(this.element, container.childNodes[0] || null);
            }
            else {
                container.appendChild(this.element);
            }
            this.performAutoPan();
        }
    };
    /**
     * @protected
     */
    Overlay.prototype.render = function () {
        this.updatePixelPosition();
    };
    /**
     * @protected
     */
    Overlay.prototype.handleOffsetChanged = function () {
        this.updatePixelPosition();
    };
    /**
     * @protected
     */
    Overlay.prototype.handlePositionChanged = function () {
        this.updatePixelPosition();
        this.performAutoPan();
    };
    /**
     * @protected
     */
    Overlay.prototype.handlePositioningChanged = function () {
        this.updatePixelPosition();
    };
    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */
    Overlay.prototype.setElement = function (element) {
        this.set(Property.ELEMENT, element);
    };
    /**
     * Set the map to be associated with this overlay.
     * @param {import("./PluggableMap.js").default|null} map The map that the
     * overlay is part of. Pass `null` to just remove the overlay from the current map.
     * @observable
     * @api
     */
    Overlay.prototype.setMap = function (map) {
        this.set(Property.MAP, map);
    };
    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */
    Overlay.prototype.setOffset = function (offset) {
        this.set(Property.OFFSET, offset);
    };
    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */
    Overlay.prototype.setPosition = function (position) {
        this.set(Property.POSITION, position);
    };
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */
    Overlay.prototype.performAutoPan = function () {
        if (this.autoPan) {
            this.panIntoView(this.autoPan);
        }
    };
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [opt_panIntoViewOptions] Options for the pan action
     * @api
     */
    Overlay.prototype.panIntoView = function (opt_panIntoViewOptions) {
        var map = this.getMap();
        if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {
            return;
        }
        var mapRect = this.getRect(map.getTargetElement(), map.getSize());
        var element = this.getElement();
        var overlayRect = this.getRect(element, [
            Object(ol_dom["c" /* outerWidth */])(element),
            Object(ol_dom["b" /* outerHeight */])(element),
        ]);
        var panIntoViewOptions = opt_panIntoViewOptions || {};
        var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;
        if (!Object(ol_extent["g" /* containsExtent */])(mapRect, overlayRect)) {
            // the overlay is not completely inside the viewport, so pan the map
            var offsetLeft = overlayRect[0] - mapRect[0];
            var offsetRight = mapRect[2] - overlayRect[2];
            var offsetTop = overlayRect[1] - mapRect[1];
            var offsetBottom = mapRect[3] - overlayRect[3];
            var delta = [0, 0];
            if (offsetLeft < 0) {
                // move map to the left
                delta[0] = offsetLeft - myMargin;
            }
            else if (offsetRight < 0) {
                // move map to the right
                delta[0] = Math.abs(offsetRight) + myMargin;
            }
            if (offsetTop < 0) {
                // move map up
                delta[1] = offsetTop - myMargin;
            }
            else if (offsetBottom < 0) {
                // move map down
                delta[1] = Math.abs(offsetBottom) + myMargin;
            }
            if (delta[0] !== 0 || delta[1] !== 0) {
                var center = /** @type {import("./coordinate.js").Coordinate} */ (map.getView().getCenterInternal());
                var centerPx = map.getPixelFromCoordinateInternal(center);
                if (!centerPx) {
                    return;
                }
                var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
                var panOptions = panIntoViewOptions.animation || {};
                map.getView().animateInternal({
                    center: map.getCoordinateFromPixelInternal(newCenterPx),
                    duration: panOptions.duration,
                    easing: panOptions.easing,
                });
            }
        }
    };
    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */
    Overlay.prototype.getRect = function (element, size) {
        var box = element.getBoundingClientRect();
        var offsetX = box.left + window.pageXOffset;
        var offsetY = box.top + window.pageYOffset;
        return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
    };
    /**
     * Set the positioning for this overlay.
     * @param {import("./OverlayPositioning.js").default} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */
    Overlay.prototype.setPositioning = function (positioning) {
        this.set(Property.POSITIONING, positioning);
    };
    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */
    Overlay.prototype.setVisible = function (visible) {
        if (this.rendered.visible !== visible) {
            this.element.style.display = visible ? '' : 'none';
            this.rendered.visible = visible;
        }
    };
    /**
     * Update pixel position.
     * @protected
     */
    Overlay.prototype.updatePixelPosition = function () {
        var map = this.getMap();
        var position = this.getPosition();
        if (!map || !map.isRendered() || !position) {
            this.setVisible(false);
            return;
        }
        var pixel = map.getPixelFromCoordinate(position);
        var mapSize = map.getSize();
        this.updateRenderedPosition(pixel, mapSize);
    };
    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */
    Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
        var style = this.element.style;
        var offset = this.getOffset();
        var positioning = this.getPositioning();
        this.setVisible(true);
        var x = Math.round(pixel[0] + offset[0]) + 'px';
        var y = Math.round(pixel[1] + offset[1]) + 'px';
        var posX = '0%';
        var posY = '0%';
        if (positioning == OverlayPositioning.BOTTOM_RIGHT ||
            positioning == OverlayPositioning.CENTER_RIGHT ||
            positioning == OverlayPositioning.TOP_RIGHT) {
            posX = '-100%';
        }
        else if (positioning == OverlayPositioning.BOTTOM_CENTER ||
            positioning == OverlayPositioning.CENTER_CENTER ||
            positioning == OverlayPositioning.TOP_CENTER) {
            posX = '-50%';
        }
        if (positioning == OverlayPositioning.BOTTOM_LEFT ||
            positioning == OverlayPositioning.BOTTOM_CENTER ||
            positioning == OverlayPositioning.BOTTOM_RIGHT) {
            posY = '-100%';
        }
        else if (positioning == OverlayPositioning.CENTER_LEFT ||
            positioning == OverlayPositioning.CENTER_CENTER ||
            positioning == OverlayPositioning.CENTER_RIGHT) {
            posY = '-50%';
        }
        var transform = "translate(".concat(posX, ", ").concat(posY, ") translate(").concat(x, ", ").concat(y, ")");
        if (this.rendered.transform_ != transform) {
            this.rendered.transform_ = transform;
            style.transform = transform;
            // @ts-ignore IE9
            style.msTransform = transform;
        }
    };
    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */
    Overlay.prototype.getOptions = function () {
        return this.options;
    };
    return Overlay;
}(ol_Object["a" /* default */]));
/* harmony default export */ var ol_Overlay = (Overlay_Overlay);
//# sourceMappingURL=Overlay.js.map
// EXTERNAL MODULE: ./node_modules/ol/geom/Circle.js
var Circle = __webpack_require__("f822");

// EXTERNAL MODULE: ./node_modules/ol/geom/LineString.js
var LineString = __webpack_require__("7a09");

// EXTERNAL MODULE: ./node_modules/ol/style/Style.js
var Style = __webpack_require__("6c77");

// EXTERNAL MODULE: ./node_modules/ol/style/Icon.js + 1 modules
var Icon = __webpack_require__("6cbf");

// EXTERNAL MODULE: ./node_modules/ol/style/Stroke.js
var Stroke = __webpack_require__("8682");

// EXTERNAL MODULE: ./node_modules/ol/style/Text.js
var Text = __webpack_require__("8295");

// EXTERNAL MODULE: ./node_modules/ol/style/Fill.js
var Fill = __webpack_require__("83a6");

// EXTERNAL MODULE: ./node_modules/ol/style/Circle.js + 1 modules
var style_Circle = __webpack_require__("ce2c");

// CONCATENATED MODULE: ./src/plugins/wg-ol-plugin/custom-styles.js



/* harmony default export */ var custom_styles = ({
  disasterLineFunc: function disasterLineFunc(feature) {
    var featureRemark = feature.get('featureRemark');
    var sign = feature.get('sign');
    var style;

    if (feature.getGeometry().getType() == 'Point') {
      var src;

      if (sign != true) {
        switch (featureRemark.notice_category) {
          case '預警性管制':
            src = __webpack_require__("c692");
            break;

          case '災阻':
            src = __webpack_require__("02de");
            break;

          case '災情':
            src = __webpack_require__("936b");
            break;
        }
      } else {
        src = __webpack_require__("02de"); // switch (featureRemark.notice_category) {
        //   case "預警性管制":
        //     src = require("@/assets/show_point/point_7_1.png")
        //   break
        //   case "災阻":
        //     src = require("@/assets/show_point/point_7_3.png")
        //   break
        //   case "災情":
        //     src = require("@/assets/show_point/point_7_4.png")
        //   break
        // }
      }

      style = new Style["c" /* default */]({
        image: new Icon["a" /* default */]({
          src: src,
          size: [30, 30],
          anchor: [0.5, 1],
          anchorXUnits: 'fraction',
          anchorYUnits: 'fraction'
        })
      });
    } else {
      style = new Style["c" /* default */]({
        stroke: new Stroke["a" /* default */]({
          color: 'rgba(181, 27, 27)',
          width: 10
        })
      });
    }

    return style;
  },
  disasterLineClusterFunc: function disasterLineClusterFunc(feature) {
    var featureRemark = '';
    var size = '';

    if (feature.get('features') != undefined) {
      featureRemark = feature.get('features')[0].get('featureRemark');
      size = feature.get('features').length;
    }

    var style;

    if (feature.getGeometry().getType() == 'Point') {
      var src = '';

      switch (featureRemark.notice_category) {
        case '預警性管制':
          src = __webpack_require__("02de");
          break;

        case '災阻':
          src = __webpack_require__("c866");
          break;

        case '災情':
          src = __webpack_require__("936b");
          break;
      }

      style = new Style["c" /* default */]({
        image: new Icon["a" /* default */]({
          src: src,
          size: [30, 30],
          anchor: [0.5, 1],
          anchorXUnits: 'fraction',
          anchorYUnits: 'fraction'
        }),
        text: new Text["a" /* default */]({
          text: size.toString(),
          fill: new Fill["a" /* default */]({
            color: '#fff'
          }),
          scale: [1.7, 1.7],
          backgroundFill: new Fill["a" /* default */]({
            color: 'rgb(120, 120, 120, 0.7)'
          }),
          offsetY: 15,
          padding: [1, 7, 0, 10],
          textAlign: 'center'
        })
      });
    }

    return style;
  },
  closeRoadLineFunc: function closeRoadLineFunc(feature) {
    var style;

    if (feature.getGeometry().getType() == 'Point') {
      var src = __webpack_require__("02de");

      style = new Style["c" /* default */]({
        image: new Icon["a" /* default */]({
          src: src,
          size: [30, 30],
          anchor: [0.5, 1],
          anchorXUnits: 'fraction',
          anchorYUnits: 'fraction'
        })
      });
    } else {
      style = new Style["c" /* default */]({
        stroke: new Stroke["a" /* default */]({
          color: 'rgba(181, 27, 27)',
          width: 10
        })
      });
    }

    return style;
  },
  roadLine: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(245,0,87,1)',
      width: 5
    })
  }),
  roadStakePoint: function roadStakePoint(feature) {
    return new Style["c" /* default */]({
      image: new style_Circle["a" /* default */]({
        radius: 7,
        fill: new Fill["a" /* default */]({
          color: 'rgba(170,0,255,1)'
        })
      }),
      text: new Text["a" /* default */]({
        text: feature.get('featureRemark').text,
        scale: [1.7, 1.7],
        offsetY: -25,
        padding: [1, 7, 0, 10],
        textAlign: 'center',
        fill: new Fill["a" /* default */]({
          color: 'rgba(255,255,255,1)'
        }),
        backgroundFill: new Fill["a" /* default */]({
          color: 'rgba(74,20,140,0.7)'
        }),
        backgroundStroke: new Stroke["a" /* default */]({
          color: 'rgba(123,31,162,1)',
          width: 2
        })
      })
    });
  },
  exportExtentPolygon: new Style["c" /* default */]({
    fill: new Fill["a" /* default */]({
      color: 'rgba(255,255,255,0)'
    }),
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(255,204,51,1)',
      width: 2
    })
  }),
  currentPositionPoint: new Style["c" /* default */]({
    image: new style_Circle["a" /* default */]({
      radius: 10,
      fill: new Fill["a" /* default */]({
        color: 'rgba(213,0,0,1)'
      })
    })
  }),
  remoteControlPoint: new Style["c" /* default */]({
    image: new style_Circle["a" /* default */]({
      radius: 10,
      fill: new Fill["a" /* default */]({
        color: 'rgba(98,0,234,1)'
      })
    })
  }),
  nearendControlPoint: new Style["c" /* default */]({
    image: new style_Circle["a" /* default */]({
      radius: 10,
      fill: new Fill["a" /* default */]({
        color: 'rgba(255,109,0,1)'
      })
    })
  }),
  controlRoadLineString: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(3,169,244,1)',
      width: 8
    })
  }),
  alternativeRoadLineString: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(98,0,234,1)',
      width: 4,
      lineDash: [10, 8]
    })
  }),
  controlRoadPolygon: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(3,169,244,1)',
      width: 8
    })
  }),
  alternativeRoadPolygon: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(98,0,234,1)',
      width: 4,
      lineDash: [10, 8]
    })
  }),
  line01: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(203,67,53,1)',
      width: 5
    })
  }),
  customPointFunc: function customPointFunc(feature) {
    var img = feature.get('imgName');
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("bbec")("./" + img + ".png"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  floodPointFunc: function floodPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("17f2"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  rainPointFunc: function rainPointFunc(feature) {
    var featureRemark = feature.get('featureRemark');

    var statusIcon = __webpack_require__("3b0c");

    if (featureRemark.hour_24 >= 500) {
      statusIcon = __webpack_require__("238b");
    } else if (featureRemark.hour_24 >= 350 || featureRemark.hour_3 >= 200) {
      statusIcon = __webpack_require__("83c0");
    } else if (featureRemark.hour_24 >= 200 || featureRemark.hour_3 >= 100) {
      statusIcon = __webpack_require__("13b4");
    } else if (featureRemark.hour_24 >= 80 || featureRemark.hour_1 >= 40) {
      statusIcon = __webpack_require__("271d");
    }

    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: statusIcon,
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  rainStationPointFunc: function rainStationPointFunc(feature) {
    var featureRemark = feature.get('featureRemark');

    var statusIcon = __webpack_require__("3b0c");

    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: statusIcon,
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      }),
      text: new Text["a" /* default */]({
        text: featureRemark.Name,
        font: '12px sans-serif',
        offsetY: 10,
        fill: new Fill["a" /* default */]({
          color: '#000'
        })
      })
    });
  },
  rawPointFunc: function rawPointFunc(feature) {
    var featureRemark = feature.get('featureRemark');

    var statusIcon = __webpack_require__("2b41");

    if (featureRemark.Value >= featureRemark.Alertlv1 && featureRemark.Alertlv1 != '') {
      statusIcon = __webpack_require__("399a");
    } else if (featureRemark.Value >= featureRemark.Alertlv2 && featureRemark.Alertlv1 > featureRemark.Value && featureRemark.Alertlv2 != '') {
      statusIcon = __webpack_require__("fb20");
    } else if (featureRemark.Value >= featureRemark.Alertlv3 && featureRemark.Alertlv2 > featureRemark.Value && featureRemark.Alertlv3 != '') {
      statusIcon = __webpack_require__("2846");
    }

    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: statusIcon,
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  observatoryPointFunc: function observatoryPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("5a95"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  dsPointFunc: function dsPointFunc(feature) {
    var featureRemark = feature.get('featureRemark');
    var color;
    var org = '局';

    if (featureRemark.org_2 != '') {
      org = '處';

      if (featureRemark.org_3 != '') {
        org = '段';
      }
    }

    return new Style["c" /* default */]({
      image: new style_Circle["a" /* default */]({
        radius: 15,
        fill: new Fill["a" /* default */]({
          color: color
        })
      }),
      text: new Text["a" /* default */]({
        text: org,
        font: '20px bold',
        textAlign: 'center',
        fill: new Fill["a" /* default */]({
          color: 'rgba(255,255,255,1)'
        })
      })
    });
  },
  dsTotalPointFunc: function dsTotalPointFunc(feature) {
    var color;
    var org = '處';
    return new Style["c" /* default */]({
      image: new style_Circle["a" /* default */]({
        radius: 15,
        fill: new Fill["a" /* default */]({
          color: color
        })
      }),
      text: new Text["a" /* default */]({
        text: org,
        font: '20px bold',
        textAlign: 'center',
        fill: new Fill["a" /* default */]({
          color: 'rgba(255,255,255,1)'
        })
      })
    });
  },
  dpEventPointFunc: function dpEventPointFunc(feature) {
    var featureRemark = feature.get('featureRemark');
    var color;
    var org = '局';

    if (featureRemark.org_2 != '') {
      org = '處';

      if (featureRemark.org_3 != '') {
        org = '段';
      }
    }

    if (featureRemark.level == '二級') {
      color = 'rgba(33,150,243,1)';
    } else if (featureRemark.level == '一級') {
      color = 'rgba(255,235,59,1)';
    }

    return new Style["c" /* default */]({
      image: new style_Circle["a" /* default */]({
        radius: 15,
        fill: new Fill["a" /* default */]({
          color: color
        })
      }),
      text: new Text["a" /* default */]({
        text: org,
        font: '20px bold',
        textAlign: 'center',
        fill: new Fill["a" /* default */]({
          color: 'rgba(255,255,255,1)'
        })
      })
    });
  },
  reservoirPointFunc: function reservoirPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("4763"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  currentPointFunc: function currentPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("2efd"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      }),
      text: new Text["a" /* default */]({
        text: '現在位置',
        font: '12px bold',
        offsetY: 10,
        fill: new Fill["a" /* default */]({
          color: 'gray'
        })
      })
    });
  },
  earthquakePointFunc: function earthquakePointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("734f"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  hospitalPointFunc: function hospitalPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("eef5"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  policePointFunc: function policePointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("766c"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  firedepartmentPointFunc: function firedepartmentPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("4e9e"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  oilPointFunc: function oilPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("a808"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  schoolPointFunc: function schoolPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("a305"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  freewayPointFunc: function freewayPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("eeb0"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  highwayPointFunc: function highwayPointFunc(feature) {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("74b5")("./".concat(feature.get('layerName'), ".png")),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  countyRoadPointFunc: function countyRoadPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("1b84"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  typhoonPointFunc: function typhoonPointFunc(feature) {
    var url = feature.get('styleUrl');
    var statusIcon;
    var scale;

    if (url.indexOf('fcst') >= 0) {
      statusIcon = __webpack_require__("57b3");
      scale = 0.4;
    } else if (url.indexOf('current') >= 0) {
      statusIcon = __webpack_require__("f75d");
      scale = 0.6;
    }

    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: statusIcon,
        scale: scale,
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  debrisPointFunc: function debrisPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("1b14"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  tunnelPointFunc: function tunnelPointFunc() {
    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: __webpack_require__("bae9"),
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  roadInfoManagementAlert: function roadInfoManagementAlert(feature) {
    var featureRemark = feature.get('featureRemark');

    var statusIcon = __webpack_require__("c158");

    if (featureRemark.type == '⼆級監控路段') {
      statusIcon = __webpack_require__("74f8");
    }

    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: statusIcon,
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  slopePointFunc: function slopePointFunc(feature) {
    var featureRemark = feature.get('featureRemark');
    var slope_lv;

    if (featureRemark.slope_lv == 'A級') {
      slope_lv = __webpack_require__("b358");
    } else if (featureRemark.slope_lv == 'B級') {
      slope_lv = __webpack_require__("48d6");
    } else if (featureRemark.slope_lv == 'C級') {
      slope_lv = __webpack_require__("40db");
    } else if (featureRemark.slope_lv == 'D級') {
      slope_lv = __webpack_require__("b401");
    } else if (featureRemark.slope_lv == '其他') {
      slope_lv = __webpack_require__("8322");
    }

    return new Style["c" /* default */]({
      image: new Icon["a" /* default */]({
        src: slope_lv,
        size: [30, 30],
        anchor: [0.5, 1],
        anchorXUnits: 'fraction',
        anchorYUnits: 'fraction'
      })
    });
  },
  monitorRoadPointFunc: function monitorRoadPointFunc(feature) {
    var style;

    if (feature.getGeometry().getType() == 'Point') {
      var featureRemark = feature.get('featureRemark');
      var org;

      if (featureRemark.monitor_type == '一級監控路段') {
        org = '一';
      } else if (featureRemark.slope_lv == '二級監控路段') {
        org = '二';
      } else if (featureRemark.slope_lv == '一級監控橋梁') {
        org = '橋';
      } else if (featureRemark.slope_lv == '橋梁全流域') {
        org = '流';
      } else if (featureRemark.slope_lv == '淹水泥流水瀑路段') {
        org = '淹';
      } else if (featureRemark.slope_lv == '易受浪襲路段') {
        org = '浪';
      }

      style = new Style["c" /* default */]({
        image: new style_Circle["a" /* default */]({
          radius: 15,
          fill: new Fill["a" /* default */]({
            color: 'rgba(33,150,243,1)'
          })
        }),
        text: new Text["a" /* default */]({
          text: org,
          font: '20px bold',
          textAlign: 'center',
          fill: new Fill["a" /* default */]({
            color: 'rgba(255,255,255,1)'
          })
        })
      });
    } else {
      style = new Style["c" /* default */]({
        stroke: new Stroke["a" /* default */]({
          color: 'rgba(181, 27, 27)',
          width: 10
        })
      });
    }

    return style;
  },
  islandPointFunc: new Style["c" /* default */]({
    fill: new Fill["a" /* default */]({
      color: 'rgba(235, 156, 73, 0.8)'
    }),
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(235, 156, 73, 0.8)',
      width: 2
    })
  }),
  line02: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(203,67,53,1)',
      width: 5
    })
  }),
  polygon02: new Style["c" /* default */]({
    fill: new Fill["a" /* default */]({
      color: 'rgba(255,204,51,0.2)'
    }),
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(255,204,51,1)',
      width: 2
    })
  }),
  line03: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(203,67,53,1)',
      width: 5
    })
  }),
  polygon03: new Style["c" /* default */]({
    fill: new Fill["a" /* default */]({
      color: 'rgba(255,204,51,0.2)'
    }),
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(255,204,51,1)',
      width: 2
    })
  }),
  line04a: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(255,235,59,1)',
      width: 5
    })
  }),
  line04b: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(76,175,80,1)',
      width: 5
    })
  }),
  line04c: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(33,150,243,1)',
      width: 5
    })
  }),
  line04d: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(203,67,53,1)',
      width: 5
    })
  }),
  line05: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(203,67,53,1)',
      width: 5
    })
  }),
  line06: new Style["c" /* default */]({
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(242, 160, 49)',
      width: 5
    })
  }),
  point06a: new Style["c" /* default */]({
    image: new style_Circle["a" /* default */]({
      radius: 15,
      fill: new Fill["a" /* default */]({
        color: 'rgba(255,235,59,1)'
      })
    }),
    text: new Text["a" /* default */]({
      text: '處',
      font: '20px bold',
      textAlign: 'center'
    })
  }),
  point06b: new Style["c" /* default */]({
    image: new style_Circle["a" /* default */]({
      radius: 15,
      fill: new Fill["a" /* default */]({
        color: 'rgba(33,150,243,1)'
      })
    }),
    text: new Text["a" /* default */]({
      text: '處',
      font: '20px bold',
      fill: new Fill["a" /* default */]({
        color: 'rgba(255,255,255,1)'
      }),
      textAlign: 'center'
    })
  }),
  point06c: new Style["c" /* default */]({
    image: new style_Circle["a" /* default */]({
      radius: 15,
      fill: new Fill["a" /* default */]({
        color: 'rgba(255,235,59,1)'
      })
    }),
    text: new Text["a" /* default */]({
      text: '段',
      font: '20px bold',
      textAlign: 'center'
    })
  }),
  point06d: new Style["c" /* default */]({
    image: new style_Circle["a" /* default */]({
      radius: 15,
      fill: new Fill["a" /* default */]({
        color: 'rgba(33,150,243,1)'
      })
    }),
    text: new Text["a" /* default */]({
      text: '段',
      font: '20px bold',
      fill: new Fill["a" /* default */]({
        color: 'rgba(255,255,255,1)'
      }),
      textAlign: 'center'
    })
  }),
  kmlStyle: new Style["c" /* default */]({
    fill: new Fill["a" /* default */]({
      color: 'rgba(51,153,204,0.2)'
    }),
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(254,85,0,1)',
      width: 10
    }),
    image: new style_Circle["a" /* default */]({
      radius: 10,
      fill: new Fill["a" /* default */]({
        color: 'rgba(51,153,204,1)'
      })
    })
  }),
  default: new Style["c" /* default */]({
    fill: new Fill["a" /* default */]({
      color: 'rgba(51,153,204,0.2)'
    }),
    stroke: new Stroke["a" /* default */]({
      color: 'rgba(51,153,204,1)',
      width: 2
    }),
    image: new style_Circle["a" /* default */]({
      radius: 7,
      fill: new Fill["a" /* default */]({
        color: 'rgba(51,153,204,1)'
      })
    })
  })
});
// EXTERNAL MODULE: ./node_modules/ol/interaction/Draw.js
var Draw = __webpack_require__("ac29");

// EXTERNAL MODULE: ./node_modules/ol/interaction/Modify.js
var Modify = __webpack_require__("c807");

// EXTERNAL MODULE: ./node_modules/ol/control/FullScreen.js
var FullScreen = __webpack_require__("c320");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryCollection.js
var GeometryCollection = __webpack_require__("d352");

// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryLayout.js
var GeometryLayout = __webpack_require__("521b");

// EXTERNAL MODULE: ./node_modules/ol/style/IconAnchorUnits.js
var IconAnchorUnits = __webpack_require__("82b0");

// EXTERNAL MODULE: ./node_modules/ol/style/IconOrigin.js
var IconOrigin = __webpack_require__("d202");

// EXTERNAL MODULE: ./node_modules/ol/geom/MultiLineString.js
var MultiLineString = __webpack_require__("47e4");

// EXTERNAL MODULE: ./node_modules/ol/geom/MultiPoint.js
var MultiPoint = __webpack_require__("9a44");

// EXTERNAL MODULE: ./node_modules/ol/geom/MultiPolygon.js + 1 modules
var MultiPolygon = __webpack_require__("88da");

// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules
var Polygon = __webpack_require__("5bc3");

// EXTERNAL MODULE: ./node_modules/ol/format/Feature.js
var format_Feature = __webpack_require__("b7df");

// EXTERNAL MODULE: ./node_modules/ol/format/FormatType.js
var FormatType = __webpack_require__("1ecb");

// CONCATENATED MODULE: ./node_modules/ol/xml.js
/**
 * @module ol/xml
 */

/**
 * When using {@link module:ol/xml.makeChildAppender} or
 * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs
 * to have this structure.
 * @typedef {Object} NodeStackItem
 * @property {Element} node Node.
 */
/**
 * @typedef {function(Element, Array<*>): void} Parser
 */
/**
 * @typedef {function(Element, *, Array<*>): void} Serializer
 */
/**
 * @type {string}
 */
var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';
/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Element} Node.
 */
function createElementNS(namespaceURI, qualifiedName) {
    return getDocument().createElementNS(namespaceURI, qualifiedName);
}
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */
function getAllTextContent(node, normalizeWhitespace) {
    return getAllTextContent_(node, normalizeWhitespace, []).join('');
}
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array<string>} accumulator Accumulator.
 * @private
 * @return {Array<string>} Accumulator.
 */
function getAllTextContent_(node, normalizeWhitespace, accumulator) {
    if (node.nodeType == Node.CDATA_SECTION_NODE ||
        node.nodeType == Node.TEXT_NODE) {
        if (normalizeWhitespace) {
            accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
        }
        else {
            accumulator.push(node.nodeValue);
        }
    }
    else {
        var n = void 0;
        for (n = node.firstChild; n; n = n.nextSibling) {
            getAllTextContent_(n, normalizeWhitespace, accumulator);
        }
    }
    return accumulator;
}
/**
 * @param {Object} object Object.
 * @return {boolean} Is a document.
 */
function isDocument(object) {
    return 'documentElement' in object;
}
/**
 * @param {Element} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */
function getAttributeNS(node, namespaceURI, name) {
    return node.getAttributeNS(namespaceURI, name) || '';
}
/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */
function parse(xml) {
    return new DOMParser().parseFromString(xml, 'application/xml');
}
/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeArrayExtender(valueReader, opt_this) {
    return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
        if (value !== undefined) {
            var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);
            Object(ol_array["c" /* extend */])(array, value);
        }
    });
}
/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeArrayPusher(valueReader, opt_this) {
    return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
        if (value !== undefined) {
            var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);
            array.push(value);
        }
    });
}
/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeReplacer(valueReader, opt_this) {
    return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
        if (value !== undefined) {
            objectStack[objectStack.length - 1] = value;
        }
    });
}
/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [opt_property] Property.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {
    return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
        if (value !== undefined) {
            var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
            var property = opt_property !== undefined ? opt_property : node.localName;
            var array = void 0;
            if (property in object) {
                array = object[property];
            }
            else {
                array = [];
                object[property] = array;
            }
            array.push(value);
        }
    });
}
/**
 * Make an object property setter function.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [opt_property] Property.
 * @param {T} [opt_this] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeObjectPropertySetter(valueReader, opt_property, opt_this) {
    return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
        var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
        if (value !== undefined) {
            var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
            var property = opt_property !== undefined ? opt_property : node.localName;
            object[property] = value;
        }
    });
}
/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */
function makeChildAppender(nodeWriter, opt_this) {
    return function (node, value, objectStack) {
        nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);
        var parent = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);
        var parentNode = parent.node;
        parentNode.appendChild(node);
    };
}
/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the
 * `nodeWriter` called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */
function makeArraySerializer(nodeWriter, opt_this) {
    var serializersNS, nodeFactory;
    return function (node, value, objectStack) {
        if (serializersNS === undefined) {
            serializersNS = {};
            var serializers = {};
            serializers[node.localName] = nodeWriter;
            serializersNS[node.namespaceURI] = serializers;
            nodeFactory = makeSimpleNodeFactory(node.localName);
        }
        serialize(serializersNS, nodeFactory, value, objectStack);
    };
}
/**
 * Create a node factory which can use the `opt_keys` passed to
 * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string} [opt_nodeName] Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string} [opt_namespaceURI] Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.
 */
function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {
    var fixedNodeName = opt_nodeName;
    return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [opt_nodeName] Node name.
     * @return {Node} Node.
     */
    function (value, objectStack, opt_nodeName) {
        var context = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);
        var node = context.node;
        var nodeName = fixedNodeName;
        if (nodeName === undefined) {
            nodeName = opt_nodeName;
        }
        var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;
        return createElementNS(namespaceURI, /** @type {string} */ (nodeName));
    });
}
/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
/**
 * Create an array of `values` to be used with {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `opt_key` argument.
 * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array<*>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 */
function makeSequence(object, orderedKeys) {
    var length = orderedKeys.length;
    var sequence = new Array(length);
    for (var i = 0; i < length; ++i) {
        sequence[i] = object[orderedKeys[i]];
    }
    return sequence;
}
/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object<string, T>} [opt_structureNS] Namespaced structure to add to.
 * @return {Object<string, T>} Namespaced structure.
 * @template T
 */
function makeStructureNS(namespaceURIs, structure, opt_structureNS) {
    /**
     * @type {Object<string, T>}
     */
    var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
    var i, ii;
    for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
        structureNS[namespaceURIs[i]] = structure;
    }
    return structureNS;
}
/**
 * Parse a node using the parsers and object stack.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [opt_this] The object to use as `this`.
 */
function parseNode(parsersNS, node, objectStack, opt_this) {
    var n;
    for (n = node.firstElementChild; n; n = n.nextElementSibling) {
        var parsers = parsersNS[n.namespaceURI];
        if (parsers !== undefined) {
            var parser = parsers[n.localName];
            if (parser !== undefined) {
                parser.call(opt_this, n, objectStack);
            }
        }
    }
}
/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [opt_this] The object to use as `this`.
 * @return {T} Object.
 * @template T
 */
function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {
    objectStack.push(object);
    parseNode(parsersNS, node, objectStack, opt_this);
    return /** @type {T} */ (objectStack.pop());
}
/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T} [opt_this] The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */
function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
    var length = (opt_keys !== undefined ? opt_keys : values).length;
    var value, node;
    for (var i = 0; i < length; ++i) {
        value = values[i];
        if (value !== undefined) {
            node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);
            if (node !== undefined) {
                serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
            }
        }
    }
}
/**
 * @param {O} object Object.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T} [opt_this] The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */
function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
    objectStack.push(object);
    serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
    return /** @type {O|undefined} */ (objectStack.pop());
}
var xmlSerializer_ = undefined;
/**
 * Register a XMLSerializer. Can be used  to inject a XMLSerializer
 * where there is no globally available implementation.
 *
 * @param {XMLSerializer} xmlSerializer A XMLSerializer.
 * @api
 */
function registerXMLSerializer(xmlSerializer) {
    xmlSerializer_ = xmlSerializer;
}
/**
 * @return {XMLSerializer} The XMLSerializer.
 */
function getXMLSerializer() {
    if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {
        xmlSerializer_ = new XMLSerializer();
    }
    return xmlSerializer_;
}
var document_ = undefined;
/**
 * Register a Document to use when creating nodes for XML serializations. Can be used
 * to inject a Document where there is no globally available implementation.
 *
 * @param {Document} document A Document.
 * @api
 */
function registerDocument(document) {
    document_ = document;
}
/**
 * Get a document that should be used when creating nodes for XML serializations.
 * @return {Document} The document.
 */
function getDocument() {
    if (document_ === undefined && typeof document !== 'undefined') {
        document_ = document.implementation.createDocument('', '', null);
    }
    return document_;
}
//# sourceMappingURL=xml.js.map
// CONCATENATED MODULE: ./node_modules/ol/format/XMLFeature.js
var XMLFeature_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/format/XMLFeature
 */





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 *
 * @abstract
 */
var XMLFeature_XMLFeature = /** @class */ (function (_super) {
    XMLFeature_extends(XMLFeature, _super);
    function XMLFeature() {
        var _this = _super.call(this) || this;
        /**
         * @type {XMLSerializer}
         * @private
         */
        _this.xmlSerializer_ = getXMLSerializer();
        return _this;
    }
    /**
     * @return {import("./FormatType.js").default} Format.
     */
    XMLFeature.prototype.getType = function () {
        return FormatType["a" /* default */].XML;
    };
    /**
     * Read a single feature.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     */
    XMLFeature.prototype.readFeature = function (source, opt_options) {
        if (!source) {
            return null;
        }
        else if (typeof source === 'string') {
            var doc = parse(source);
            return this.readFeatureFromDocument(doc, opt_options);
        }
        else if (isDocument(source)) {
            return this.readFeatureFromDocument(
            /** @type {Document} */ (source), opt_options);
        }
        else {
            return this.readFeatureFromNode(
            /** @type {Element} */ (source), opt_options);
        }
    };
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    XMLFeature.prototype.readFeatureFromDocument = function (doc, opt_options) {
        var features = this.readFeaturesFromDocument(doc, opt_options);
        if (features.length > 0) {
            return features[0];
        }
        else {
            return null;
        }
    };
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    XMLFeature.prototype.readFeatureFromNode = function (node, opt_options) {
        return null; // not implemented
    };
    /**
     * Read all features from a feature collection.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     */
    XMLFeature.prototype.readFeatures = function (source, opt_options) {
        if (!source) {
            return [];
        }
        else if (typeof source === 'string') {
            var doc = parse(source);
            return this.readFeaturesFromDocument(doc, opt_options);
        }
        else if (isDocument(source)) {
            return this.readFeaturesFromDocument(
            /** @type {Document} */ (source), opt_options);
        }
        else {
            return this.readFeaturesFromNode(
            /** @type {Element} */ (source), opt_options);
        }
    };
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    XMLFeature.prototype.readFeaturesFromDocument = function (doc, opt_options) {
        /** @type {Array<import("../Feature.js").default>} */
        var features = [];
        for (var n = doc.firstChild; n; n = n.nextSibling) {
            if (n.nodeType == Node.ELEMENT_NODE) {
                Object(ol_array["c" /* extend */])(features, this.readFeaturesFromNode(/** @type {Element} */ (n), opt_options));
            }
        }
        return features;
    };
    /**
     * @abstract
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    XMLFeature.prototype.readFeaturesFromNode = function (node, opt_options) {
        return Object(util["b" /* abstract */])();
    };
    /**
     * Read a single geometry from a source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    XMLFeature.prototype.readGeometry = function (source, opt_options) {
        if (!source) {
            return null;
        }
        else if (typeof source === 'string') {
            var doc = parse(source);
            return this.readGeometryFromDocument(doc, opt_options);
        }
        else if (isDocument(source)) {
            return this.readGeometryFromDocument(
            /** @type {Document} */ (source), opt_options);
        }
        else {
            return this.readGeometryFromNode(
            /** @type {Element} */ (source), opt_options);
        }
    };
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    XMLFeature.prototype.readGeometryFromDocument = function (doc, opt_options) {
        return null; // not implemented
    };
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    XMLFeature.prototype.readGeometryFromNode = function (node, opt_options) {
        return null; // not implemented
    };
    /**
     * Read the projection from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     */
    XMLFeature.prototype.readProjection = function (source) {
        if (!source) {
            return null;
        }
        else if (typeof source === 'string') {
            var doc = parse(source);
            return this.readProjectionFromDocument(doc);
        }
        else if (isDocument(source)) {
            return this.readProjectionFromDocument(/** @type {Document} */ (source));
        }
        else {
            return this.readProjectionFromNode(/** @type {Element} */ (source));
        }
    };
    /**
     * @param {Document} doc Document.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    XMLFeature.prototype.readProjectionFromDocument = function (doc) {
        return this.dataProjection;
    };
    /**
     * @param {Element} node Node.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    XMLFeature.prototype.readProjectionFromNode = function (node) {
        return this.dataProjection;
    };
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {string} Encoded feature.
     */
    XMLFeature.prototype.writeFeature = function (feature, opt_options) {
        var node = this.writeFeatureNode(feature, opt_options);
        return this.xmlSerializer_.serializeToString(node);
    };
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
     * @protected
     * @return {Node} Node.
     */
    XMLFeature.prototype.writeFeatureNode = function (feature, opt_options) {
        return null; // not implemented
    };
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {string} Result.
     * @api
     */
    XMLFeature.prototype.writeFeatures = function (features, opt_options) {
        var node = this.writeFeaturesNode(features, opt_options);
        return this.xmlSerializer_.serializeToString(node);
    };
    /**
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
     * @return {Node} Node.
     */
    XMLFeature.prototype.writeFeaturesNode = function (features, opt_options) {
        return null; // not implemented
    };
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Write options.
     * @return {string} Encoded geometry.
     */
    XMLFeature.prototype.writeGeometry = function (geometry, opt_options) {
        var node = this.writeGeometryNode(geometry, opt_options);
        return this.xmlSerializer_.serializeToString(node);
    };
    /**
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
     * @return {Node} Node.
     */
    XMLFeature.prototype.writeGeometryNode = function (geometry, opt_options) {
        return null; // not implemented
    };
    return XMLFeature;
}(format_Feature["a" /* default */]));
/* harmony default export */ var format_XMLFeature = (XMLFeature_XMLFeature);
//# sourceMappingURL=XMLFeature.js.map
// EXTERNAL MODULE: ./node_modules/ol/color.js
var ol_color = __webpack_require__("5c38");

// EXTERNAL MODULE: ./node_modules/ol/string.js
var ol_string = __webpack_require__("b0c1");

// CONCATENATED MODULE: ./node_modules/ol/format/xsd.js
/**
 * @module ol/format/xsd
 */


/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */
function readBoolean(node) {
    var s = getAllTextContent(node, false);
    return readBooleanString(s);
}
/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */
function readBooleanString(string) {
    var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
    if (m) {
        return m[1] !== undefined || false;
    }
    else {
        return undefined;
    }
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */
function readDateTime(node) {
    var s = getAllTextContent(node, false);
    var dateTime = Date.parse(s);
    return isNaN(dateTime) ? undefined : dateTime / 1000;
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */
function readDecimal(node) {
    var s = getAllTextContent(node, false);
    return readDecimalString(s);
}
/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */
function readDecimalString(string) {
    // FIXME check spec
    var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
    if (m) {
        return parseFloat(m[1]);
    }
    else {
        return undefined;
    }
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */
function readPositiveInteger(node) {
    var s = getAllTextContent(node, false);
    return readNonNegativeIntegerString(s);
}
/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */
function readNonNegativeIntegerString(string) {
    var m = /^\s*(\d+)\s*$/.exec(string);
    if (m) {
        return parseInt(m[1], 10);
    }
    else {
        return undefined;
    }
}
/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */
function readString(node) {
    return getAllTextContent(node, false).trim();
}
/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */
function writeBooleanTextNode(node, bool) {
    writeStringTextNode(node, bool ? '1' : '0');
}
/**
 * @param {Node} node Node to append a CDATA Section with the string to.
 * @param {string} string String.
 */
function writeCDATASection(node, string) {
    node.appendChild(getDocument().createCDATASection(string));
}
/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */
function writeDateTimeTextNode(node, dateTime) {
    var date = new Date(dateTime * 1000);
    var string = date.getUTCFullYear() +
        '-' +
        Object(ol_string["a" /* padNumber */])(date.getUTCMonth() + 1, 2) +
        '-' +
        Object(ol_string["a" /* padNumber */])(date.getUTCDate(), 2) +
        'T' +
        Object(ol_string["a" /* padNumber */])(date.getUTCHours(), 2) +
        ':' +
        Object(ol_string["a" /* padNumber */])(date.getUTCMinutes(), 2) +
        ':' +
        Object(ol_string["a" /* padNumber */])(date.getUTCSeconds(), 2) +
        'Z';
    node.appendChild(getDocument().createTextNode(string));
}
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */
function writeDecimalTextNode(node, decimal) {
    var string = decimal.toPrecision();
    node.appendChild(getDocument().createTextNode(string));
}
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */
function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
    var string = nonNegativeInteger.toString();
    node.appendChild(getDocument().createTextNode(string));
}
/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */
function writeStringTextNode(node, string) {
    node.appendChild(getDocument().createTextNode(string));
}
//# sourceMappingURL=xsd.js.map
// CONCATENATED MODULE: ./node_modules/ol/format/KML.js
var KML_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/format/KML
 */



























/**
 * @typedef {Object} Vec2
 * @property {number} x X coordinate.
 * @property {import("../style/IconAnchorUnits").default} xunits Units of x.
 * @property {number} y Y coordinate.
 * @property {import("../style/IconAnchorUnits").default} yunits Units of Y.
 * @property {import("../style/IconOrigin.js").default} [origin] Origin.
 */
/**
 * @typedef {Object} GxTrackObject
 * @property {Array<Array<number>>} coordinates Coordinates.
 * @property {Array<number>} whens Whens.
 */
/**
 * @const
 * @type {Array<string>}
 */
var GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];
/**
 * @const
 * @type {Array<null|string>}
 */
var NAMESPACE_URIS = [
    null,
    'http://earth.google.com/kml/2.0',
    'http://earth.google.com/kml/2.1',
    'http://earth.google.com/kml/2.2',
    'http://www.opengis.net/kml/2.2',
];
/**
 * @const
 * @type {string}
 */
var SCHEMA_LOCATION = 'http://www.opengis.net/kml/2.2 ' +
    'https://developers.google.com/kml/schema/kml22gx.xsd';
/**
 * @type {Object<string, import("../style/IconAnchorUnits").default>}
 */
var ICON_ANCHOR_UNITS_MAP = {
    'fraction': IconAnchorUnits["a" /* default */].FRACTION,
    'pixels': IconAnchorUnits["a" /* default */].PIXELS,
    'insetPixels': IconAnchorUnits["a" /* default */].PIXELS,
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var PLACEMARK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'ExtendedData': extendedDataParser,
    'Region': regionParser,
    'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),
    'LineString': makeObjectPropertySetter(readLineString, 'geometry'),
    'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),
    'Point': makeObjectPropertySetter(readPoint, 'geometry'),
    'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),
    'Style': makeObjectPropertySetter(readStyle),
    'StyleMap': placemarkStyleMapParser,
    'address': makeObjectPropertySetter(readString),
    'description': makeObjectPropertySetter(readString),
    'name': makeObjectPropertySetter(readString),
    'open': makeObjectPropertySetter(readBoolean),
    'phoneNumber': makeObjectPropertySetter(readString),
    'styleUrl': makeObjectPropertySetter(readStyleURL),
    'visibility': makeObjectPropertySetter(readBoolean),
}, makeStructureNS(GX_NAMESPACE_URIS, {
    'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),
    'Track': makeObjectPropertySetter(readGxTrack, 'geometry'),
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'ExtendedData': extendedDataParser,
    'Region': regionParser,
    'Link': linkParser,
    'address': makeObjectPropertySetter(readString),
    'description': makeObjectPropertySetter(readString),
    'name': makeObjectPropertySetter(readString),
    'open': makeObjectPropertySetter(readBoolean),
    'phoneNumber': makeObjectPropertySetter(readString),
    'visibility': makeObjectPropertySetter(readBoolean),
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'href': makeObjectPropertySetter(readURI),
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'LatLonAltBox': latLonAltBoxParser,
    'Lod': lodParser,
});
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'Document': makeChildAppender(writeDocument),
    'Placemark': makeChildAppender(writePlacemark),
});
/**
 * @type {import("../color.js").Color}
 */
var DEFAULT_COLOR;
/**
 * @type {Fill|null}
 */
var DEFAULT_FILL_STYLE = null;
/**
 * Get the default fill style (or null if not yet set).
 * @return {Fill|null} The default fill style.
 */
function getDefaultFillStyle() {
    return DEFAULT_FILL_STYLE;
}
/**
 * @type {import("../size.js").Size}
 */
var DEFAULT_IMAGE_STYLE_ANCHOR;
/**
 * @type {import("../style/IconAnchorUnits").default}
 */
var DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
/**
 * @type {import("../style/IconAnchorUnits").default}
 */
var DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
/**
 * @type {import("../size.js").Size}
 */
var DEFAULT_IMAGE_STYLE_SIZE;
/**
 * @type {string}
 */
var DEFAULT_IMAGE_STYLE_SRC;
/**
 * @type {import("../style/Image.js").default|null}
 */
var DEFAULT_IMAGE_STYLE = null;
/**
 * Get the default image style (or null if not yet set).
 * @return {import("../style/Image.js").default|null} The default image style.
 */
function getDefaultImageStyle() {
    return DEFAULT_IMAGE_STYLE;
}
/**
 * @type {string}
 */
var DEFAULT_NO_IMAGE_STYLE;
/**
 * @type {Stroke|null}
 */
var DEFAULT_STROKE_STYLE = null;
/**
 * Get the default stroke style (or null if not yet set).
 * @return {Stroke|null} The default stroke style.
 */
function getDefaultStrokeStyle() {
    return DEFAULT_STROKE_STYLE;
}
/**
 * @type {Stroke}
 */
var DEFAULT_TEXT_STROKE_STYLE;
/**
 * @type {Text|null}
 */
var DEFAULT_TEXT_STYLE = null;
/**
 * Get the default text style (or null if not yet set).
 * @return {Text|null} The default text style.
 */
function getDefaultTextStyle() {
    return DEFAULT_TEXT_STYLE;
}
/**
 * @type {Style|null}
 */
var DEFAULT_STYLE = null;
/**
 * Get the default style (or null if not yet set).
 * @return {Style|null} The default style.
 */
function getDefaultStyle() {
    return DEFAULT_STYLE;
}
/**
 * @type {Array<Style>|null}
 */
var DEFAULT_STYLE_ARRAY = null;
/**
 * Get the default style array (or null if not yet set).
 * @return {Array<Style>|null} The default style.
 */
function getDefaultStyleArray() {
    return DEFAULT_STYLE_ARRAY;
}
/**
 * Function that returns the scale needed to normalize an icon image to 32 pixels.
 * @param {import("../size.js").Size} size Image size.
 * @return {number} Scale.
 */
function scaleForSize(size) {
    return 32 / Math.min(size[0], size[1]);
}
function createStyleDefaults() {
    DEFAULT_COLOR = [255, 255, 255, 1];
    DEFAULT_FILL_STYLE = new Fill["a" /* default */]({
        color: DEFAULT_COLOR,
    });
    DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
    DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = IconAnchorUnits["a" /* default */].PIXELS;
    DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = IconAnchorUnits["a" /* default */].PIXELS;
    DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
    DEFAULT_IMAGE_STYLE_SRC =
        'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';
    DEFAULT_IMAGE_STYLE = new Icon["a" /* default */]({
        anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
        anchorOrigin: IconOrigin["a" /* default */].BOTTOM_LEFT,
        anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
        anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
        crossOrigin: 'anonymous',
        rotation: 0,
        scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
        size: DEFAULT_IMAGE_STYLE_SIZE,
        src: DEFAULT_IMAGE_STYLE_SRC,
    });
    DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';
    DEFAULT_STROKE_STYLE = new Stroke["a" /* default */]({
        color: DEFAULT_COLOR,
        width: 1,
    });
    DEFAULT_TEXT_STROKE_STYLE = new Stroke["a" /* default */]({
        color: [51, 51, 51, 1],
        width: 2,
    });
    DEFAULT_TEXT_STYLE = new Text["a" /* default */]({
        font: 'bold 16px Helvetica',
        fill: DEFAULT_FILL_STYLE,
        stroke: DEFAULT_TEXT_STROKE_STYLE,
        scale: 0.8,
    });
    DEFAULT_STYLE = new Style["c" /* default */]({
        fill: DEFAULT_FILL_STYLE,
        image: DEFAULT_IMAGE_STYLE,
        text: DEFAULT_TEXT_STYLE,
        stroke: DEFAULT_STROKE_STYLE,
        zIndex: 0,
    });
    DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
}
/**
 * @type {HTMLTextAreaElement}
 */
var TEXTAREA;
/**
 * A function that takes a url `{string}` and returns a url `{string}`.
 * Might be used to change an icon path or to substitute a
 * data url obtained from a KMZ array buffer.
 *
 * @typedef {function(string):string} IconUrlFunction
 * @api
 */
/**
 * Function that returns a url unchanged.
 * @param {string} href Input url.
 * @return {string} Output url.
 */
function defaultIconUrlFunction(href) {
    return href;
}
/**
 * @typedef {Object} Options
 * @property {boolean} [extractStyles=true] Extract styles from the KML.
 * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.
 * @property {Array<Style>} [defaultStyle] Default style. The
 * default default style is the same as Google Earth.
 * @property {boolean} [writeStyles=true] Write styles into KML.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.
 * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.
 */
/**
 * @classdesc
 * Feature format for reading and writing data in the KML format.
 *
 * {@link module:ol/format/KML~KML#readFeature} will read the first feature from
 * a KML source.
 *
 * MultiGeometries are converted into GeometryCollections if they are a mix of
 * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are
 * all of the same type.
 *
 * Note that the KML format uses the URL() constructor. Older browsers such as IE
 * which do not support this will need a URL polyfill to be loaded before use.
 *
 * @api
 */
var KML_KML = /** @class */ (function (_super) {
    KML_extends(KML, _super);
    /**
     * @param {Options} [opt_options] Options.
     */
    function KML(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options ? opt_options : {};
        if (!DEFAULT_STYLE_ARRAY) {
            createStyleDefaults();
        }
        /**
         * @type {import("../proj/Projection.js").default}
         */
        _this.dataProjection = Object(ol_proj["m" /* get */])('EPSG:4326');
        /**
         * @private
         * @type {Array<Style>}
         */
        _this.defaultStyle_ = options.defaultStyle
            ? options.defaultStyle
            : DEFAULT_STYLE_ARRAY;
        /**
         * @private
         * @type {boolean}
         */
        _this.extractStyles_ =
            options.extractStyles !== undefined ? options.extractStyles : true;
        /**
         * @type {boolean}
         */
        _this.writeStyles_ =
            options.writeStyles !== undefined ? options.writeStyles : true;
        /**
         * @private
         * @type {!Object<string, (Array<Style>|string)>}
         */
        _this.sharedStyles_ = {};
        /**
         * @private
         * @type {boolean}
         */
        _this.showPointNames_ =
            options.showPointNames !== undefined ? options.showPointNames : true;
        /**
         * @type {null|string}
         */
        _this.crossOrigin_ =
            options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
        /**
         * @type {IconUrlFunction}
         */
        _this.iconUrlFunction_ = options.iconUrlFunction
            ? options.iconUrlFunction
            : defaultIconUrlFunction;
        _this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];
        return _this;
    }
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     * @return {Array<Feature>|undefined} Features.
     */
    KML.prototype.readDocumentOrFolder_ = function (node, objectStack) {
        // FIXME use scope somehow
        var parsersNS = makeStructureNS(NAMESPACE_URIS, {
            'Document': makeArrayExtender(this.readDocumentOrFolder_, this),
            'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),
            'Placemark': makeArrayPusher(this.readPlacemark_, this),
            'Style': this.readSharedStyle_.bind(this),
            'StyleMap': this.readSharedStyleMap_.bind(this),
        });
        /** @type {Array<Feature>} */
        // @ts-ignore
        var features = pushParseAndPop([], parsersNS, node, objectStack, this);
        if (features) {
            return features;
        }
        else {
            return undefined;
        }
    };
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     * @return {Feature|undefined} Feature.
     */
    KML.prototype.readPlacemark_ = function (node, objectStack) {
        var object = pushParseAndPop({ 'geometry': null }, PLACEMARK_PARSERS, node, objectStack, this);
        if (!object) {
            return undefined;
        }
        var feature = new Feature["a" /* default */]();
        var id = node.getAttribute('id');
        if (id !== null) {
            feature.setId(id);
        }
        var options = /** @type {import("./Feature.js").ReadOptions} */ (objectStack[0]);
        var geometry = object['geometry'];
        if (geometry) {
            Object(format_Feature["b" /* transformGeometryWithOptions */])(geometry, false, options);
        }
        feature.setGeometry(geometry);
        delete object['geometry'];
        if (this.extractStyles_) {
            var style = object['Style'];
            var styleUrl = object['styleUrl'];
            var styleFunction = createFeatureStyleFunction(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
            feature.setStyle(styleFunction);
        }
        delete object['Style'];
        // we do not remove the styleUrl property from the object, so it
        // gets stored on feature when setProperties is called
        feature.setProperties(object, true);
        return feature;
    };
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     */
    KML.prototype.readSharedStyle_ = function (node, objectStack) {
        var id = node.getAttribute('id');
        if (id !== null) {
            var style = readStyle.call(this, node, objectStack);
            if (style) {
                var styleUri = void 0;
                var baseURI = node.baseURI;
                if (!baseURI || baseURI == 'about:blank') {
                    baseURI = window.location.href;
                }
                if (baseURI) {
                    var url = new URL('#' + id, baseURI);
                    styleUri = url.href;
                }
                else {
                    styleUri = '#' + id;
                }
                this.sharedStyles_[styleUri] = style;
            }
        }
    };
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @private
     */
    KML.prototype.readSharedStyleMap_ = function (node, objectStack) {
        var id = node.getAttribute('id');
        if (id === null) {
            return;
        }
        var styleMapValue = readStyleMapValue.call(this, node, objectStack);
        if (!styleMapValue) {
            return;
        }
        var styleUri;
        var baseURI = node.baseURI;
        if (!baseURI || baseURI == 'about:blank') {
            baseURI = window.location.href;
        }
        if (baseURI) {
            var url = new URL('#' + id, baseURI);
            styleUri = url.href;
        }
        else {
            styleUri = '#' + id;
        }
        this.sharedStyles_[styleUri] = styleMapValue;
    };
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    KML.prototype.readFeatureFromNode = function (node, opt_options) {
        if (!Object(ol_array["d" /* includes */])(NAMESPACE_URIS, node.namespaceURI)) {
            return null;
        }
        var feature = this.readPlacemark_(node, [
            this.getReadOptions(node, opt_options),
        ]);
        if (feature) {
            return feature;
        }
        else {
            return null;
        }
    };
    /**
     * @protected
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [opt_options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     */
    KML.prototype.readFeaturesFromNode = function (node, opt_options) {
        if (!Object(ol_array["d" /* includes */])(NAMESPACE_URIS, node.namespaceURI)) {
            return [];
        }
        var features;
        var localName = node.localName;
        if (localName == 'Document' || localName == 'Folder') {
            features = this.readDocumentOrFolder_(node, [
                this.getReadOptions(node, opt_options),
            ]);
            if (features) {
                return features;
            }
            else {
                return [];
            }
        }
        else if (localName == 'Placemark') {
            var feature = this.readPlacemark_(node, [
                this.getReadOptions(node, opt_options),
            ]);
            if (feature) {
                return [feature];
            }
            else {
                return [];
            }
        }
        else if (localName == 'kml') {
            features = [];
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                var fs = this.readFeaturesFromNode(n, opt_options);
                if (fs) {
                    Object(ol_array["c" /* extend */])(features, fs);
                }
            }
            return features;
        }
        else {
            return [];
        }
    };
    /**
     * Read the name of the KML.
     *
     * @param {Document|Element|string} source Source.
     * @return {string|undefined} Name.
     * @api
     */
    KML.prototype.readName = function (source) {
        if (!source) {
            return undefined;
        }
        else if (typeof source === 'string') {
            var doc = parse(source);
            return this.readNameFromDocument(doc);
        }
        else if (isDocument(source)) {
            return this.readNameFromDocument(/** @type {Document} */ (source));
        }
        else {
            return this.readNameFromNode(/** @type {Element} */ (source));
        }
    };
    /**
     * @param {Document} doc Document.
     * @return {string|undefined} Name.
     */
    KML.prototype.readNameFromDocument = function (doc) {
        for (var n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
            if (n.nodeType == Node.ELEMENT_NODE) {
                var name_1 = this.readNameFromNode(/** @type {Element} */ (n));
                if (name_1) {
                    return name_1;
                }
            }
        }
        return undefined;
    };
    /**
     * @param {Element} node Node.
     * @return {string|undefined} Name.
     */
    KML.prototype.readNameFromNode = function (node) {
        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
            if (Object(ol_array["d" /* includes */])(NAMESPACE_URIS, n.namespaceURI) && n.localName == 'name') {
                return readString(n);
            }
        }
        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
            var localName = n.localName;
            if (Object(ol_array["d" /* includes */])(NAMESPACE_URIS, n.namespaceURI) &&
                (localName == 'Document' ||
                    localName == 'Folder' ||
                    localName == 'Placemark' ||
                    localName == 'kml')) {
                var name_2 = this.readNameFromNode(n);
                if (name_2) {
                    return name_2;
                }
            }
        }
        return undefined;
    };
    /**
     * Read the network links of the KML.
     *
     * @param {Document|Element|string} source Source.
     * @return {Array<Object>} Network links.
     * @api
     */
    KML.prototype.readNetworkLinks = function (source) {
        var networkLinks = [];
        if (typeof source === 'string') {
            var doc = parse(source);
            Object(ol_array["c" /* extend */])(networkLinks, this.readNetworkLinksFromDocument(doc));
        }
        else if (isDocument(source)) {
            Object(ol_array["c" /* extend */])(networkLinks, this.readNetworkLinksFromDocument(/** @type {Document} */ (source)));
        }
        else {
            Object(ol_array["c" /* extend */])(networkLinks, this.readNetworkLinksFromNode(/** @type {Element} */ (source)));
        }
        return networkLinks;
    };
    /**
     * @param {Document} doc Document.
     * @return {Array<Object>} Network links.
     */
    KML.prototype.readNetworkLinksFromDocument = function (doc) {
        var networkLinks = [];
        for (var n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
            if (n.nodeType == Node.ELEMENT_NODE) {
                Object(ol_array["c" /* extend */])(networkLinks, this.readNetworkLinksFromNode(/** @type {Element} */ (n)));
            }
        }
        return networkLinks;
    };
    /**
     * @param {Element} node Node.
     * @return {Array<Object>} Network links.
     */
    KML.prototype.readNetworkLinksFromNode = function (node) {
        var networkLinks = [];
        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
            if (Object(ol_array["d" /* includes */])(NAMESPACE_URIS, n.namespaceURI) &&
                n.localName == 'NetworkLink') {
                var obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);
                networkLinks.push(obj);
            }
        }
        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
            var localName = n.localName;
            if (Object(ol_array["d" /* includes */])(NAMESPACE_URIS, n.namespaceURI) &&
                (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {
                Object(ol_array["c" /* extend */])(networkLinks, this.readNetworkLinksFromNode(n));
            }
        }
        return networkLinks;
    };
    /**
     * Read the regions of the KML.
     *
     * @param {Document|Element|string} source Source.
     * @return {Array<Object>} Regions.
     * @api
     */
    KML.prototype.readRegion = function (source) {
        var regions = [];
        if (typeof source === 'string') {
            var doc = parse(source);
            Object(ol_array["c" /* extend */])(regions, this.readRegionFromDocument(doc));
        }
        else if (isDocument(source)) {
            Object(ol_array["c" /* extend */])(regions, this.readRegionFromDocument(/** @type {Document} */ (source)));
        }
        else {
            Object(ol_array["c" /* extend */])(regions, this.readRegionFromNode(/** @type {Element} */ (source)));
        }
        return regions;
    };
    /**
     * @param {Document} doc Document.
     * @return {Array<Object>} Region.
     */
    KML.prototype.readRegionFromDocument = function (doc) {
        var regions = [];
        for (var n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
            if (n.nodeType == Node.ELEMENT_NODE) {
                Object(ol_array["c" /* extend */])(regions, this.readRegionFromNode(/** @type {Element} */ (n)));
            }
        }
        return regions;
    };
    /**
     * @param {Element} node Node.
     * @return {Array<Object>} Region.
     * @api
     */
    KML.prototype.readRegionFromNode = function (node) {
        var regions = [];
        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
            if (Object(ol_array["d" /* includes */])(NAMESPACE_URIS, n.namespaceURI) && n.localName == 'Region') {
                var obj = pushParseAndPop({}, REGION_PARSERS, n, []);
                regions.push(obj);
            }
        }
        for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
            var localName = n.localName;
            if (Object(ol_array["d" /* includes */])(NAMESPACE_URIS, n.namespaceURI) &&
                (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {
                Object(ol_array["c" /* extend */])(regions, this.readRegionFromNode(n));
            }
        }
        return regions;
    };
    /**
     * Encode an array of features in the KML format as an XML node. GeometryCollections,
     * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
     *
     * @param {Array<Feature>} features Features.
     * @param {import("./Feature.js").WriteOptions} [opt_options] Options.
     * @return {Node} Node.
     * @api
     */
    KML.prototype.writeFeaturesNode = function (features, opt_options) {
        opt_options = this.adaptOptions(opt_options);
        var kml = createElementNS(NAMESPACE_URIS[4], 'kml');
        var xmlnsUri = 'http://www.w3.org/2000/xmlns/';
        kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);
        kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);
        kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);
        var /** @type {import("../xml.js").NodeStackItem} */ context = {
            node: kml,
        };
        /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */
        var properties = {};
        if (features.length > 1) {
            properties['Document'] = features;
        }
        else if (features.length == 1) {
            properties['Placemark'] = features[0];
        }
        var orderedKeys = KML_SEQUENCE[kml.namespaceURI];
        var values = makeSequence(properties, orderedKeys);
        pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys, this);
        return kml;
    };
    return KML;
}(format_XMLFeature));
/**
 * @param {Style|undefined} foundStyle Style.
 * @param {string} name Name.
 * @return {Style} style Style.
 */
function createNameStyleFunction(foundStyle, name) {
    var textOffset = [0, 0];
    var textAlign = 'start';
    var imageStyle = foundStyle.getImage();
    if (imageStyle) {
        var imageSize = imageStyle.getSize();
        if (imageSize && imageSize.length == 2) {
            var imageScale = imageStyle.getScaleArray();
            var anchor = imageStyle.getAnchor();
            // Offset the label to be centered to the right of the icon,
            // if there is one.
            textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
            textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
            textAlign = 'left';
        }
    }
    var textStyle = foundStyle.getText();
    if (textStyle) {
        // clone the text style, customizing it with name, alignments and offset.
        // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).
        textStyle = textStyle.clone();
        textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
        textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
        textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
        textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
    }
    else {
        textStyle = DEFAULT_TEXT_STYLE.clone();
    }
    textStyle.setText(name);
    textStyle.setOffsetX(textOffset[0]);
    textStyle.setOffsetY(textOffset[1]);
    textStyle.setTextAlign(textAlign);
    var nameStyle = new Style["c" /* default */]({
        image: imageStyle,
        text: textStyle,
    });
    return nameStyle;
}
/**
 * @param {Array<Style>|undefined} style Style.
 * @param {string} styleUrl Style URL.
 * @param {Array<Style>} defaultStyle Default style.
 * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.
 * @param {boolean|undefined} showPointNames true to show names for point placemarks.
 * @return {import("../style/Style.js").StyleFunction} Feature style function.
 */
function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
    return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    function (feature, resolution) {
        var drawName = showPointNames;
        var name = '';
        var multiGeometryPoints = [];
        if (drawName) {
            var geometry = feature.getGeometry();
            if (geometry) {
                if (geometry instanceof GeometryCollection["a" /* default */]) {
                    multiGeometryPoints = geometry
                        .getGeometriesArrayRecursive()
                        .filter(function (geometry) {
                        var type = geometry.getType();
                        return (type === GeometryType["a" /* default */].POINT ||
                            type === GeometryType["a" /* default */].MULTI_POINT);
                    });
                    drawName = multiGeometryPoints.length > 0;
                }
                else {
                    var type = geometry.getType();
                    drawName =
                        type === GeometryType["a" /* default */].POINT || type === GeometryType["a" /* default */].MULTI_POINT;
                }
            }
        }
        if (drawName) {
            name = /** @type {string} */ (feature.get('name'));
            drawName = drawName && !!name;
            // convert any html character codes
            if (drawName && name.search(/&[^&]+;/) > -1) {
                if (!TEXTAREA) {
                    TEXTAREA = document.createElement('textarea');
                }
                TEXTAREA.innerHTML = name;
                name = TEXTAREA.value;
            }
        }
        var featureStyle = defaultStyle;
        if (style) {
            featureStyle = style;
        }
        else if (styleUrl) {
            featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
        }
        if (drawName) {
            var nameStyle = createNameStyleFunction(featureStyle[0], name);
            if (multiGeometryPoints.length > 0) {
                // in multigeometries restrict the name style to points and create a
                // style without image or text for geometries requiring fill or stroke
                // including any polygon specific style if there is one
                nameStyle.setGeometry(new GeometryCollection["a" /* default */](multiGeometryPoints));
                var baseStyle = new Style["c" /* default */]({
                    geometry: featureStyle[0].getGeometry(),
                    image: null,
                    fill: featureStyle[0].getFill(),
                    stroke: featureStyle[0].getStroke(),
                    text: null,
                });
                return [nameStyle, baseStyle].concat(featureStyle.slice(1));
            }
            return nameStyle;
        }
        return featureStyle;
    });
}
/**
 * @param {Array<Style>|string|undefined} styleValue Style value.
 * @param {Array<Style>} defaultStyle Default style.
 * @param {!Object<string, (Array<Style>|string)>} sharedStyles
 * Shared styles.
 * @return {Array<Style>} Style.
 */
function findStyle(styleValue, defaultStyle, sharedStyles) {
    if (Array.isArray(styleValue)) {
        return styleValue;
    }
    else if (typeof styleValue === 'string') {
        return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
    }
    else {
        return defaultStyle;
    }
}
/**
 * @param {Node} node Node.
 * @return {import("../color.js").Color|undefined} Color.
 */
function readColor(node) {
    var s = getAllTextContent(node, false);
    // The KML specification states that colors should not include a leading `#`
    // but we tolerate them.
    var m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
    if (m) {
        var hexColor = m[1];
        return [
            parseInt(hexColor.substr(6, 2), 16),
            parseInt(hexColor.substr(4, 2), 16),
            parseInt(hexColor.substr(2, 2), 16),
            parseInt(hexColor.substr(0, 2), 16) / 255,
        ];
    }
    else {
        return undefined;
    }
}
/**
 * @param {Node} node Node.
 * @return {Array<number>|undefined} Flat coordinates.
 */
function readFlatCoordinates(node) {
    var s = getAllTextContent(node, false);
    var flatCoordinates = [];
    // The KML specification states that coordinate tuples should not include
    // spaces, but we tolerate them.
    s = s.replace(/\s*,\s*/g, ',');
    var re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
    var m;
    while ((m = re.exec(s))) {
        var x = parseFloat(m[1]);
        var y = parseFloat(m[2]);
        var z = m[3] ? parseFloat(m[3]) : 0;
        flatCoordinates.push(x, y, z);
        s = s.substr(m[0].length);
    }
    if (s !== '') {
        return undefined;
    }
    return flatCoordinates;
}
/**
 * @param {Node} node Node.
 * @return {string} URI.
 */
function readURI(node) {
    var s = getAllTextContent(node, false).trim();
    var baseURI = node.baseURI;
    if (!baseURI || baseURI == 'about:blank') {
        baseURI = window.location.href;
    }
    if (baseURI) {
        var url = new URL(s, baseURI);
        return url.href;
    }
    else {
        return s;
    }
}
/**
 * @param {Node} node Node.
 * @return {string} URI.
 */
function readStyleURL(node) {
    // KML files in the wild occasionally forget the leading
    // `#` on styleUrlsdefined in the same document.
    var s = getAllTextContent(node, false)
        .trim()
        .replace(/^(?!.*#)/, '#');
    var baseURI = node.baseURI;
    if (!baseURI || baseURI == 'about:blank') {
        baseURI = window.location.href;
    }
    if (baseURI) {
        var url = new URL(s, baseURI);
        return url.href;
    }
    else {
        return s;
    }
}
/**
 * @param {Element} node Node.
 * @return {Vec2} Vec2.
 */
function readVec2(node) {
    var xunits = node.getAttribute('xunits');
    var yunits = node.getAttribute('yunits');
    var origin;
    if (xunits !== 'insetPixels') {
        if (yunits !== 'insetPixels') {
            origin = IconOrigin["a" /* default */].BOTTOM_LEFT;
        }
        else {
            origin = IconOrigin["a" /* default */].TOP_LEFT;
        }
    }
    else {
        if (yunits !== 'insetPixels') {
            origin = IconOrigin["a" /* default */].BOTTOM_RIGHT;
        }
        else {
            origin = IconOrigin["a" /* default */].TOP_RIGHT;
        }
    }
    return {
        x: parseFloat(node.getAttribute('x')),
        xunits: ICON_ANCHOR_UNITS_MAP[xunits],
        y: parseFloat(node.getAttribute('y')),
        yunits: ICON_ANCHOR_UNITS_MAP[yunits],
        origin: origin,
    };
}
/**
 * @param {Node} node Node.
 * @return {number|undefined} Scale.
 */
function readScale(node) {
    return readDecimal(node);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'Pair': pairDataParser,
});
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<Style>|string|undefined} StyleMap.
 */
function readStyleMapValue(node, objectStack) {
    return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'Icon': makeObjectPropertySetter(readIcon),
    'color': makeObjectPropertySetter(readColor),
    'heading': makeObjectPropertySetter(readDecimal),
    'hotSpot': makeObjectPropertySetter(readVec2),
    'scale': makeObjectPropertySetter(readScale),
});
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function iconStyleParser(node, objectStack) {
    // FIXME refreshMode
    // FIXME refreshInterval
    // FIXME viewRefreshTime
    // FIXME viewBoundScale
    // FIXME viewFormat
    // FIXME httpQuery
    var object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);
    if (!object) {
        return;
    }
    var styleObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
    var IconObject = 'Icon' in object ? object['Icon'] : {};
    var drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;
    var src;
    var href = /** @type {string|undefined} */ (IconObject['href']);
    if (href) {
        src = href;
    }
    else if (drawIcon) {
        src = DEFAULT_IMAGE_STYLE_SRC;
    }
    var anchor, anchorXUnits, anchorYUnits;
    var anchorOrigin = IconOrigin["a" /* default */].BOTTOM_LEFT;
    var hotSpot = /** @type {Vec2|undefined} */ (object['hotSpot']);
    if (hotSpot) {
        anchor = [hotSpot.x, hotSpot.y];
        anchorXUnits = hotSpot.xunits;
        anchorYUnits = hotSpot.yunits;
        anchorOrigin = hotSpot.origin;
    }
    else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
        // Google hotspots from https://kml4earth.appspot.com/icons.html#notes
        if (/pushpin/.test(src)) {
            anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
            anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
            anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
        }
        else if (/arrow-reverse/.test(src)) {
            anchor = [54, 42];
            anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
            anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
        }
        else if (/paddle/.test(src)) {
            anchor = [32, 1];
            anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
            anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
        }
    }
    var offset;
    var x = /** @type {number|undefined} */ (IconObject['x']);
    var y = /** @type {number|undefined} */ (IconObject['y']);
    if (x !== undefined && y !== undefined) {
        offset = [x, y];
    }
    var size;
    var w = /** @type {number|undefined} */ (IconObject['w']);
    var h = /** @type {number|undefined} */ (IconObject['h']);
    if (w !== undefined && h !== undefined) {
        size = [w, h];
    }
    var rotation;
    var heading = /** @type {number} */ (object['heading']);
    if (heading !== undefined) {
        rotation = Object(math["l" /* toRadians */])(heading);
    }
    var scale = /** @type {number|undefined} */ (object['scale']);
    var color = /** @type {Array<number>|undefined} */ (object['color']);
    if (drawIcon) {
        if (src == DEFAULT_IMAGE_STYLE_SRC) {
            size = DEFAULT_IMAGE_STYLE_SIZE;
        }
        var imageStyle_1 = new Icon["a" /* default */]({
            anchor: anchor,
            anchorOrigin: anchorOrigin,
            anchorXUnits: anchorXUnits,
            anchorYUnits: anchorYUnits,
            crossOrigin: this.crossOrigin_,
            offset: offset,
            offsetOrigin: IconOrigin["a" /* default */].BOTTOM_LEFT,
            rotation: rotation,
            scale: scale,
            size: size,
            src: this.iconUrlFunction_(src),
            color: color,
        });
        var imageScale_1 = imageStyle_1.getScaleArray()[0];
        var imageSize = imageStyle_1.getSize();
        if (imageSize === null) {
            var imageState = imageStyle_1.getImageState();
            if (imageState === ImageState["a" /* default */].IDLE || imageState === ImageState["a" /* default */].LOADING) {
                var listener_1 = function () {
                    var imageState = imageStyle_1.getImageState();
                    if (!(imageState === ImageState["a" /* default */].IDLE ||
                        imageState === ImageState["a" /* default */].LOADING)) {
                        var imageSize_1 = imageStyle_1.getSize();
                        if (imageSize_1 && imageSize_1.length == 2) {
                            var resizeScale = scaleForSize(imageSize_1);
                            imageStyle_1.setScale(imageScale_1 * resizeScale);
                        }
                        imageStyle_1.unlistenImageChange(listener_1);
                    }
                };
                imageStyle_1.listenImageChange(listener_1);
                if (imageState === ImageState["a" /* default */].IDLE) {
                    imageStyle_1.load();
                }
            }
        }
        else if (imageSize.length == 2) {
            var resizeScale = scaleForSize(imageSize);
            imageStyle_1.setScale(imageScale_1 * resizeScale);
        }
        styleObject['imageStyle'] = imageStyle_1;
    }
    else {
        // handle the case when we explicitly want to draw no icon.
        styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'color': makeObjectPropertySetter(readColor),
    'scale': makeObjectPropertySetter(readScale),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function labelStyleParser(node, objectStack) {
    // FIXME colorMode
    var object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);
    if (!object) {
        return;
    }
    var styleObject = objectStack[objectStack.length - 1];
    var textStyle = new Text["a" /* default */]({
        fill: new Fill["a" /* default */]({
            color: 
            /** @type {import("../color.js").Color} */
            ('color' in object ? object['color'] : DEFAULT_COLOR),
        }),
        scale: /** @type {number|undefined} */ (object['scale']),
    });
    styleObject['textStyle'] = textStyle;
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'color': makeObjectPropertySetter(readColor),
    'width': makeObjectPropertySetter(readDecimal),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function lineStyleParser(node, objectStack) {
    // FIXME colorMode
    // FIXME gx:outerColor
    // FIXME gx:outerWidth
    // FIXME gx:physicalWidth
    // FIXME gx:labelVisibility
    var object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);
    if (!object) {
        return;
    }
    var styleObject = objectStack[objectStack.length - 1];
    var strokeStyle = new Stroke["a" /* default */]({
        color: 
        /** @type {import("../color.js").Color} */
        ('color' in object ? object['color'] : DEFAULT_COLOR),
        width: /** @type {number} */ ('width' in object ? object['width'] : 1),
    });
    styleObject['strokeStyle'] = strokeStyle;
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'color': makeObjectPropertySetter(readColor),
    'fill': makeObjectPropertySetter(readBoolean),
    'outline': makeObjectPropertySetter(readBoolean),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function polyStyleParser(node, objectStack) {
    // FIXME colorMode
    var object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);
    if (!object) {
        return;
    }
    var styleObject = objectStack[objectStack.length - 1];
    var fillStyle = new Fill["a" /* default */]({
        color: 
        /** @type {import("../color.js").Color} */
        ('color' in object ? object['color'] : DEFAULT_COLOR),
    });
    styleObject['fillStyle'] = fillStyle;
    var fill = /** @type {boolean|undefined} */ (object['fill']);
    if (fill !== undefined) {
        styleObject['fill'] = fill;
    }
    var outline = /** @type {boolean|undefined} */ (object['outline']);
    if (outline !== undefined) {
        styleObject['outline'] = outline;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'coordinates': makeReplacer(readFlatCoordinates),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<number>} LinearRing flat coordinates.
 */
function readFlatLinearRing(node, objectStack) {
    return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function gxCoordParser(node, objectStack) {
    var gxTrackObject = 
    /** @type {GxTrackObject} */
    (objectStack[objectStack.length - 1]);
    var coordinates = gxTrackObject.coordinates;
    var s = getAllTextContent(node, false);
    var re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
    var m = re.exec(s);
    if (m) {
        var x = parseFloat(m[1]);
        var y = parseFloat(m[2]);
        var z = parseFloat(m[3]);
        coordinates.push([x, y, z]);
    }
    else {
        coordinates.push([]);
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {
    'Track': makeArrayPusher(readGxTrack),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {MultiLineString|undefined} MultiLineString.
 */
function readGxMultiTrack(node, objectStack) {
    var lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);
    if (!lineStrings) {
        return undefined;
    }
    return new MultiLineString["a" /* default */](lineStrings);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var GX_TRACK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'when': whenParser,
}, makeStructureNS(GX_NAMESPACE_URIS, {
    'coord': gxCoordParser,
}));
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {LineString|undefined} LineString.
 */
function readGxTrack(node, objectStack) {
    var gxTrackObject = pushParseAndPop(
    /** @type {GxTrackObject} */ ({
        coordinates: [],
        whens: [],
    }), GX_TRACK_PARSERS, node, objectStack);
    if (!gxTrackObject) {
        return undefined;
    }
    var flatCoordinates = [];
    var coordinates = gxTrackObject.coordinates;
    var whens = gxTrackObject.whens;
    for (var i = 0, ii = Math.min(coordinates.length, whens.length); i < ii; ++i) {
        if (coordinates[i].length == 3) {
            flatCoordinates.push(coordinates[i][0], coordinates[i][1], coordinates[i][2], whens[i]);
        }
    }
    return new LineString["a" /* default */](flatCoordinates, GeometryLayout["a" /* default */].XYZM);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var ICON_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'href': makeObjectPropertySetter(readURI),
}, makeStructureNS(GX_NAMESPACE_URIS, {
    'x': makeObjectPropertySetter(readDecimal),
    'y': makeObjectPropertySetter(readDecimal),
    'w': makeObjectPropertySetter(readDecimal),
    'h': makeObjectPropertySetter(readDecimal),
}));
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object} Icon object.
 */
function readIcon(node, objectStack) {
    var iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);
    if (iconObject) {
        return iconObject;
    }
    else {
        return null;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'coordinates': makeReplacer(readFlatCoordinates),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<number>} Flat coordinates.
 */
function readFlatCoordinatesFromNode(node, objectStack) {
    return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'extrude': makeObjectPropertySetter(readBoolean),
    'tessellate': makeObjectPropertySetter(readBoolean),
    'altitudeMode': makeObjectPropertySetter(readString),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {LineString|undefined} LineString.
 */
function readLineString(node, objectStack) {
    var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
    var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
        var lineString = new LineString["a" /* default */](flatCoordinates, GeometryLayout["a" /* default */].XYZ);
        lineString.setProperties(properties, true);
        return lineString;
    }
    else {
        return undefined;
    }
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Polygon|undefined} Polygon.
 */
function readLinearRing(node, objectStack) {
    var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
    var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
        var polygon = new Polygon["a" /* default */](flatCoordinates, GeometryLayout["a" /* default */].XYZ, [
            flatCoordinates.length,
        ]);
        polygon.setProperties(properties, true);
        return polygon;
    }
    else {
        return undefined;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'LineString': makeArrayPusher(readLineString),
    'LinearRing': makeArrayPusher(readLinearRing),
    'MultiGeometry': makeArrayPusher(readMultiGeometry),
    'Point': makeArrayPusher(readPoint),
    'Polygon': makeArrayPusher(readPolygon),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */
function readMultiGeometry(node, objectStack) {
    var geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node, objectStack);
    if (!geometries) {
        return null;
    }
    if (geometries.length === 0) {
        return new GeometryCollection["a" /* default */](geometries);
    }
    var multiGeometry;
    var homogeneous = true;
    var type = geometries[0].getType();
    var geometry;
    for (var i = 1, ii = geometries.length; i < ii; ++i) {
        geometry = geometries[i];
        if (geometry.getType() != type) {
            homogeneous = false;
            break;
        }
    }
    if (homogeneous) {
        var layout = void 0;
        var flatCoordinates = void 0;
        if (type == GeometryType["a" /* default */].POINT) {
            var point = geometries[0];
            layout = point.getLayout();
            flatCoordinates = point.getFlatCoordinates();
            for (var i = 1, ii = geometries.length; i < ii; ++i) {
                geometry = geometries[i];
                Object(ol_array["c" /* extend */])(flatCoordinates, geometry.getFlatCoordinates());
            }
            multiGeometry = new MultiPoint["a" /* default */](flatCoordinates, layout);
            setCommonGeometryProperties(multiGeometry, geometries);
        }
        else if (type == GeometryType["a" /* default */].LINE_STRING) {
            multiGeometry = new MultiLineString["a" /* default */](geometries);
            setCommonGeometryProperties(multiGeometry, geometries);
        }
        else if (type == GeometryType["a" /* default */].POLYGON) {
            multiGeometry = new MultiPolygon["a" /* default */](geometries);
            setCommonGeometryProperties(multiGeometry, geometries);
        }
        else if (type == GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
            multiGeometry = new GeometryCollection["a" /* default */](geometries);
        }
        else {
            Object(asserts["a" /* assert */])(false, 37); // Unknown geometry type found
        }
    }
    else {
        multiGeometry = new GeometryCollection["a" /* default */](geometries);
    }
    return /** @type {import("../geom/Geometry.js").default} */ (multiGeometry);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Point|undefined} Point.
 */
function readPoint(node, objectStack) {
    var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
    var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
        var point = new Point["a" /* default */](flatCoordinates, GeometryLayout["a" /* default */].XYZ);
        point.setProperties(properties, true);
        return point;
    }
    else {
        return undefined;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'innerBoundaryIs': innerBoundaryIsParser,
    'outerBoundaryIs': outerBoundaryIsParser,
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Polygon|undefined} Polygon.
 */
function readPolygon(node, objectStack) {
    var properties = pushParseAndPop(
    /** @type {Object<string,*>} */ ({}), EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
    var flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node, objectStack);
    if (flatLinearRings && flatLinearRings[0]) {
        var flatCoordinates = flatLinearRings[0];
        var ends = [flatCoordinates.length];
        for (var i = 1, ii = flatLinearRings.length; i < ii; ++i) {
            Object(ol_array["c" /* extend */])(flatCoordinates, flatLinearRings[i]);
            ends.push(flatCoordinates.length);
        }
        var polygon = new Polygon["a" /* default */](flatCoordinates, GeometryLayout["a" /* default */].XYZ, ends);
        polygon.setProperties(properties, true);
        return polygon;
    }
    else {
        return undefined;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'IconStyle': iconStyleParser,
    'LabelStyle': labelStyleParser,
    'LineStyle': lineStyleParser,
    'PolyStyle': polyStyleParser,
});
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<Style>} Style.
 */
function readStyle(node, objectStack) {
    var styleObject = pushParseAndPop({}, STYLE_PARSERS, node, objectStack, this);
    if (!styleObject) {
        return null;
    }
    var fillStyle = 
    /** @type {Fill} */
    ('fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE);
    var fill = /** @type {boolean|undefined} */ (styleObject['fill']);
    if (fill !== undefined && !fill) {
        fillStyle = null;
    }
    var imageStyle;
    if ('imageStyle' in styleObject) {
        if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {
            imageStyle = styleObject['imageStyle'];
        }
    }
    else {
        imageStyle = DEFAULT_IMAGE_STYLE;
    }
    var textStyle = 
    /** @type {Text} */
    ('textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE);
    var strokeStyle = 
    /** @type {Stroke} */
    ('strokeStyle' in styleObject
        ? styleObject['strokeStyle']
        : DEFAULT_STROKE_STYLE);
    var outline = /** @type {boolean|undefined} */ (styleObject['outline']);
    if (outline !== undefined && !outline) {
        // if the polystyle specifies no outline two styles are needed,
        // one for non-polygon geometries where linestrings require a stroke
        // and one for polygons where there should be no stroke
        return [
            new Style["c" /* default */]({
                geometry: function (feature) {
                    var geometry = feature.getGeometry();
                    var type = geometry.getType();
                    if (type === GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
                        var collection = 
                        /** @type {import("../geom/GeometryCollection").default} */ (geometry);
                        return new GeometryCollection["a" /* default */](collection
                            .getGeometriesArrayRecursive()
                            .filter(function (geometry) {
                            var type = geometry.getType();
                            return (type !== GeometryType["a" /* default */].POLYGON &&
                                type !== GeometryType["a" /* default */].MULTI_POLYGON);
                        }));
                    }
                    else if (type !== GeometryType["a" /* default */].POLYGON &&
                        type !== GeometryType["a" /* default */].MULTI_POLYGON) {
                        return geometry;
                    }
                },
                fill: fillStyle,
                image: imageStyle,
                stroke: strokeStyle,
                text: textStyle,
                zIndex: undefined, // FIXME
            }),
            new Style["c" /* default */]({
                geometry: function (feature) {
                    var geometry = feature.getGeometry();
                    var type = geometry.getType();
                    if (type === GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
                        var collection = 
                        /** @type {import("../geom/GeometryCollection").default} */ (geometry);
                        return new GeometryCollection["a" /* default */](collection
                            .getGeometriesArrayRecursive()
                            .filter(function (geometry) {
                            var type = geometry.getType();
                            return (type === GeometryType["a" /* default */].POLYGON ||
                                type === GeometryType["a" /* default */].MULTI_POLYGON);
                        }));
                    }
                    else if (type === GeometryType["a" /* default */].POLYGON ||
                        type === GeometryType["a" /* default */].MULTI_POLYGON) {
                        return geometry;
                    }
                },
                fill: fillStyle,
                stroke: null,
                zIndex: undefined, // FIXME
            }),
        ];
    }
    return [
        new Style["c" /* default */]({
            fill: fillStyle,
            image: imageStyle,
            stroke: strokeStyle,
            text: textStyle,
            zIndex: undefined, // FIXME
        }),
    ];
}
/**
 * Reads an array of geometries and creates arrays for common geometry
 * properties. Then sets them to the multi geometry.
 * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.
 * @param {Array<import("../geom/Geometry.js").default>} geometries List of geometries.
 */
function setCommonGeometryProperties(multiGeometry, geometries) {
    var ii = geometries.length;
    var extrudes = new Array(geometries.length);
    var tessellates = new Array(geometries.length);
    var altitudeModes = new Array(geometries.length);
    var hasExtrude, hasTessellate, hasAltitudeMode;
    hasExtrude = false;
    hasTessellate = false;
    hasAltitudeMode = false;
    for (var i = 0; i < ii; ++i) {
        var geometry = geometries[i];
        extrudes[i] = geometry.get('extrude');
        tessellates[i] = geometry.get('tessellate');
        altitudeModes[i] = geometry.get('altitudeMode');
        hasExtrude = hasExtrude || extrudes[i] !== undefined;
        hasTessellate = hasTessellate || tessellates[i] !== undefined;
        hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
    }
    if (hasExtrude) {
        multiGeometry.set('extrude', extrudes);
    }
    if (hasTessellate) {
        multiGeometry.set('tessellate', tessellates);
    }
    if (hasAltitudeMode) {
        multiGeometry.set('altitudeMode', altitudeModes);
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'displayName': makeObjectPropertySetter(readString),
    'value': makeObjectPropertySetter(readString),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function dataParser(node, objectStack) {
    var name = node.getAttribute('name');
    parseNode(DATA_PARSERS, node, objectStack);
    var featureObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
    if (name && featureObject.displayName) {
        featureObject[name] = {
            value: featureObject.value,
            displayName: featureObject.displayName,
            toString: function () {
                return featureObject.value;
            },
        };
    }
    else if (name !== null) {
        featureObject[name] = featureObject.value;
    }
    else if (featureObject.displayName !== null) {
        featureObject[featureObject.displayName] = featureObject.value;
    }
    delete featureObject['value'];
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'Data': dataParser,
    'SchemaData': schemaDataParser,
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function extendedDataParser(node, objectStack) {
    parseNode(EXTENDED_DATA_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function regionParser(node, objectStack) {
    parseNode(REGION_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'Style': makeObjectPropertySetter(readStyle),
    'key': makeObjectPropertySetter(readString),
    'styleUrl': makeObjectPropertySetter(readStyleURL),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function pairDataParser(node, objectStack) {
    var pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);
    if (!pairObject) {
        return;
    }
    var key = /** @type {string|undefined} */ (pairObject['key']);
    if (key && key == 'normal') {
        var styleUrl = /** @type {string|undefined} */ (pairObject['styleUrl']);
        if (styleUrl) {
            objectStack[objectStack.length - 1] = styleUrl;
        }
        var style = /** @type {Style} */ (pairObject['Style']);
        if (style) {
            objectStack[objectStack.length - 1] = style;
        }
    }
}
/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function placemarkStyleMapParser(node, objectStack) {
    var styleMapValue = readStyleMapValue.call(this, node, objectStack);
    if (!styleMapValue) {
        return;
    }
    var placemarkObject = objectStack[objectStack.length - 1];
    if (Array.isArray(styleMapValue)) {
        placemarkObject['Style'] = styleMapValue;
    }
    else if (typeof styleMapValue === 'string') {
        placemarkObject['styleUrl'] = styleMapValue;
    }
    else {
        Object(asserts["a" /* assert */])(false, 38); // `styleMapValue` has an unknown type
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'SimpleData': simpleDataParser,
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function schemaDataParser(node, objectStack) {
    parseNode(SCHEMA_DATA_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function simpleDataParser(node, objectStack) {
    var name = node.getAttribute('name');
    if (name !== null) {
        var data = readString(node);
        var featureObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        featureObject[name] = data;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'altitudeMode': makeObjectPropertySetter(readString),
    'minAltitude': makeObjectPropertySetter(readDecimal),
    'maxAltitude': makeObjectPropertySetter(readDecimal),
    'north': makeObjectPropertySetter(readDecimal),
    'south': makeObjectPropertySetter(readDecimal),
    'east': makeObjectPropertySetter(readDecimal),
    'west': makeObjectPropertySetter(readDecimal),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function latLonAltBoxParser(node, objectStack) {
    var object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);
    if (!object) {
        return;
    }
    var regionObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
    var extent = [
        parseFloat(object['west']),
        parseFloat(object['south']),
        parseFloat(object['east']),
        parseFloat(object['north']),
    ];
    regionObject['extent'] = extent;
    regionObject['altitudeMode'] = object['altitudeMode'];
    regionObject['minAltitude'] = parseFloat(object['minAltitude']);
    regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'minLodPixels': makeObjectPropertySetter(readDecimal),
    'maxLodPixels': makeObjectPropertySetter(readDecimal),
    'minFadeExtent': makeObjectPropertySetter(readDecimal),
    'maxFadeExtent': makeObjectPropertySetter(readDecimal),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function lodParser(node, objectStack) {
    var object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);
    if (!object) {
        return;
    }
    var lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
    lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);
    lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);
    lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);
    lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
    // allows multiple, so we parse multiple here too.
    'LinearRing': makeArrayPusher(readFlatLinearRing),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function innerBoundaryIsParser(node, objectStack) {
    var innerBoundaryFlatLinearRings = pushParseAndPop(
    /** @type {Array<Array<number>>} */ ([]), INNER_BOUNDARY_IS_PARSERS, node, objectStack);
    if (innerBoundaryFlatLinearRings.length > 0) {
        var flatLinearRings = 
        /** @type {Array<Array<number>>} */
        (objectStack[objectStack.length - 1]);
        flatLinearRings.push.apply(flatLinearRings, innerBoundaryFlatLinearRings);
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
var OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
    'LinearRing': makeReplacer(readFlatLinearRing),
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function outerBoundaryIsParser(node, objectStack) {
    /** @type {Array<number>|undefined} */
    var flatLinearRing = pushParseAndPop(undefined, OUTER_BOUNDARY_IS_PARSERS, node, objectStack);
    if (flatLinearRing) {
        var flatLinearRings = 
        /** @type {Array<Array<number>>} */
        (objectStack[objectStack.length - 1]);
        flatLinearRings[0] = flatLinearRing;
    }
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function linkParser(node, objectStack) {
    parseNode(LINK_PARSERS, node, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function whenParser(node, objectStack) {
    var gxTrackObject = 
    /** @type {GxTrackObject} */
    (objectStack[objectStack.length - 1]);
    var whens = gxTrackObject.whens;
    var s = getAllTextContent(node, false);
    var when = Date.parse(s);
    whens.push(isNaN(when) ? 0 : when);
}
/**
 * @param {Node} node Node to append a TextNode with the color to.
 * @param {import("../color.js").Color|string} color Color.
 */
function writeColorTextNode(node, color) {
    var rgba = Object(ol_color["a" /* asArray */])(color);
    var opacity = rgba.length == 4 ? rgba[3] : 1;
    /** @type {Array<string|number>} */
    var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
    for (var i = 0; i < 4; ++i) {
        var hex = Math.floor(/** @type {number} */ (abgr[i])).toString(16);
        abgr[i] = hex.length == 1 ? '0' + hex : hex;
    }
    writeStringTextNode(node, abgr.join(''));
}
/**
 * @param {Node} node Node to append a TextNode with the coordinates to.
 * @param {Array<number>} coordinates Coordinates.
 * @param {Array<*>} objectStack Object stack.
 */
function writeCoordinatesTextNode(node, coordinates, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var layout = context['layout'];
    var stride = context['stride'];
    var dimension;
    if (layout == GeometryLayout["a" /* default */].XY || layout == GeometryLayout["a" /* default */].XYM) {
        dimension = 2;
    }
    else if (layout == GeometryLayout["a" /* default */].XYZ || layout == GeometryLayout["a" /* default */].XYZM) {
        dimension = 3;
    }
    else {
        Object(asserts["a" /* assert */])(false, 34); // Invalid geometry layout
    }
    var ii = coordinates.length;
    var text = '';
    if (ii > 0) {
        text += coordinates[0];
        for (var d = 1; d < dimension; ++d) {
            text += ',' + coordinates[d];
        }
        for (var i = stride; i < ii; i += stride) {
            text += ' ' + coordinates[i];
            for (var d = 1; d < dimension; ++d) {
                text += ',' + coordinates[i + d];
            }
        }
    }
    writeStringTextNode(node, text);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'Data': makeChildAppender(writeDataNode),
    'value': makeChildAppender(writeDataNodeValue),
    'displayName': makeChildAppender(writeDataNodeName),
});
/**
 * @param {Element} node Node.
 * @param {{name: *, value: *}} pair Name value pair.
 * @param {Array<*>} objectStack Object stack.
 */
function writeDataNode(node, pair, objectStack) {
    node.setAttribute('name', pair.name);
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var value = pair.value;
    if (typeof value == 'object') {
        if (value !== null && value.displayName) {
            pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);
        }
        if (value !== null && value.value) {
            pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);
        }
    }
    else {
        pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);
    }
}
/**
 * @param {Node} node Node to append a TextNode with the name to.
 * @param {string} name DisplayName.
 */
function writeDataNodeName(node, name) {
    writeCDATASection(node, name);
}
/**
 * @param {Node} node Node to append a CDATA Section with the value to.
 * @param {string} value Value.
 */
function writeDataNodeValue(node, value) {
    writeStringTextNode(node, value);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'Placemark': makeChildAppender(writePlacemark),
});
/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [opt_nodeName] Node name.
 * @return {Node|undefined} Node.
 */
var DOCUMENT_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(parentNode.namespaceURI, 'Placemark');
};
/**
 * @param {Element} node Node.
 * @param {Array<Feature>} features Features.
 * @param {Array<*>} objectStack Object stack.
 * @this {KML}
 */
function writeDocument(node, features, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, undefined, this);
}
/**
 * A factory for creating Data nodes.
 * @const
 * @type {function(*, Array<*>): (Node|undefined)}
 */
var DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');
/**
 * @param {Element} node Node.
 * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.
 * @param {Array<*>} objectStack Object stack.
 */
function writeExtendedData(node, namesAndValues, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var names = namesAndValues.names;
    var values = namesAndValues.values;
    var length = names.length;
    for (var i = 0; i < length; i++) {
        pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{ name: names[i], value: values[i] }], objectStack);
    }
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var ICON_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['href'], makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h']));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var ICON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'href': makeChildAppender(writeStringTextNode),
}, makeStructureNS(GX_NAMESPACE_URIS, {
    'x': makeChildAppender(writeDecimalTextNode),
    'y': makeChildAppender(writeDecimalTextNode),
    'w': makeChildAppender(writeDecimalTextNode),
    'h': makeChildAppender(writeDecimalTextNode),
}));
/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [opt_nodeName] Node name.
 * @return {Node|undefined} Node.
 */
var GX_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
    return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + opt_nodeName);
};
/**
 * @param {Element} node Node.
 * @param {Object} icon Icon object.
 * @param {Array<*>} objectStack Object stack.
 */
function writeIcon(node, icon, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(icon, orderedKeys);
    pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
    values = makeSequence(icon, orderedKeys);
    pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
    'scale',
    'heading',
    'Icon',
    'color',
    'hotSpot',
]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'Icon': makeChildAppender(writeIcon),
    'color': makeChildAppender(writeColorTextNode),
    'heading': makeChildAppender(writeDecimalTextNode),
    'hotSpot': makeChildAppender(writeVec2),
    'scale': makeChildAppender(writeScaleTextNode),
});
/**
 * @param {Element} node Node.
 * @param {import("../style/Icon.js").default} style Icon style.
 * @param {Array<*>} objectStack Object stack.
 */
function writeIconStyle(node, style, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var /** @type {Object<string, any>} */ properties = {};
    var src = style.getSrc();
    var size = style.getSize();
    var iconImageSize = style.getImageSize();
    var iconProperties = {
        'href': src,
    };
    if (size) {
        iconProperties['w'] = size[0];
        iconProperties['h'] = size[1];
        var anchor = style.getAnchor(); // top-left
        var origin_1 = style.getOrigin(); // top-left
        if (origin_1 && iconImageSize && origin_1[0] !== 0 && origin_1[1] !== size[1]) {
            iconProperties['x'] = origin_1[0];
            iconProperties['y'] = iconImageSize[1] - (origin_1[1] + size[1]);
        }
        if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
            var /** @type {Vec2} */ hotSpot = {
                x: anchor[0],
                xunits: IconAnchorUnits["a" /* default */].PIXELS,
                y: size[1] - anchor[1],
                yunits: IconAnchorUnits["a" /* default */].PIXELS,
            };
            properties['hotSpot'] = hotSpot;
        }
    }
    properties['Icon'] = iconProperties;
    var scale = style.getScaleArray()[0];
    var imageSize = size;
    if (imageSize === null) {
        imageSize = DEFAULT_IMAGE_STYLE_SIZE;
    }
    if (imageSize.length == 2) {
        var resizeScale = scaleForSize(imageSize);
        scale = scale / resizeScale;
    }
    if (scale !== 1) {
        properties['scale'] = scale;
    }
    var rotation = style.getRotation();
    if (rotation !== 0) {
        properties['heading'] = rotation; // 0-360
    }
    var color = style.getColor();
    if (color) {
        properties['color'] = color;
    }
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
    'color',
    'scale',
]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'color': makeChildAppender(writeColorTextNode),
    'scale': makeChildAppender(writeScaleTextNode),
});
/**
 * @param {Element} node Node.
 * @param {Text} style style.
 * @param {Array<*>} objectStack Object stack.
 */
function writeLabelStyle(node, style, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var properties = {};
    var fill = style.getFill();
    if (fill) {
        properties['color'] = fill.getColor();
    }
    var scale = style.getScale();
    if (scale && scale !== 1) {
        properties['scale'] = scale;
    }
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'color': makeChildAppender(writeColorTextNode),
    'width': makeChildAppender(writeDecimalTextNode),
});
/**
 * @param {Element} node Node.
 * @param {Stroke} style style.
 * @param {Array<*>} objectStack Object stack.
 */
function writeLineStyle(node, style, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var properties = {
        'color': style.getColor(),
        'width': Number(style.getWidth()) || 1,
    };
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, string>}
 */
var GEOMETRY_TYPE_TO_NODENAME = {
    'Point': 'Point',
    'LineString': 'LineString',
    'LinearRing': 'LinearRing',
    'Polygon': 'Polygon',
    'MultiPoint': 'MultiGeometry',
    'MultiLineString': 'MultiGeometry',
    'MultiPolygon': 'MultiGeometry',
    'GeometryCollection': 'MultiGeometry',
};
/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [opt_nodeName] Node name.
 * @return {Node|undefined} Node.
 */
var GEOMETRY_NODE_FACTORY = function (value, objectStack, opt_nodeName) {
    if (value) {
        var parentNode = objectStack[objectStack.length - 1].node;
        return createElementNS(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME[
        /** @type {import("../geom/Geometry.js").default} */ (value).getType()]);
    }
};
/**
 * A factory for creating Point nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
var POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');
/**
 * A factory for creating LineString nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
var LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');
/**
 * A factory for creating LinearRing nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
var LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');
/**
 * A factory for creating Polygon nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
var POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'LineString': makeChildAppender(writePrimitiveGeometry),
    'Point': makeChildAppender(writePrimitiveGeometry),
    'Polygon': makeChildAppender(writePolygon),
    'GeometryCollection': makeChildAppender(writeMultiGeometry),
});
/**
 * @param {Element} node Node.
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {Array<*>} objectStack Object stack.
 */
function writeMultiGeometry(node, geometry, objectStack) {
    /** @type {import("../xml.js").NodeStackItem} */
    var context = { node: node };
    var type = geometry.getType();
    /** @type {Array<import("../geom/Geometry.js").default>} */
    var geometries = [];
    /** @type {function(*, Array<*>, string=): (Node|undefined)} */
    var factory;
    if (type === GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
        /** @type {GeometryCollection} */ (geometry)
            .getGeometriesArrayRecursive()
            .forEach(function (geometry) {
            var type = geometry.getType();
            if (type === GeometryType["a" /* default */].MULTI_POINT) {
                geometries = geometries.concat(
                /** @type {MultiPoint} */ (geometry).getPoints());
            }
            else if (type === GeometryType["a" /* default */].MULTI_LINE_STRING) {
                geometries = geometries.concat(
                /** @type {MultiLineString} */ (geometry).getLineStrings());
            }
            else if (type === GeometryType["a" /* default */].MULTI_POLYGON) {
                geometries = geometries.concat(
                /** @type {MultiPolygon} */ (geometry).getPolygons());
            }
            else if (type === GeometryType["a" /* default */].POINT ||
                type === GeometryType["a" /* default */].LINE_STRING ||
                type === GeometryType["a" /* default */].POLYGON) {
                geometries.push(geometry);
            }
            else {
                Object(asserts["a" /* assert */])(false, 39); // Unknown geometry type
            }
        });
        factory = GEOMETRY_NODE_FACTORY;
    }
    else if (type === GeometryType["a" /* default */].MULTI_POINT) {
        geometries = /** @type {MultiPoint} */ (geometry).getPoints();
        factory = POINT_NODE_FACTORY;
    }
    else if (type === GeometryType["a" /* default */].MULTI_LINE_STRING) {
        geometries = /** @type {MultiLineString} */ (geometry).getLineStrings();
        factory = LINE_STRING_NODE_FACTORY;
    }
    else if (type === GeometryType["a" /* default */].MULTI_POLYGON) {
        geometries = /** @type {MultiPolygon} */ (geometry).getPolygons();
        factory = POLYGON_NODE_FACTORY;
    }
    else {
        Object(asserts["a" /* assert */])(false, 39); // Unknown geometry type
    }
    pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'LinearRing': makeChildAppender(writePrimitiveGeometry),
});
/**
 * @param {Element} node Node.
 * @param {import("../geom/LinearRing.js").default} linearRing Linear ring.
 * @param {Array<*>} objectStack Object stack.
 */
function writeBoundaryIs(node, linearRing, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'ExtendedData': makeChildAppender(writeExtendedData),
    'MultiGeometry': makeChildAppender(writeMultiGeometry),
    'LineString': makeChildAppender(writePrimitiveGeometry),
    'LinearRing': makeChildAppender(writePrimitiveGeometry),
    'Point': makeChildAppender(writePrimitiveGeometry),
    'Polygon': makeChildAppender(writePolygon),
    'Style': makeChildAppender(writeStyle),
    'address': makeChildAppender(writeStringTextNode),
    'description': makeChildAppender(writeStringTextNode),
    'name': makeChildAppender(writeStringTextNode),
    'open': makeChildAppender(writeBooleanTextNode),
    'phoneNumber': makeChildAppender(writeStringTextNode),
    'styleUrl': makeChildAppender(writeStringTextNode),
    'visibility': makeChildAppender(writeBooleanTextNode),
});
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
    'name',
    'open',
    'visibility',
    'address',
    'phoneNumber',
    'description',
    'styleUrl',
    'Style',
]);
/**
 * A factory for creating ExtendedData nodes.
 * @const
 * @type {function(*, Array<*>): (Node|undefined)}
 */
var EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');
/**
 * FIXME currently we do serialize arbitrary/custom feature properties
 * (ExtendedData).
 * @param {Element} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 * @this {KML}
 */
function writePlacemark(node, feature, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    // set id
    if (feature.getId()) {
        node.setAttribute('id', /** @type {string} */ (feature.getId()));
    }
    // serialize properties (properties unknown to KML are not serialized)
    var properties = feature.getProperties();
    // don't export these to ExtendedData
    var filter = {
        'address': 1,
        'description': 1,
        'name': 1,
        'open': 1,
        'phoneNumber': 1,
        'styleUrl': 1,
        'visibility': 1,
    };
    filter[feature.getGeometryName()] = 1;
    var keys = Object.keys(properties || {})
        .sort()
        .filter(function (v) {
        return !filter[v];
    });
    var styleFunction = feature.getStyleFunction();
    if (styleFunction) {
        // FIXME the styles returned by the style function are supposed to be
        // resolution-independent here
        var styles = styleFunction(feature, 0);
        if (styles) {
            var styleArray = Array.isArray(styles) ? styles : [styles];
            var pointStyles = styleArray;
            if (feature.getGeometry()) {
                pointStyles = styleArray.filter(function (style) {
                    var geometry = style.getGeometryFunction()(feature);
                    if (geometry) {
                        var type = geometry.getType();
                        if (type === GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
                            return /** @type {GeometryCollection} */ (geometry)
                                .getGeometriesArrayRecursive()
                                .filter(function (geometry) {
                                var type = geometry.getType();
                                return (type === GeometryType["a" /* default */].POINT ||
                                    type === GeometryType["a" /* default */].MULTI_POINT);
                            }).length;
                        }
                        return (type === GeometryType["a" /* default */].POINT || type === GeometryType["a" /* default */].MULTI_POINT);
                    }
                });
            }
            if (this.writeStyles_) {
                var lineStyles = styleArray;
                var polyStyles = styleArray;
                if (feature.getGeometry()) {
                    lineStyles = styleArray.filter(function (style) {
                        var geometry = style.getGeometryFunction()(feature);
                        if (geometry) {
                            var type = geometry.getType();
                            if (type === GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
                                return /** @type {GeometryCollection} */ (geometry)
                                    .getGeometriesArrayRecursive()
                                    .filter(function (geometry) {
                                    var type = geometry.getType();
                                    return (type === GeometryType["a" /* default */].LINE_STRING ||
                                        type === GeometryType["a" /* default */].MULTI_LINE_STRING);
                                }).length;
                            }
                            return (type === GeometryType["a" /* default */].LINE_STRING ||
                                type === GeometryType["a" /* default */].MULTI_LINE_STRING);
                        }
                    });
                    polyStyles = styleArray.filter(function (style) {
                        var geometry = style.getGeometryFunction()(feature);
                        if (geometry) {
                            var type = geometry.getType();
                            if (type === GeometryType["a" /* default */].GEOMETRY_COLLECTION) {
                                return /** @type {GeometryCollection} */ (geometry)
                                    .getGeometriesArrayRecursive()
                                    .filter(function (geometry) {
                                    var type = geometry.getType();
                                    return (type === GeometryType["a" /* default */].POLYGON ||
                                        type === GeometryType["a" /* default */].MULTI_POLYGON);
                                }).length;
                            }
                            return (type === GeometryType["a" /* default */].POLYGON ||
                                type === GeometryType["a" /* default */].MULTI_POLYGON);
                        }
                    });
                }
                properties['Style'] = {
                    pointStyles: pointStyles,
                    lineStyles: lineStyles,
                    polyStyles: polyStyles,
                };
            }
            if (pointStyles.length && properties['name'] === undefined) {
                var textStyle = pointStyles[0].getText();
                if (textStyle) {
                    properties['name'] = textStyle.getText();
                }
            }
        }
    }
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
    if (keys.length > 0) {
        var sequence = makeSequence(properties, keys);
        var namesAndValues = { names: keys, values: sequence };
        pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
    }
    // serialize geometry
    var options = /** @type {import("./Feature.js").WriteOptions} */ (objectStack[0]);
    var geometry = feature.getGeometry();
    if (geometry) {
        geometry = Object(format_Feature["b" /* transformGeometryWithOptions */])(geometry, true, options);
    }
    pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
    'extrude',
    'tessellate',
    'altitudeMode',
    'coordinates',
]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'extrude': makeChildAppender(writeBooleanTextNode),
    'tessellate': makeChildAppender(writeBooleanTextNode),
    'altitudeMode': makeChildAppender(writeStringTextNode),
    'coordinates': makeChildAppender(writeCoordinatesTextNode),
});
/**
 * @param {Element} node Node.
 * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @param {Array<*>} objectStack Object stack.
 */
function writePrimitiveGeometry(node, geometry, objectStack) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    context['layout'] = geometry.getLayout();
    context['stride'] = geometry.getStride();
    // serialize properties (properties unknown to KML are not serialized)
    var properties = geometry.getProperties();
    properties.coordinates = flatCoordinates;
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
    'color',
    'fill',
    'outline',
]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'outerBoundaryIs': makeChildAppender(writeBoundaryIs),
    'innerBoundaryIs': makeChildAppender(writeBoundaryIs),
});
/**
 * A factory for creating innerBoundaryIs nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
var INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');
/**
 * A factory for creating outerBoundaryIs nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
var OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');
/**
 * @param {Element} node Node.
 * @param {Polygon} polygon Polygon.
 * @param {Array<*>} objectStack Object stack.
 */
function writePolygon(node, polygon, objectStack) {
    var linearRings = polygon.getLinearRings();
    var outerRing = linearRings.shift();
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    // inner rings
    pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings, objectStack);
    // outer ring
    pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'color': makeChildAppender(writeColorTextNode),
    'fill': makeChildAppender(writeBooleanTextNode),
    'outline': makeChildAppender(writeBooleanTextNode),
});
/**
 * @param {Element} node Node.
 * @param {Style} style Style.
 * @param {Array<*>} objectStack Object stack.
 */
function writePolyStyle(node, style, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var fill = style.getFill();
    var stroke = style.getStroke();
    var properties = {
        'color': fill ? fill.getColor() : undefined,
        'fill': fill ? undefined : false,
        'outline': stroke ? undefined : false,
    };
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @param {Node} node Node to append a TextNode with the scale to.
 * @param {number|undefined} scale Scale.
 */
function writeScaleTextNode(node, scale) {
    // the Math is to remove any excess decimals created by float arithmetic
    writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);
}
/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
var STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
    'IconStyle',
    'LabelStyle',
    'LineStyle',
    'PolyStyle',
]);
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
var STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
    'IconStyle': makeChildAppender(writeIconStyle),
    'LabelStyle': makeChildAppender(writeLabelStyle),
    'LineStyle': makeChildAppender(writeLineStyle),
    'PolyStyle': makeChildAppender(writePolyStyle),
});
/**
 * @param {Element} node Node.
 * @param {Object<string, Array<Style>>} styles Styles.
 * @param {Array<*>} objectStack Object stack.
 */
function writeStyle(node, styles, objectStack) {
    var /** @type {import("../xml.js").NodeStackItem} */ context = { node: node };
    var properties = {};
    if (styles.pointStyles.length) {
        var textStyle = styles.pointStyles[0].getText();
        if (textStyle) {
            properties['LabelStyle'] = textStyle;
        }
        var imageStyle = styles.pointStyles[0].getImage();
        if (imageStyle &&
            typeof ( /** @type {?} */(imageStyle).getSrc) === 'function') {
            properties['IconStyle'] = imageStyle;
        }
    }
    if (styles.lineStyles.length) {
        var strokeStyle = styles.lineStyles[0].getStroke();
        if (strokeStyle) {
            properties['LineStyle'] = strokeStyle;
        }
    }
    if (styles.polyStyles.length) {
        var strokeStyle = styles.polyStyles[0].getStroke();
        if (strokeStyle && !properties['LineStyle']) {
            properties['LineStyle'] = strokeStyle;
        }
        properties['PolyStyle'] = styles.polyStyles[0];
    }
    var parentNode = objectStack[objectStack.length - 1].node;
    var orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
/**
 * @param {Element} node Node to append a TextNode with the Vec2 to.
 * @param {Vec2} vec2 Vec2.
 */
function writeVec2(node, vec2) {
    node.setAttribute('x', String(vec2.x));
    node.setAttribute('y', String(vec2.y));
    node.setAttribute('xunits', vec2.xunits);
    node.setAttribute('yunits', vec2.yunits);
}
/* harmony default export */ var format_KML = (KML_KML);
//# sourceMappingURL=KML.js.map
// EXTERNAL MODULE: ./node_modules/ol/format/GeoJSON.js + 1 modules
var GeoJSON = __webpack_require__("a2e1");

// CONCATENATED MODULE: ./src/plugins/wg-tgos-4-ol-plugin/TGAgent_OL.js
// https://api.tgos.tw//TGOS_MAP_API/Web/Sample_Codes/TGOSMapAPI/QuickExample/OpenLayers/TGAgent_OL.js

/*
export default {
  getTileAgentPath: function () {
    return "api.tgos.tw/"
  },
  getWebProtocal: function () {
    return 'https:' == document.location.protocol ? 'https://' : 'http://'
  },
  TGOS: {
    TILE_AGENT_PATH: this.getWebProtocal() + this.getTileAgentPath() + "TileAgent",
    CoordSys: {
      EPSG3857: 'EPSG3857',
      EPSG4326: 'EPSG4326',
      EPSG3826: 'EPSG3826',
      EPSG3825: 'EPSG3825'
    },
    TGMapTileId: {
      TGOSMAP: 'TGOSMAP',
      F2IMAGE: 'F2IMAGE',
      ROADMAP: 'ROADMAP',
      HILLSHADE: 'HILLSHADE',
      HILLSHADEMIX: 'HILLSHADEMIX',
      MOTCMAP: 'MOTCMAP',
      NLSCMAP: 'NLSCMAP',
      CITYZONING: 'CITYZONING',
      RURALZONING: 'RURALZONING',
      LANDUSE: 'LANDUSE',
      TOPO1000: 'TOPO1000'
    },
    getTileAgentPath: function (mapTileId, crs) {
      let path = this.TGOS.TILE_AGENT_PATH + '/' + mapTileId
      if (crs == 'EPSG3857') {
        path += '_W'
      }
      if (crs == 'EPSG3825') {
        path += '_119'
      }
      path += '.aspx'
      return path
    },
    TGKey: function (appID, apiKey) {
      let appID_ = appID
      let apiKey_ = apiKey
      this.setAppID = function (id) {
        appID_ = id
      }
      this.getAppID = function () {
        return appID_
      }
      this.setApiKey = function (key) {
        apiKey_ = key
      }
      this.getApiKey = function () {
        return apiKey_
      }
    }
  }
}
*/
// TODO : 圖磚代理程式的網址
var getTileAgentPath = function getTileAgentPath() {
  //return ("203.66.168.227/");  // keep last '/'
  return 'api.tgos.tw/'; // keep last '/'
}; //=== 修改上面的 Agent 位址 ===========================================================


var getWebProtocal = function getWebProtocal() {
  return 'https:' == document.location.protocol ? 'https://' : 'http://';
};

var TGOS = TGOS || {
  TILE_AGENT_PATH: getWebProtocal() + getTileAgentPath() + 'TileAgent'
};
TGOS.CoordSys = TGOS.CoordSys || {};
TGOS.CoordSys = {
  EPSG3857: 'EPSG3857',
  EPSG4326: 'EPSG4326',
  EPSG3826: 'EPSG3826',
  EPSG3825: 'EPSG3825'
};
TGOS.TGMapTileId = TGOS.TGMapTileId || {};
TGOS.TGMapTileId = {
  TGOSMAP: 'TGOSMAP',
  F2IMAGE: 'F2IMAGE',
  ROADMAP: 'ROADMAP',
  HILLSHADE: 'HILLSHADE',
  HILLSHADEMIX: 'HILLSHADEMIX',
  MOTCMAP: 'MOTCMAP',
  NLSCMAP: 'NLSCMAP',
  CITYZONING: 'CITYZONING',
  RURALZONING: 'RURALZONING',
  LANDUSE: 'LANDUSE',
  TOPO1000: 'TOPO1000'
};

TGOS.getTileAgentPath = function (mapTileId, crs) {
  var path = TGOS.TILE_AGENT_PATH + '/' + mapTileId;

  if (crs == 'EPSG3857') {
    path += '_W';
  }

  if (crs == 'EPSG3825') {
    path += '_119';
  }

  path += '.aspx';
  return path;
};

TGOS.TGKey = function (appID, apiKey) {
  var appID_ = appID;
  var apiKey_ = apiKey;

  this.setAppID = function (id) {
    appID_ = id;
  };

  this.getAppID = function () {
    return appID_;
  };

  this.setApiKey = function (key) {
    apiKey_ = key;
  };

  this.getApiKey = function () {
    return apiKey_;
  };
};

/* harmony default export */ var TGAgent_OL = (TGOS);
// EXTERNAL MODULE: ./node_modules/json5/dist/index.js
var dist = __webpack_require__("5e48");
var dist_default = /*#__PURE__*/__webpack_require__.n(dist);

// EXTERNAL MODULE: ./node_modules/ol/proj/Projection.js
var Projection = __webpack_require__("f5dd");

// EXTERNAL MODULE: ./node_modules/ol/proj/Units.js
var Units = __webpack_require__("fced");

// EXTERNAL MODULE: ./node_modules/ol/proj/transforms.js
var transforms = __webpack_require__("c15b");

// CONCATENATED MODULE: ./node_modules/ol/proj/proj4.js
/**
 * @module ol/proj/proj4
 */




/**
 * Make projections defined in proj4 (with `proj4.defs()`) available in
 * OpenLayers.
 *
 * This function should be called whenever changes are made to the proj4
 * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be
 * modified by this function.
 *
 * @param {?} proj4 Proj4.
 * @api
 */
function register(proj4) {
    var projCodes = Object.keys(proj4.defs);
    var len = projCodes.length;
    var i, j;
    for (i = 0; i < len; ++i) {
        var code = projCodes[i];
        if (!Object(ol_proj["m" /* get */])(code)) {
            var def = proj4.defs(code);
            var units = def.units;
            if (!units && def.projName === 'longlat') {
                units = Units["b" /* default */].DEGREES;
            }
            Object(ol_proj["e" /* addProjection */])(new Projection["a" /* default */]({
                code: code,
                axisOrientation: def.axis,
                metersPerUnit: def.to_meter,
                units: units,
            }));
        }
    }
    for (i = 0; i < len; ++i) {
        var code1 = projCodes[i];
        var proj1 = Object(ol_proj["m" /* get */])(code1);
        for (j = 0; j < len; ++j) {
            var code2 = projCodes[j];
            var proj2 = Object(ol_proj["m" /* get */])(code2);
            if (!Object(transforms["c" /* get */])(code1, code2)) {
                if (proj4.defs[code1] === proj4.defs[code2]) {
                    Object(ol_proj["d" /* addEquivalentProjections */])([proj1, proj2]);
                }
                else {
                    var transform = proj4(code1, code2);
                    Object(ol_proj["c" /* addCoordinateTransforms */])(proj1, proj2, Object(ol_proj["g" /* createSafeCoordinateTransform */])(proj1, proj2, transform.forward), Object(ol_proj["g" /* createSafeCoordinateTransform */])(proj2, proj1, transform.inverse));
                }
            }
        }
    }
}
//# sourceMappingURL=proj4.js.map
// CONCATENATED MODULE: ./node_modules/proj4/lib/global.js
/* harmony default export */ var global = (function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI/2;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10;
// you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI/4;
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/PrimeMeridian.js
var PrimeMeridian_exports = {};


PrimeMeridian_exports.greenwich = 0.0; //"0dE",
PrimeMeridian_exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
PrimeMeridian_exports.paris = 2.337229166667; //"2d20'14.025\"E",
PrimeMeridian_exports.bogota = -74.080916666667; //"74d04'51.3\"W",
PrimeMeridian_exports.madrid = -3.687938888889; //"3d41'16.58\"W",
PrimeMeridian_exports.rome = 12.452333333333; //"12d27'8.4\"E",
PrimeMeridian_exports.bern = 7.439583333333; //"7d26'22.5\"E",
PrimeMeridian_exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
PrimeMeridian_exports.ferro = -17.666666666667; //"17d40'W",
PrimeMeridian_exports.brussels = 4.367975; //"4d22'4.71\"E",
PrimeMeridian_exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
PrimeMeridian_exports.athens = 23.7163375; //"23d42'58.815\"E",
PrimeMeridian_exports.oslo = 10.722916666667; //"10d43'22.5\"E"

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/units.js
/* harmony default export */ var constants_units = ({
  ft: {to_meter: 0.3048},
  'us-ft': {to_meter: 1200 / 3937}
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/projString.js





/* harmony default export */ var projString = (function(defData) {
  var self = {};
  var paramObj = defData.split('+').map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self.long0 = v * D2R;
    },
    lon_1: function(v) {
      self.long1 = v * D2R;
    },
    lon_2: function(v) {
      self.long2 = v * D2R;
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    gamma: function(v) {
      self.rectified_grid_angle = parseFloat(v);
    },
    lonc: function(v) {
      self.longc = v * D2R;
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      var unit = match(constants_units, v);
      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function(v) {
      var pm = match(PrimeMeridian_exports, v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    },
    approx: function() {
      self.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
});

// CONCATENATED MODULE: ./node_modules/wkt-parser/parser.js
/* harmony default export */ var parser = (parseString);

var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char)
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === ']') {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}

// CONCATENATED MODULE: ./node_modules/wkt-parser/process.js


function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;

  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj
  }, thing);
  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === 'PARAMETER') {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }
  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;
  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}

// CONCATENATED MODULE: ./node_modules/wkt-parser/index.js
var wkt_parser_D2R = 0.01745329251994329577;





function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * wkt_parser_D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = '';
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
        axisOrder += 'n';
      } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
        axisOrder += 's';
      } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
        axisOrder += 'e';
      } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
        axisOrder += 'w';
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }
  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }
    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }
    if (~wkt.datumCode.indexOf('tm65')
      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }
    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }
    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_1', 'Latitude of 1st standard parallel'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
    ['false_easting', 'False_Easting'],
    ['false_easting', 'False easting'],
    ['false-easting', 'Easting at false origin'],
    ['false_northing', 'False_Northing'],
    ['false_northing', 'False northing'],
    ['false_northing', 'Northing at false origin'],
    ['central_meridian', 'Central_Meridian'],
    ['central_meridian', 'Longitude of natural origin'],
    ['central_meridian', 'Longitude of false origin'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['latitude_of_origin', 'Latitude of natural origin'],
    ['latitude_of_origin', 'Latitude of false origin'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_Of_Center'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longitude_of_center', 'Longitude_of_center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['azimuth', 'Azimuth'],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}
/* harmony default export */ var wkt_parser = (function(wkt) {
  var lisp = parser(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/defs.js




function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = projString(arguments[1]);
      }
      else {
        defs[name] = wkt_parser(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
global(defs);
/* harmony default export */ var lib_defs = (defs);

// CONCATENATED MODULE: ./node_modules/proj4/lib/parseCode.js




function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in lib_defs;
}
var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
function testWKT(code){
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ['3857', '900913', '3785', '102113'];
function checkMercator(item) {
  var auth = match(item, 'authority');
  if (!auth) {
    return;
  }
  var code = match(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, 'extension');
  if (!ext) {
    return;
  }
  return match(ext, 'proj4');
}
function testProj(code){
  return code[0] === '+';
}
function parseCode_parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return lib_defs[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser(code);
      // test of spetial case, due to this being a very common and often malformed
      if (checkMercator(out)) {
        return lib_defs['EPSG:3857'];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString(code);
    }
  }else{
    return code;
  }
}

/* harmony default export */ var parseCode = (parseCode_parse);

// CONCATENATED MODULE: ./node_modules/proj4/lib/extend.js
/* harmony default export */ var extend = (function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/msfnz.js
/* harmony default export */ var msfnz = (function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sign.js
/* harmony default export */ var common_sign = (function(x) {
  return x<0 ? -1 : 1;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lon.js




/* harmony default export */ var adjust_lon = (function(x) {
  return (Math.abs(x) <= SPI) ? x : (x - (common_sign(x) * TWO_PI));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/tsfnz.js


/* harmony default export */ var tsfnz = (function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/phi2z.js


/* harmony default export */ var phi2z = (function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/merc.js






function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
}

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}

/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
function merc_inverse(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
}

var merc_names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ var merc = ({
  init: init,
  forward: forward,
  inverse: merc_inverse,
  names: merc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/longlat.js
function longlat_init() {
  //no-op for longlat
}

function identity(pt) {
  return pt;
}


var longlat_names = ["longlat", "identity"];
/* harmony default export */ var longlat = ({
  init: longlat_init,
  forward: identity,
  inverse: identity,
  names: longlat_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections.js


var projs = [merc, longlat];
var projections_names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    projections_names[n.toLowerCase()] = len;
  });
  return this;
}



function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof projections_names[n] !== 'undefined' && projStore[projections_names[n]]) {
    return projStore[projections_names[n]];
  }
}

function start() {
  projs.forEach(add);
}
/* harmony default export */ var projections = ({
  start: start,
  add: add,
  get: get
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Ellipsoid.js
var Ellipsoid_exports = {};

Ellipsoid_exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};

Ellipsoid_exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};

Ellipsoid_exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};

Ellipsoid_exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};

Ellipsoid_exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};

Ellipsoid_exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};

Ellipsoid_exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};

Ellipsoid_exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};

Ellipsoid_exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};

Ellipsoid_exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};

Ellipsoid_exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};

Ellipsoid_exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};

Ellipsoid_exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};

Ellipsoid_exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};

Ellipsoid_exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};

Ellipsoid_exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};

Ellipsoid_exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};

Ellipsoid_exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};

Ellipsoid_exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};

Ellipsoid_exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};

Ellipsoid_exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};

Ellipsoid_exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};

Ellipsoid_exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};

Ellipsoid_exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};

Ellipsoid_exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};

Ellipsoid_exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};

Ellipsoid_exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};

Ellipsoid_exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};

Ellipsoid_exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};

Ellipsoid_exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};

Ellipsoid_exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};

Ellipsoid_exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};

Ellipsoid_exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};

Ellipsoid_exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};

Ellipsoid_exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};

Ellipsoid_exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};

Ellipsoid_exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};

Ellipsoid_exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};

Ellipsoid_exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};

Ellipsoid_exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};

Ellipsoid_exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};

var WGS84 = Ellipsoid_exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};

Ellipsoid_exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};

// CONCATENATED MODULE: ./node_modules/proj4/lib/deriveConstants.js




function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric
  var b2 = b * b; // used in geocentric
  var es = (a2 - b2) / a2; // e ^ 2
  var e = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }
  var ep2 = (a2 - b2) / b2; // used in geocentric
  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function deriveConstants_sphere(a, b, rf, ellps, sphere) {
  if (!a) { // do we have an ellipsoid?
    var ellipse = match(Ellipsoid_exports, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere = true;
    b = a;
  }
  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Datum.js
var Datum_exports = {};

Datum_exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};

Datum_exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};

Datum_exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};

Datum_exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};

Datum_exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};

Datum_exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};

Datum_exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};

Datum_exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};

Datum_exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};

Datum_exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};

Datum_exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};

Datum_exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};

Datum_exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};

Datum_exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};

Datum_exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};

Datum_exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};

Datum_exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};

// CONCATENATED MODULE: ./node_modules/proj4/lib/datum.js


function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a; //datum object also uses these values
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ var lib_datum = (datum);

// CONCATENATED MODULE: ./node_modules/proj4/lib/nadgrid.js
/**
 * Resources for details of NTv2 file formats:
 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
 */

var loadedNadgrids = {};

/**
 * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
 * as an ArrayBuffer.
 */
function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid = {header: header, subgrids: subgrids};
  loadedNadgrids[key] = nadgrid;
  return nadgrid;
}

/**
 * Given a proj4 value for nadgrids, return an array of loaded grids
 */
function getNadgrids(nadgrids) {
  // Format details: http://proj.maptools.org/gen_parms.html
  if (nadgrids === undefined) { return null; }
  var grids = nadgrids.split(',');
  return grids.map(parseNadgridString);
}

function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === '@';
  if (optional) {
    value = value.slice(1);
  }
  if (value === 'null') {
    return {name: 'null', mandatory: !optional, grid: null, isNull: true};
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}

function secondsToRadians(seconds) {
  return (seconds / 3600) * Math.PI / 180;
}

function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
  }
  return true;
}

function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
  };
}

function decodeString(view, start, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
}

function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
    // Proj4 operates on radians whereas the coordinates are in seconds in the grid
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}

function mapNodes(nodes) {
  return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
}

function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}

function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/Proj.js









function Proj_Projection(srsCode,callback) {
  if (!(this instanceof Proj_Projection)) {
    return new Proj_Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = parseCode(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var ourProj = Proj_Projection.projections.get(json.projName);
  if(!ourProj){
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = match(Datum_exports, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

  var sphere_ = deriveConstants_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
    nadgrids);

  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
  extend(this, ourProj); // transfer all the methods from the projection

  // copy the 4 things over we calulated in deriveConstants.sphere
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;

  // copy the 3 things we calculated in deriveConstants.eccentricity
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;

  // add in the datum object
  this.datum = datumObj;

  // init the projection
  this.init();

  // legecy callback from back in the day when it went to spatialreference.org
  callback(null, this);

}
Proj_Projection.projections = projections;
Proj_Projection.projections.start();
/* harmony default export */ var Proj = (Proj_Projection);

// CONCATENATED MODULE: ./node_modules/proj4/lib/datumUtils.js


function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
  } else if (source.datum_type === PJD_7PARAM) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn; /*  Earth radius at location  */
  var Sin_Lat; /*  Math.sin(Latitude)  */
  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
  var Cos_Lat; /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > HALF_PI) {
    /* Latitude out of range */
    return { x: Infinity, y: Infinity, z: p.z };
  }

  if (Longitude > Math.PI) {
    Longitude -= (2 * Math.PI);
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: ((Rn * (1 - es)) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */
  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = (genau * genau);
  var maxiter = 30;

  var P; /* distance between semi-minor axis and location */
  var RR; /* distance between center and location */
  var CT; /* sin of geocentric latitude */
  var ST; /* cos of geocentric latitude */
  var RX;
  var RK;
  var RN; /* Earth radius at location */
  var CPHI0; /* cos of start or old geodetic latitude in iterations */
  var SPHI0; /* sin of start or old geodetic latitude in iterations */
  var CPHI; /* cos of searched geodetic latitude */
  var SPHI; /* sin of searched geodetic latitude */
  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied
  var Longitude;
  var Latitude;
  var Height;

  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);

  /*      special cases for latitude and longitude */
  if (P / a < genau) {

    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;

    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }

  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;

  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

    /*  ellipsoidal (geodetic) height */
    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  }
  while (SDPHI * SDPHI > genau2 && iter < maxiter);

  /*      ellipsoidal (geodetic) latitude */
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)


/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
function geocentricToWgs84(p, datum_type, datum_params) {

  if (datum_type === PJD_3PARAM) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2],
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
function geocentricFromWgs84(p, datum_type, datum_params) {

  if (datum_type === PJD_3PARAM) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2],
    };

  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/datum_transform.js




function checkParams(type) {
  return (type === PJD_3PARAM || type === PJD_7PARAM);
}

/* harmony default export */ var datum_transform = (function(source, dest, point) {
  // Short cut if the datums are identical.
  if (compareDatums(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }

  // If this datum requires grid shifts, then apply it to geodetic coordinates.
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return undefined;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }

  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }

  // Do we need to go through geocentric coordinates?
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
    return point;
  }

  // Convert to geocentric coordinates.
  point = geodeticToGeocentric(point, source_es, source_a);
  // Convert between datums
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return undefined;
    }
  }

  return point;
});

function applyGridShift(source, inverse, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log('Grid shift grids not found');
    return -1;
  }
  var input = {x: -point.x, y: point.y};
  var output = {x: Number.NaN, y: Number.NaN};
  var onlyMandatoryGrids = false;
  var attemptedGrids = [];
  for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    onlyMandatoryGrids = grid.mandatory;
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    // skip tables that don't match our point at all
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
      continue;
    }
    output = applySubgridShift(input, inverse, subgrid);
    if (!isNaN(output.x)) {
      break;
    }
  }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '"+
      -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}

function applySubgridShift(pin, inverse, ct) {
  var val = {x: Number.NaN, y: Number.NaN};
  if (isNaN(pin.x)) { return val; }
  var tb = {x: pin.x, y: pin.y};
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}

function nadInterpolate(pin, ct) {
  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
  var val= {x: Number.NaN, y: Number.NaN};
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = (indx.y * ct.lim[0]) + indx.x;
  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx++;
  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx += ct.lim[0];
  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx--;
  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
  return val;
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/adjust_axis.js
/* harmony default export */ var adjust_axis = (function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = 'x';
      } else {
        t = 'y';
      }

    }
    else if (i === 1) {
      v = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = 'y';
      } else {
        t = 'x';
      }
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      out[t] = v;
      break;
    case 'w':
      out[t] = -v;
      break;
    case 'n':
      out[t] = v;
      break;
    case 's':
      out[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        out.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        out.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return out;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/toPoint.js
/* harmony default export */ var toPoint = (function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/checkSanity.js
/* harmony default export */ var checkSanity = (function (point) {
  checkCoord(point.x);
  checkCoord(point.y);
});
function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError('coordinates must be finite numbers');
  }
  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/transform.js







function checkNotWGS(source, dest) {
  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
}

function transform_transform(source, dest, point, enforceAxis) {
  var wgs84;
  if (Array.isArray(point)) {
    point = toPoint(point);
  }
  checkSanity(point);
  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new Proj('WGS84');
    point = transform_transform(source, wgs84, point, enforceAxis);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (enforceAxis && source.axis !== 'enu') {
    point = adjust_axis(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === 'longlat') {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point); // Convert Cartesian to longlat
    if (!point) {
      return;
    }
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else { // else project
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }

  // DGR, 2010/11/12
  if (enforceAxis && dest.axis !== 'enu') {
    return adjust_axis(dest, true, point);
  }

  return point;
}

// CONCATENATED MODULE: ./node_modules/proj4/lib/core.js


var core_wgs84 = Proj('WGS84');

function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform_transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
    if (coords.length > 2) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (typeof transformedArray.z === 'number') {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform_transform(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function (key) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (key === 'x' || key === 'y' || key === 'z') {
          return;
        }
      } else {
        if (key === 'x' || key === 'y') {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}

function checkProj(item) {
  if (item instanceof Proj) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Proj(item);
}

function core_proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = core_wgs84;
    single = true;
  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = core_wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function (coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function (coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
/* harmony default export */ var core = (core_proj4);
// CONCATENATED MODULE: ./node_modules/mgrs/mgrs.js



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var mgrs_A = 65; // A
var I = 73; // I
var O = 79; // O
var mgrs_V = 86; // V
var mgrs_Z = 90; // Z
/* harmony default export */ var mgrs = ({
  forward: mgrs_forward,
  inverse: mgrs_inverse,
  toPoint: mgrs_toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
function mgrs_forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
function mgrs_inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

function mgrs_toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
    snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > mgrs_Z) {
    colInt = colInt - mgrs_Z + mgrs_A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > mgrs_Z) {
    colInt = colInt - mgrs_Z + mgrs_A - 1;
  }

  if (rowInt > mgrs_V) {
    rowInt = rowInt - mgrs_V + mgrs_A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > mgrs_V) {
    rowInt = rowInt - mgrs_V + mgrs_A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > mgrs_Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = mgrs_A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > mgrs_V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = mgrs_A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}

// CONCATENATED MODULE: ./node_modules/proj4/lib/Point.js


function Point_Point(x, y, z) {
  if (!(this instanceof Point_Point)) {
    return new Point_Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point_Point.fromMGRS = function(mgrsStr) {
  return new Point_Point(mgrs_toPoint(mgrsStr));
};
Point_Point.prototype.toMGRS = function(accuracy) {
  return mgrs_forward([this.x, this.y], accuracy);
};
/* harmony default export */ var lib_Point = (Point_Point);

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_enfn.js
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

/* harmony default export */ var pj_enfn = (function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_mlfn.js
/* harmony default export */ var pj_mlfn = (function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_inv_mlfn.js



var MAX_ITER = 20;

/* harmony default export */ var pj_inv_mlfn = (function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tmerc.js
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js









function tmerc_init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
function tmerc_forward(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if ((b - 1) > EPSLN) {
          return (93);
        }
        else {
          y = 0;
        }
      }
      else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

    x = this.a * (this.k0 * al * (1 +
      als / 6 * (1 - t + c +
      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
      this.x0;

    y = this.a * (this.k0 * (ml - this.ml0 +
      sin_phi * delta_lon * al / 2 * (1 +
      als / 12 * (5 - t + 9 * c + 4 * cs +
      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
      this.y0;
  }

  p.x = x;
  p.y = y;

  return p;
}

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
function tmerc_inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if ((g === 0) && (h === 0)) {
      lon = 0;
    }
    else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);

    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;

      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

      lon = adjust_lon(this.long0 + (d * (1 -
        ds / 6 * (1 + 2 * t + c -
        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
    }
    else {
      lat = HALF_PI * common_sign(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var tmerc_names = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
/* harmony default export */ var tmerc = ({
  init: tmerc_init,
  forward: tmerc_forward,
  inverse: tmerc_inverse,
  names: tmerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sinh.js
/* harmony default export */ var sinh = (function(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/hypot.js
/* harmony default export */ var hypot = (function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);

  return a * Math.sqrt(1 + Math.pow(b, 2));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/log1py.js
/* harmony default export */ var log1py = (function(x) {
  var y = 1 + x;
  var z = y - 1;

  return z === 0 ? x : x * Math.log(y) / z;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinhy.js



/* harmony default export */ var asinhy = (function(x) {
  var y = Math.abs(x);
  y = log1py(y * (1 + y / (hypot(1, y) + 1)));

  return x < 0 ? -y : y;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gatg.js
/* harmony default export */ var gatg = (function(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return (B + h * Math.sin(2 * B));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens.js
/* harmony default export */ var clens = (function(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/cosh.js
/* harmony default export */ var cosh = (function(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens_cmplx.js



/* harmony default export */ var clens_cmplx = (function(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;

  return [r * hr - i * hi, r * hi + i * hr];
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/etmerc.js
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js










function etmerc_init() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    // When '+approx' is set, use tmerc instead
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];

  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;

  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);

  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);

  var Z = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
}

function etmerc_forward(p) {
  var Ce = adjust_lon(p.x - this.long0);
  var Cn = p.y;

  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);

  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));

  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];

  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  }
  else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;

  return p;
}

function etmerc_inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);

  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;

  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));

    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  }
  else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var etmerc_names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ var etmerc = ({
  init: etmerc_init,
  forward: etmerc_forward,
  inverse: etmerc_inverse,
  names: etmerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_zone.js


/* harmony default export */ var adjust_zone = (function(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/utm.js


var dependsOn = 'etmerc';



function utm_init() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }
  this.lat0 = 0;
  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}

var utm_names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ var utm = ({
  init: utm_init,
  names: utm_names,
  dependsOn: dependsOn
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/srat.js
/* harmony default export */ var srat = (function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gauss.js

var gauss_MAX_ITER = 20;


function gauss_init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}

function gauss_forward(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}

function gauss_inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = gauss_MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var gauss_names = ["gauss"];
/* harmony default export */ var gauss = ({
  init: gauss_init,
  forward: gauss_forward,
  inverse: gauss_inverse,
  names: gauss_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sterea.js



function sterea_init() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}

function sterea_forward(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}

function sterea_inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
}

var sterea_names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
/* harmony default export */ var sterea = ({
  init: sterea_init,
  forward: sterea_forward,
  inverse: sterea_inverse,
  names: sterea_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/stere.js








function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
}

function stere_init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + common_sign(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}

// Stereographic forward equations--mapping lat,long to x,y
function stere_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
}

//* Stereographic inverse equations--mapping x,y to lat/long
function stere_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

}

var stere_names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ var stere = ({
  init: stere_init,
  forward: stere_forward,
  inverse: stere_inverse,
  names: stere_names,
  ssfn_: ssfn_
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/somerc.js
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */

function somerc_init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}

function somerc_forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}

function somerc_inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}

var somerc_names = ["somerc"];
/* harmony default export */ var somerc = ({
  init: somerc_init,
  forward: somerc_forward,
  inverse: somerc_inverse,
  names: somerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/omerc.js





var TOL = 1e-7;

function isTypeA(P) {
  var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
  
  return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
}


/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
function omerc_init() {  
  var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
    gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
  
  // only Type A uses the no_off or no_uoff property
  // https://github.com/OSGeo/proj.4/issues/104
  this.no_off = isTypeA(this);
  this.no_rot = 'no_rot' in this;
  
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }

  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }

  if (alp) {
    alpha_c = this.alpha;
  }
  
  if (gam) {
    gamma = (this.rectified_grid_angle * D2R);
  }
  
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
        Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
        Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  
  var one_es = 1.0 - this.es;
  com = Math.sqrt(one_es);
  
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D -1;
    
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    
    this.E = F += D;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }
  
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    
    if (con < -Math.pi) {
      lam2 -=TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    
    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }
  
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  AB = this.A * this.B;
  
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
    
    if (this.lat0 < 0) {
      this.u_0 = - this.u_0;
    }  
  }
    
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}


/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
function omerc_forward(p) {
  var coords = {};
  var S, T, U, V, W, temp, u, v;
  p.x = p.x - this.lam0;
  
  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
    
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V = Math.sin(this.B * p.x);
    U = (S * this.singam - V * this.cosgam) / T;
        
    if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
      throw new Error();
    }
    
    v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
    temp = Math.cos(this.B * p.x);
    
    if (Math.abs(temp) < TOL) {
      u = this.A * p.x;
    } else {
      u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
    }    
  } else {
    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p.y;
  }
     
  if (this.no_rot) {
    coords.x = u;
    coords.y = v;
  } else {
    u -= this.u_0;
    coords.x = v * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v * this.sinrot;
  }
  
  coords.x = (this.a * coords.x + this.x0);
  coords.y = (this.a * coords.y + this.y0);
  
  return coords;
}

function omerc_inverse(p) {
  var u, v, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  
  p.x = (p.x - this.x0) * (1.0 / this.a);
  p.y = (p.y - this.y0) * (1.0 / this.a);

  if (this.no_rot) {
    v = p.y;
    u = p.x;
  } else {
    v = p.x * this.cosrot - p.y * this.sinrot;
    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  
  Qp = Math.exp(-this.BrA * v);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
    
    if (coords.y === Infinity) {
      throw new Error();
    }
        
    coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
  }
  
  coords.x += this.lam0;
  
  return coords;
}

var omerc_names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
/* harmony default export */ var omerc = ({
  init: omerc_init,
  forward: omerc_forward,
  inverse: omerc_inverse,
  names: omerc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/lcc.js






function lcc_init() {
  
  //double lat0;                    /* the reference latitude               */
  //double long0;                   /* the reference longitude              */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */
  
  //the above value can be set with proj4.defs
  //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);

  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}

// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function lcc_forward(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = common_sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
}

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function lcc_inverse(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
}

var lcc_names = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc"
];

/* harmony default export */ var lcc = ({
  init: lcc_init,
  forward: lcc_forward,
  inverse: lcc_inverse,
  names: lcc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/krovak.js


function krovak_init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
function krovak_forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
}

/* calculate lat/lon from xy */
function krovak_inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
}

var krovak_names = ["Krovak", "krovak"];
/* harmony default export */ var krovak = ({
  init: krovak_init,
  forward: krovak_forward,
  inverse: krovak_inverse,
  names: krovak_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/mlfn.js
/* harmony default export */ var mlfn = (function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e0fn.js
/* harmony default export */ var e0fn = (function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e1fn.js
/* harmony default export */ var e1fn = (function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e2fn.js
/* harmony default export */ var e2fn = (function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e3fn.js
/* harmony default export */ var e3fn = (function(x) {
  return (x * x * x * (35 / 3072));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gN.js
/* harmony default export */ var gN = (function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lat.js



/* harmony default export */ var adjust_lat = (function(x) {
  return (Math.abs(x) < HALF_PI) ? x : (x - (common_sign(x) * Math.PI));
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/imlfn.js
/* harmony default export */ var imlfn = (function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cass.js











function cass_init() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}

/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function cass_forward(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function cass_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;

}

var cass_names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ var cass = ({
  init: cass_init,
  forward: cass_forward,
  inverse: cass_inverse,
  names: cass_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/qsfnz.js
/* harmony default export */ var qsfnz = (function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/laea.js






/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;

var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;

/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
function laea_init() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function laea_forward(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = HALF_PI + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - HALF_PI;
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function laea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = HALF_PI - phi;
      break;
    case this.S_POLE:
      phi -= HALF_PI;
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
}

/* determine latitude from authalic latitude */
var P00 = 0.33333333333333333333;

var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
}

var laea_names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ var laea = ({
  init: laea_init,
  forward: laea_forward,
  inverse: laea_inverse,
  names: laea_names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinz.js
/* harmony default export */ var asinz = (function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aea.js






function aea_init() {

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
function aea_forward(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function aea_inverse(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}

var aea_names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ var aea = ({
  init: aea_init,
  forward: aea_forward,
  inverse: aea_inverse,
  names: aea_names,
  phi1z: phi1z
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gnom.js




/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
function gnom_init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}

/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function gnom_forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
}

function gnom_inverse(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var gnom_names = ["gnom"];
/* harmony default export */ var gnom = ({
  init: gnom_init,
  forward: gnom_forward,
  inverse: gnom_inverse,
  names: gnom_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/common/iqsfnz.js


/* harmony default export */ var iqsfnz = (function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * HALF_PI);
    }
    else {
      return HALF_PI;
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cea.js





/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
function cea_init() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}

/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function cea_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function cea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var cea_names = ["cea"];
/* harmony default export */ var cea = ({
  init: cea_init,
  forward: cea_forward,
  inverse: cea_inverse,
  names: cea_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqc.js



function eqc_init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function eqc_forward(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function eqc_inverse(p) {

  var x = p.x;
  var y = p.y;

  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
}

var eqc_names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ var eqc = ({
  init: eqc_init,
  forward: eqc_forward,
  inverse: eqc_inverse,
  names: eqc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/poly.js










var poly_MAX_ITER = 20;

function poly_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}

/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function poly_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function poly_inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = poly_MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = poly_MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var poly_names = ["Polyconic", "poly"];
/* harmony default export */ var poly = ({
  init: poly_init,
  forward: poly_forward,
  inverse: poly_inverse,
  names: poly_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/nzmg.js


/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
var iterations = 1;

function nzmg_init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
function nzmg_forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
}

/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
function nzmg_inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
}

var nzmg_names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ var nzmg = ({
  init: nzmg_init,
  forward: nzmg_forward,
  inverse: nzmg_inverse,
  names: nzmg_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/mill.js


/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
function mill_init() {
  //no-op
}

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function mill_forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
}

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function mill_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
}

var mill_names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ var mill = ({
  init: mill_init,
  forward: mill_forward,
  inverse: mill_inverse,
  names: mill_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sinu.js



var sinu_MAX_ITER = 20;







function sinu_init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

}

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
function sinu_forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = sinu_MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}

function sinu_inverse(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  }
  else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    }
    else if ((s - EPSLN) < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var sinu_names = ["Sinusoidal", "sinu"];
/* harmony default export */ var sinu = ({
  init: sinu_init,
  forward: sinu_forward,
  inverse: sinu_inverse,
  names: sinu_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/moll.js

function moll_init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
function moll_forward(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function moll_inverse(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
}

var moll_names = ["Mollweide", "moll"];
/* harmony default export */ var moll = ({
  init: moll_init,
  forward: moll_forward,
  inverse: moll_inverse,
  names: moll_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqdc.js











function eqdc_init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}

/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
function eqdc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}

/* Inverse equations
  -----------------*/
function eqdc_inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

}

var eqdc_names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ var eqdc = ({
  init: eqdc_init,
  forward: eqdc_forward,
  inverse: eqdc_inverse,
  names: eqdc_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/vandg.js






/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
function vandg_init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}

function vandg_forward(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
function vandg_inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  }
  else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var vandg_names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ var vandg = ({
  init: vandg_init,
  forward: vandg_forward,
  inverse: vandg_inverse,
  names: vandg_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aeqd.js














function aeqd_init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}

function aeqd_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


}

function aeqd_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * HALF_PI * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    }
    else {
      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

}

var aeqd_names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ var aeqd = ({
  init: aeqd_init,
  forward: aeqd_forward,
  inverse: aeqd_inverse,
  names: aeqd_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/ortho.js




function ortho_init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}

/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function ortho_forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}

function ortho_inverse(p) {
  var rh; /* height above ellipsoid      */
  var z; /* angle          */
  var sinz, cosz; /* sin of z and cos of z      */
  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz(rh / this.a);

  sinz = Math.sin(z);
  cosz = Math.cos(z);

  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
    }
    else {
      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}

var ortho_names = ["ortho"];
/* harmony default export */ var ortho = ({
  init: ortho_init,
  forward: ortho_forward,
  inverse: ortho_inverse,
  names: ortho_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/qsc.js
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c



/* constants */
var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
};

var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
};

function qsc_init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";

  /* Determine the cube face from the center of projection. */
  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }

  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}

// QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function qsc_forward(p) {
  var xy = {x: 0, y: 0};
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */
  var area = {value: 0};

  // move lon according to projection's lon
  p.x -= this.long0;

  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */
  if (this.es !== 0) {//if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }

  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */
  lon = p.x; //lon = lp.lam;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = (lon > 0.0 ? lon - SPI : lon + SPI);
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }

  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

  /* Apply the result to the real area. */
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }

  /* Now compute x, y from mu and nu */
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;

  p.x = xy.x;
  p.y = xy.y;
  return p;
}

// QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function qsc_inverse(p) {
  var lp = {lam: 0, phi: 0};
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {value: 0};

  /* de-offset */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = (mu < 0.0 ? mu + SPI : mu - SPI);
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }

  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
  t = (SPI / 12) * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }

  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
    }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }

  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = (lp.phi < 0 ? 1 : 0);
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}

/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}

/* Helper function: shift the longitude. */
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}

var qsc_names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ var qsc = ({
  init: qsc_init,
  forward: qsc_forward,
  inverse: qsc_inverse,
  names: qsc_names
});


// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/robin.js
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039




var COEFS_X = [
    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
    [0.5722, -0.00906601, 0.000182, 6.24051e-06],
    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
];

var COEFS_Y = [
    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
    [0.9761, 0.00616527, -0.000256, -4.2106e-06],
    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
];

var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D/5; // rad to 5-degree interval
var RC1 = 1/C1;
var NODES = 18;

var poly3_val = function(coefs, x) {
    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};

var poly3_der = function(coefs, x) {
    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};

function newton_rapshon(f_df, start, max_err, iters) {
    var x = start;
    for (; iters; --iters) {
        var upd = f_df(x);
        x -= upd;
        if (Math.abs(upd) < max_err) {
            break;
        }
    }
    return x;
}

function robin_init() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.long0 = this.long0 || 0;
    this.es = 0;
    this.title = this.title || "Robinson";
}

function robin_forward(ll) {
    var lon = adjust_lon(ll.x - this.long0);

    var dphi = Math.abs(ll.y);
    var i = Math.floor(dphi * C1);
    if (i < 0) {
        i = 0;
    } else if (i >= NODES) {
        i = NODES - 1;
    }
    dphi = R2D * (dphi - RC1 * i);
    var xy = {
        x: poly3_val(COEFS_X[i], dphi) * lon,
        y: poly3_val(COEFS_Y[i], dphi)
    };
    if (ll.y < 0) {
        xy.y = -xy.y;
    }

    xy.x = xy.x * this.a * FXC + this.x0;
    xy.y = xy.y * this.a * FYC + this.y0;
    return xy;
}

function robin_inverse(xy) {
    var ll = {
        x: (xy.x - this.x0) / (this.a * FXC),
        y: Math.abs(xy.y - this.y0) / (this.a * FYC)
    };

    if (ll.y >= 1) { // pathologic case
        ll.x /= COEFS_X[NODES][0];
        ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
    } else {
        // find table interval
        var i = Math.floor(ll.y * NODES);
        if (i < 0) {
            i = 0;
        } else if (i >= NODES) {
            i = NODES - 1;
        }
        for (;;) {
            if (COEFS_Y[i][0] > ll.y) {
                --i;
            } else if (COEFS_Y[i+1][0] <= ll.y) {
                ++i;
            } else {
                break;
            }
        }
        // linear interpolation in 5 degree interval
        var coefs = COEFS_Y[i];
        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
        // find t so that poly3_val(coefs, t) = ll.y
        t = newton_rapshon(function(x) {
            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
        }, t, EPSLN, 100);

        ll.x /= poly3_val(COEFS_X[i], t);
        ll.y = (5 * i + t) * D2R;
        if (xy.y < 0) {
            ll.y = -ll.y;
        }
    }

    ll.x = adjust_lon(ll.x + this.long0);
    return ll;
}

var robin_names = ["Robinson", "robin"];
/* harmony default export */ var robin = ({
  init: robin_init,
  forward: robin_forward,
  inverse: robin_inverse,
  names: robin_names
});

// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geocent.js


function geocent_init() {
    this.name = 'geocent';

}

function geocent_forward(p) {
    var point = geodeticToGeocentric(p, this.es, this.a);
    return point;
}

function geocent_inverse(p) {
    var point = geocentricToGeodetic(p, this.es, this.a, this.b);
    return point;
}

var geocent_names = ["Geocentric", 'geocentric', "geocent", "Geocent"];
/* harmony default export */ var geocent = ({
    init: geocent_init,
    forward: geocent_forward,
    inverse: geocent_inverse,
    names: geocent_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tpers.js

var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};




var tpers_params = {
  h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
  azi:   { def: 0, num: true, degrees: true }, // default is North
  tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
  long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
  lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
};

function tpers_init() {
  Object.keys(tpers_params).forEach(function (p) {
    if (typeof this[p] === "undefined") {
      this[p] = tpers_params[p].def;
    } else if (tpers_params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (tpers_params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (tpers_params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }.bind(this));

  if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }

  this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;

  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}

function tpers_forward(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);

  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }

  // Tilt 
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;

  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}

function tpers_inverse(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = { x: p.x, y: p.y };

  // Un-Tilt
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;

  var rh = hypot(p.x, p.y);
  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p.x, p.y);
  }

  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}

var tpers_names = ["Tilted_Perspective", "tpers"];
/* harmony default export */ var tpers = ({
  init: tpers_init,
  forward: tpers_forward,
  inverse: tpers_inverse,
  names: tpers_names
});

// CONCATENATED MODULE: ./node_modules/proj4/projs.js




























/* harmony default export */ var proj4_projs = (function(proj4){
  proj4.Proj.projections.add(tmerc);
  proj4.Proj.projections.add(etmerc);
  proj4.Proj.projections.add(utm);
  proj4.Proj.projections.add(sterea);
  proj4.Proj.projections.add(stere);
  proj4.Proj.projections.add(somerc);
  proj4.Proj.projections.add(omerc);
  proj4.Proj.projections.add(lcc);
  proj4.Proj.projections.add(krovak);
  proj4.Proj.projections.add(cass);
  proj4.Proj.projections.add(laea);
  proj4.Proj.projections.add(aea);
  proj4.Proj.projections.add(gnom);
  proj4.Proj.projections.add(cea);
  proj4.Proj.projections.add(eqc);
  proj4.Proj.projections.add(poly);
  proj4.Proj.projections.add(nzmg);
  proj4.Proj.projections.add(mill);
  proj4.Proj.projections.add(sinu);
  proj4.Proj.projections.add(moll);
  proj4.Proj.projections.add(eqdc);
  proj4.Proj.projections.add(vandg);
  proj4.Proj.projections.add(aeqd);
  proj4.Proj.projections.add(ortho);
  proj4.Proj.projections.add(qsc);
  proj4.Proj.projections.add(robin);
  proj4.Proj.projections.add(geocent);
  proj4.Proj.projections.add(tpers);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/index.js










core.defaultDatum = 'WGS84'; //default datum
core.Proj = Proj;
core.WGS84 = new core.Proj('WGS84');
core.Point = lib_Point;
core.toPoint = toPoint;
core.defs = lib_defs;
core.nadgrid = nadgrid;
core.transform = transform_transform;
core.mgrs = mgrs;
core.version = '__VERSION__';
proj4_projs(core);
/* harmony default export */ var lib = (core);

// CONCATENATED MODULE: ./src/index.js












// "ol": "^6.5.0",
// import 'ol/ol.css'





















/* harmony default export */ var src_0 = ({
  data: function data() {
    return {
      maps: {},
      layers: {},
      overlays: {},
      interactions: {},
      customStyles: custom_styles,
      baseSources: {
        standardRoadMap: {
          cName: 'Google標準地圖',
          source: new source_XYZ({
            url: 'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
            crossOrigin: 'anonymous'
          })
        },
        somehowAlteredRoadMap: {
          cName: 'Google標準地圖2',
          source: new source_XYZ({
            url: 'https://mt1.google.com/vt/lyrs=r&x={x}&y={y}&z={z}',
            crossOrigin: 'anonymous'
          })
        },
        hybrid: {
          cName: 'Google衛星地圖',
          source: new source_XYZ({
            url: 'https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}',
            crossOrigin: 'anonymous'
          })
        },
        satelliteOnly: {
          cName: 'Google純衛星地圖',
          source: new source_XYZ({
            url: 'https://mt1.google.com/vt/lyrs=s&hl=pl&&x={x}&y={y}&z={z}',
            crossOrigin: 'anonymous'
          })
        },
        terrain: {
          cName: 'Google等高線地圖',
          source: new source_XYZ({
            url: 'https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}',
            crossOrigin: 'anonymous'
          })
        },
        terrainOnly: {
          cName: 'Google純等高線地圖',
          source: new source_XYZ({
            url: 'https://mt1.google.com/vt/lyrs=t&x={x}&y={y}&z={z}',
            crossOrigin: 'anonymous'
          })
        },
        roadsOnly: {
          cName: 'Google道路地圖',
          source: new source_XYZ({
            url: 'https://mt1.google.com/vt/lyrs=h&x={x}&y={y}&z={z}',
            crossOrigin: 'anonymous'
          })
        },
        osm: {
          cName: 'OpenStreetMap開放街圖地圖',
          source: new source_OSM()
        },
        TGOSMAP_W: {
          cName: 'TGOS電子地圖',
          source: new source_XYZ({
            url: 'https://gis.sinica.edu.tw/tgos/file-exists.php?img=TGOSMAP_W-png-{z}-{x}-{y}',
            crossOrigin: 'anonymous'
          })
        },
        NLSCMAP_W: {
          cName: '通用版電子地圖',
          source: new source_XYZ({
            url: 'https://gis.sinica.edu.tw/tgos/file-exists.php?img=NLSCMAP_W-png-{z}-{x}-{y}',
            crossOrigin: 'anonymous'
          })
        },
        F2IMAGE_W: {
          cName: '福衛二號影像',
          source: new source_XYZ({
            url: 'https://gis.sinica.edu.tw/tgos/file-exists.php?img=F2IMAGE_W-png-{z}-{x}-{y}',
            crossOrigin: 'anonymous'
          })
        },
        ROADMAP_W: {
          cName: '福衛二號混合圖',
          source: new source_XYZ({
            url: 'https://gis.sinica.edu.tw/tgos/file-exists.php?img=ROADMAP_W-png-{z}-{x}-{y}',
            crossOrigin: 'anonymous'
          })
        },
        HILLSHADEMIX_W: {
          cName: '地形暈渲混合圖',
          source: new source_XYZ({
            url: 'https://gis.sinica.edu.tw/tgos/file-exists.php?img=HILLSHADEMIX_W-png-{z}-{x}-{y}',
            crossOrigin: 'anonymous'
          })
        },
        HILLSHADE_W: {
          cName: '地形暈渲圖',
          source: new source_XYZ({
            url: 'https://gis.sinica.edu.tw/tgos/file-exists.php?img=HILLSHADE_W-png-{z}-{x}-{y}',
            crossOrigin: 'anonymous'
          })
        },
        MOTCMAP_W: {
          cName: '路網數值圖',
          source: new source_XYZ({
            url: 'https://gis.sinica.edu.tw/tgos/file-exists.php?img=MOTCMAP_W-png-{z}-{x}-{y}',
            crossOrigin: 'anonymous'
          })
        }
      }
    };
  },
  methods: {
    // map
    initMap: function initMap(targetId, center, zoom, baseSourceId) {
      var tempZoom = 13;

      if (zoom !== undefined && zoom != null && zoom != '' && zoom != 0) {
        tempZoom = zoom;
      }

      var tempBaseSourceId = 'standardRoadMap';

      if (baseSourceId !== undefined && baseSourceId != null && baseSourceId != '' && this.baseSources[baseSourceId] !== undefined) {
        tempBaseSourceId = baseSourceId;
      }

      this.layers[targetId] = {
        baseLayer: new Tile["a" /* default */]({
          name: 'baseLayer',
          source: this.baseSources[tempBaseSourceId].source
        })
      };
      this.maps[targetId] = new Map["a" /* default */]({
        target: targetId,
        layers: [this.layers[targetId]['baseLayer']],
        view: new View["a" /* default */]({
          center: center,
          zoom: tempZoom
        })
      });
    },
    initImageMap: function initImageMap(targetId, url, maxZoom, doFunc) {
      var currentThis = this;
      var img = new Image();

      img.onload = function () {
        var dom = document.getElementById(targetId);
        var imgWidth = this.width;
        var imgHeight = this.height;
        var domWidth = dom.clientWidth;
        var domHeight = dom.clientHeight;
        var extent = [0, 0, imgWidth, imgHeight];
        var viewExtent = currentThis.getImageViewExtentByImgWidthAndImgHeightAndDomWidthAndDomHeight(imgWidth, imgHeight, domWidth, domHeight);
        var projection = new ol_proj["b" /* Projection */]({
          code: 'xkcd-image',
          units: 'pixels',
          extent: extent
        });
        currentThis.layers[targetId] = {
          baseImageLayer: new layer_Image({
            name: 'baseImageLayer',
            source: new ImageStatic({
              url: url,
              projection: projection,
              imageExtent: extent
            })
          })
        };
        currentThis.maps[targetId] = new Map["a" /* default */]({
          target: targetId,
          layers: [currentThis.layers[targetId]['baseImageLayer']],
          view: new View["a" /* default */]({
            projection: projection,
            center: Object(ol_extent["w" /* getCenter */])(extent),
            extent: viewExtent,
            zoom: 1,
            maxZoom: maxZoom
          })
        });
        doFunc();
      };

      img.src = url;
    },
    reloadMap: function reloadMap(targetId) {
      if (this.maps[targetId] !== undefined) {
        this.maps[targetId].updateSize();
      }

      if (this.overlays[targetId] !== undefined) {
        Object.values(this.overlays[targetId]).forEach(function (overlay) {
          if (overlay.overlayObj !== undefined) {
            overlay.overlayObj.setPosition(undefined);
          }
        });
      }
    },
    reloadImageMap: function reloadImageMap(targetId, url) {
      if (this.maps[targetId] !== undefined) {
        var currentThis = this;
        var img = new Image();

        img.onload = function () {
          var dom = document.getElementById(targetId);
          var imgWidth = this.width;
          var imgHeight = this.height;
          var domWidth = dom.clientWidth;
          var domHeight = dom.clientHeight;
          var viewExtent = currentThis.getImageViewExtentByImgWidthAndImgHeightAndDomWidthAndDomHeight(imgWidth, imgHeight, domWidth, domHeight);
          currentThis.setViewExtent(targetId, viewExtent);
          currentThis.maps[targetId].updateSize();

          if (currentThis.overlays[targetId] !== undefined) {
            Object.values(currentThis.overlays[targetId]).forEach(function (overlay) {
              if (overlay.overlayObj !== undefined) {
                overlay.overlayObj.setPosition(undefined);
              }
            });
          }
        };

        img.src = url;
      }
    },
    checkMapIsExist: function checkMapIsExist(targetId) {
      if (this.maps[targetId] !== undefined && this.maps[targetId] != null) {
        return true;
      } else {
        return false;
      }
    },
    removeLayerByName: function removeLayerByName(targetId, layerName) {
      var layer = this.getLayerByLayerName(targetId, layerName);
      this.maps[targetId].removeLayer(layer);
    },
    initOriginalTGOSMAP_W: function initOriginalTGOSMAP_W(doFunc) {
      var _this = this;

      var TGAppId = 'GcAQiLwfxjna+6atuuwkDAZK3UoBqzp3GVQDPTapB4RjZFE+UXVY0w==';
      var TGAppKey = 'cGEErDNy5yN/1fQ0vyTOZrghjE+jIU6urygRnCxIwXnWBrrSF40esjObVwN/bD6RQxTXxnnI1//CGfqZtkmNJsdq4ZJ/0YJIi/yXphq/b1DFZKMdCTWfoVJXN9mgZEwJ/0enwsSo1mFKWy2kcM5+g1E1zFIi7k1LU4ldZaMiEBoFTtczytpZbKGT6UYuYZBh4+Di+xD2QWg12M0dCIRPeFPS0bk32E4RcwwMSk4PjKAvSjdNikzrXREJyjQkUQPTRLD/xu218gEFND1vOFJ94TWpy/eOh9nPVBRth2AeunhT+fSOiyW2C0+uzcWVRny+H+/PJ/c5VoL1pNuakQEPc4s/OmZs1ln0C4/7l+yNiGESSTGSNhd+173uI2/qdCcWvr2PkqpInxUKYoeVtI2eQujYCsj5jfcodKmZ8O/TQIU9B929h7twr1+SiA0ZTpvXBG6xPYQzeSEKyqpHNgZWUFzwASHFAXLcs7LTp8k3RkaVnb8pkwkrvQ==';
      var key_ = new TGAgent_OL.TGKey(TGAppId, TGAppKey);
      var url_ = TGAgent_OL.getTileAgentPath(TGAgent_OL.TGMapTileId.TGOSMAP, TGAgent_OL.CoordSys.EPSG3857);
      var tileUrl = url_ + '/GetCacheImage?version=1&L=0&S={z}&X={x}&Y={y}&APPID=' + key_.getAppID() + '&APIKEY=' + key_.getApiKey();
      var extent_ = [];
      var resolution_length_;
      fetch(url_ + '/GetCacheConfig?FORMAT=JSON').then(function (res) {
        return res.text();
      }).then(function (text) {
        var temp = text.replace('var result =', '');

        if (temp[temp.length - 1] == ';') {
          temp = temp.substring(0, temp.length - 1);
        }

        var tileGrid;
        var resolutions = [];
        var tileDef = dist_default.a.parse(temp);
        var pNodeRes = tileDef.Infomation;

        if (pNodeRes) {
          var dCLeft = parseFloat(pNodeRes.CornerLeft);
          var dCLower = parseFloat(pNodeRes.CornerLower);
          var ImgWidth = parseInt(pNodeRes.TileWidth);
          var ImgHeight = parseInt(pNodeRes.TileHeight);
          var pEnv = pNodeRes.Envelope;
          var dCacheLeft = parseFloat(pEnv.Left);
          var dCacheTop = parseFloat(pEnv.Top);
          var dCacheRight = parseFloat(pEnv.Right);
          var dCacheBottom = parseFloat(pEnv.Bottom);
          var pSclss = pNodeRes.Scales;
          var pScls = pSclss.Scale;

          if (pScls) {
            if (pScls.length > 0) {
              for (var i = 0; i < pScls.length; i++) {
                var pScl = pScls[i];
                var fac = parseFloat(pScl.Factor);
                resolutions.push(fac);
              }
            }

            resolution_length_ = resolutions.length;
          }

          extent_ = [dCacheLeft, dCacheBottom, dCacheRight, dCacheTop];
          tileGrid = new ol_tilegrid["a" /* createXYZ */]({
            tileSize: [ImgWidth, ImgHeight],
            origin: [dCLeft, dCLower],
            resolutions: resolutions
          });
        }

        return tileGrid;
      }).then(function (tileGrid) {
        _this.baseSources['TGOSMAP_W2'] = {
          cName: 'TGOS電子地圖2',
          source: new source_XYZ({
            tileGrid: tileGrid,
            tileUrlFunction: function tileUrlFunction(tileCoord) {
              var z = resolution_length_ - tileCoord[0] - 1;
              var x = tileCoord[1];
              var y = -tileCoord[2] - 1;
              var s = tileUrl.replace('{z}', z.toString()).replace('{x}', x.toString()).replace('{y}', y.toString());
              return s;
            },
            crossOrigin: 'anonymous'
          })
        };
        doFunc();
      }).catch(function (err) {
        console.log(err);
      });
    },
    // control
    setFullScreenControl: function setFullScreenControl(targetId) {
      this.maps[targetId].addControl(new FullScreen["a" /* default */]({
        source: 'wrapMap'
      }));
    },
    // view
    getViewByMapId: function getViewByMapId(targetId) {
      return this.maps[targetId].getView();
    },
    getViewCenter: function getViewCenter(targetId) {
      return this.maps[targetId].getView().getCenter();
    },
    setViewCenter: function setViewCenter(targetId, center) {
      var currentZoomNum = this.maps[targetId].getView().getZoom();
      this.maps[targetId].getView().fit(new Point["a" /* default */](center), {
        maxZoom: currentZoomNum,
        duration: 300
      });
    },
    setCenterBySource: function setCenterBySource(targetId, source) {
      var tempSize = this.maps[targetId].getSize();
      tempSize = [tempSize[0] * 0.4, tempSize[1] * 0.1];
      this.maps[targetId].getView().fit(source.getExtent(), {
        size: tempSize,
        duration: 1000
      });
    },
    setViewZoom: function setViewZoom(targetId, zoomNum) {
      this.maps[targetId].getView().setZoom(zoomNum);
    },
    setViewExtent: function setViewExtent(targetId, viewExtent) {
      if (this.maps[targetId] !== undefined) {
        var oldView = this.maps[targetId].getView();
        this.maps[targetId].setView(new View["a" /* default */]({
          projection: oldView.getProjection(),
          center: oldView.getCenter(),
          extent: viewExtent,
          zoom: 1,
          maxZoom: oldView.getMaxZoom()
        }));
      }
    },
    setViewMaxZoom: function setViewMaxZoom(targetId, zoomNum) {
      this.maps[targetId].getView().setMaxZoom(zoomNum);
    },
    getUnit: function getUnit(targetId) {
      return this.maps[targetId].getView().getProjection().getUnits();
    },
    // layer
    initVectorLayer: function initVectorLayer(targetId, layerName, source) {
      this.layers[targetId][layerName] = new Vector["a" /* default */]({
        name: layerName,
        source: source,
        style: this.customStyleFunction
      });
      this.setLayerByLayerName(targetId, layerName);
    },
    setLayerByLayerName: function setLayerByLayerName(targetId, layerName) {
      this.maps[targetId].addLayer(this.layers[targetId][layerName]);
    },
    setImageLayerByLayerName: function setImageLayerByLayerName(targetId, layerName, url, point1, point2) {
      var img = new Image();
      img.src = url;
      var currentThis = this;

      img.onload = function () {
        if (currentThis.layers[targetId][layerName] !== undefined) {
          var source = new ImageStatic({
            url: url,
            imageExtent: [point1[0], point1[1], point2[0], point2[1]],
            imageSize: [img.width, img.height],
            projection: currentThis.maps[targetId].getView().getProjection()
          });
          currentThis.layers[targetId][layerName].setSource(source);
        } else {
          currentThis.layers[targetId][layerName] = new layer_Image({
            name: layerName,
            source: new ImageStatic({
              url: url,
              imageExtent: [point1[0], point1[1], point2[0], point2[1]],
              imageSize: [img.width, img.height],
              projection: currentThis.maps[targetId].getView().getProjection()
            })
          });
          currentThis.setLayerByLayerName(targetId, layerName);
        }
      };
    },
    getAllLayer: function getAllLayer(targetId) {
      return this.maps[targetId].getLayers();
    },
    getLayerByLayerName: function getLayerByLayerName(targetId, layerName) {
      return this.layers[targetId][layerName];
    },
    setLayerVisibleByLayerName: function setLayerVisibleByLayerName(targetId, layerName, visible) {
      if (this.layers[targetId][layerName] != undefined) {
        this.layers[targetId][layerName].setVisible(visible);
      }
    },
    checkLayerIsVisible: function checkLayerIsVisible(targetId, layerName) {
      if (this.checkLayerIsExist(targetId, layerName)) {
        return this.layers[targetId][layerName].getVisible();
      }
    },
    checkLayerIsExist: function checkLayerIsExist(targetId, layerName) {
      if (this.layers[targetId] !== undefined && this.layers[targetId] != null && this.layers[targetId][layerName] !== undefined && this.layers[targetId][layerName] !== null) {
        return true;
      } else {
        return false;
      }
    },
    setLayerZindexByLayerName: function setLayerZindexByLayerName(targetId, layerName, zindex) {
      this.layers[targetId][layerName].setZIndex(zindex);
    },
    removeLayerByLayerName: function removeLayerByLayerName(targetId, layerName) {
      this.maps[targetId].removeLayer(this.layers[targetId][layerName]);
    },
    // overlay
    getOverlayByOverlayName: function getOverlayByOverlayName(targetId, overlayName) {
      return this.overlays[targetId][overlayName].overlayObj;
    },
    setOverlayMap: function setOverlayMap(targetId, overlayName, elementId) {
      if (!this.overlays[targetId]) {
        this.overlays[targetId] = {};
      }

      this.overlays[targetId][overlayName] = {
        elementId: elementId,
        overlayObj: new ol_Overlay({
          id: elementId,
          element: document.getElementById(elementId),
          positioning: 'bottom-center',
          stopEvent: true,
          offset: [0, -10]
        })
      };
      this.maps[targetId].addOverlay(this.overlays[targetId][overlayName].overlayObj);
    },
    getOverlayPosition: function getOverlayPosition(targetId, overlayName) {
      if (this.overlays[targetId] !== undefined && this.overlays[targetId][overlayName] !== undefined) {
        return this.getOverlayByOverlayName(targetId, overlayName).getPosition();
      } else {
        return null;
      }
    },
    setOverlayPositioning: function setOverlayPositioning(targetId, overlayName, positioning) {
      this.getOverlayByOverlayName(targetId, overlayName).setPositioning(positioning);
    },
    setOverlayOffset: function setOverlayOffset(targetId, overlayName, offset) {
      this.getOverlayByOverlayName(targetId, overlayName).setOffset(offset);
    },
    setOverlayPosition: function setOverlayPosition(targetId, overlayName, position) {
      this.getOverlayByOverlayName(targetId, overlayName).setPosition(position);
    },
    removeOverlayByOverlayName: function removeOverlayByOverlayName(targetId, overlayName) {
      this.maps[targetId].removeOverlay(overlayName);
    },
    // source
    initVectorSource: function initVectorSource() {
      return new source_Vector["a" /* default */]();
    },
    getBaseSourceByBaseSourceId: function getBaseSourceByBaseSourceId(baseSourceId) {
      return this.baseSources[baseSourceId];
    },
    getSourceByLayerName: function getSourceByLayerName(targetId, layerName) {
      return this.layers[targetId][layerName].getSource();
    },
    setBaseSourceByBaseSourceId: function setBaseSourceByBaseSourceId(targetId, baseSourceId) {
      var tempBaseSource = this.getBaseSourceByBaseSourceId(baseSourceId);

      if (tempBaseSource !== undefined && tempBaseSource != null && tempBaseSource.source !== undefined) {
        this.layers[targetId]['baseLayer'].setSource(tempBaseSource.source);
      } else {
        console.warn('no base source');
      }
    },
    setBaseImageSourceByUrl: function setBaseImageSourceByUrl(targetId, url, maxZoom) {
      var currentThis = this;
      var img = new Image();

      img.onload = function () {
        var dom = document.getElementById(targetId);
        var imgWidth = this.width;
        var imgHeight = this.height;
        var domWidth = dom.clientWidth;
        var domHeight = dom.clientHeight;
        var extent = [0, 0, imgWidth, imgHeight];
        var viewExtent = currentThis.getImageViewExtentByImgWidthAndImgHeightAndDomWidthAndDomHeight(imgWidth, imgHeight, domWidth, domHeight);
        var projection = new ol_proj["b" /* Projection */]({
          code: 'xkcd-image',
          units: 'pixels',
          extent: extent
        });
        currentThis.layers[targetId]['baseImageLayer'].setSource(new ImageStatic({
          url: url,
          projection: projection,
          imageExtent: extent
        }));
        currentThis.maps[targetId].setView(new View["a" /* default */]({
          projection: projection,
          center: Object(ol_extent["w" /* getCenter */])(extent),
          extent: viewExtent,
          zoom: 1,
          maxZoom: maxZoom
        }));
      };

      img.src = url;
    },
    // networklinks
    getNetworkLinksByKml: function getNetworkLinksByKml(kmlString) {
      return new format_KML().readNetworkLinks(kmlString.trim());
    },
    // feature
    getFeaturesByGeoJsonObject: function getFeaturesByGeoJsonObject(geoJsonObject) {
      return new GeoJSON["a" /* default */]().readFeatures(geoJsonObject, {
        dataProjection: 'EPSG:4326',
        featureProjection: 'EPSG:3857'
      });
    },
    getFeaturesByKml: function getFeaturesByKml(kmlString) {
      return new format_KML().readFeatures(kmlString.trim(), {
        dataProjection: 'EPSG:4326',
        featureProjection: 'EPSG:3857'
      });
    },
    getOriginalFeaturesByKml: function getOriginalFeaturesByKml(kmlString) {
      return new format_KML().readFeatures(kmlString.trim());
    },
    // export Kml
    getKml: function getKml(targetId, LayerName, fileName) {
      var kml = new format_KML().writeFeatures(this.getAllFeatureByLayerName(targetId, LayerName), {
        featureProjection: this.maps[targetId].getView().getProjection()
      });
      this.handleDownloadFile(fileName, kml);
    },
    getKmlByFeatures: function getKmlByFeatures(targetId, features, fileName) {
      var kml = new format_KML().writeFeatures(features, {
        featureProjection: this.maps[targetId].getView().getProjection()
      });
      this.handleDownloadFile(fileName, kml);
    },
    setKmlLayer: function setKmlLayer(targetId, LayerName, url) {
      var kml = {
        url: url,
        format: new format_KML({
          extractStyles: true,
          extractAttributes: true
        })
      };
      this.maps[targetId].addLayer(this.layers[targetId][LayerName]);
      this.setFeatureGeom(targetId, kml, layerName);
    },
    getGeoJsonObjectByLayerName: function getGeoJsonObjectByLayerName(targetId, LayerName) {
      return new GeoJSON["a" /* default */]().writeFeatures(this.getAllFeatureByLayerName(targetId, LayerName), {
        dataProjection: 'EPSG:4326',
        featureProjection: 'EPSG:3857'
      });
    },
    clearAllFeatureByLayerName: function clearAllFeatureByLayerName(targetId, LayerName) {
      var tempL = this.getLayerByLayerName(targetId, LayerName);

      if (tempL !== undefined) {
        tempL.getSource().clear();
      }
    },
    getAllFeatureByLayerName: function getAllFeatureByLayerName(targetId, LayerName) {
      return this.getSourceByLayerName(targetId, LayerName).getFeatures();
    },
    clearFeatureStyle: function clearFeatureStyle(feature) {
      feature.setStyle(null);
    },
    setFeatureAttr: function setFeatureAttr(feature, attrObj) {
      feature.setProperties(attrObj);
    },
    setFeatureGeomCluster: function setFeatureGeomCluster(targetId, feature, layerName) {
      if (this.layers[targetId][layerName] !== undefined) {
        this.layers[targetId][layerName].getSource().getSource().addFeature(feature);
      } else if (this.layers[targetId][layerName] === undefined) {
        this.layers[targetId][layerName] = new Vector["a" /* default */]({
          layerName: layerName,
          source: new source_Cluster({
            source: new source_Vector["a" /* default */]({
              features: [feature]
            })
          }),
          style: this.customClusterStyleFunction
        });
        this.maps[targetId].addLayer(this.layers[targetId][layerName]);
      }
    },
    setFeatureGeom: function setFeatureGeom(targetId, feature, layerName) {
      if (layerName !== undefined && layerName != null && layerName != '') {
        if (this.layers[targetId][layerName] !== undefined) {
          this.layers[targetId][layerName].getSource().addFeature(feature);
        } else {
          this.layers[targetId][layerName] = new Vector["a" /* default */]({
            layerName: layerName,
            source: new source_Vector["a" /* default */]({
              features: [feature]
            }),
            style: this.customStyleFunction
          });
          this.maps[targetId].addLayer(this.layers[targetId][layerName]);
        }
      } else {
        if (this.layers[targetId]['defaultLayer'] !== undefined) {
          this.layers[targetId]['defaultLayer'].getSource().addFeature(feature);
        } else {
          this.layers[targetId]['defaultLayer'] = new Vector["a" /* default */]({
            name: 'defaultLayer',
            source: new source_Vector["a" /* default */]({
              features: [feature]
            }),
            style: this.customStyleFunction
          });
          this.maps[targetId].addLayer(this.layers[targetId]['defaultLayer']);
        }
      }
    },
    setCircleFeature: function setCircleFeature(targetId, circleCenter, circleRadius, styleRemark, layerName, featureRemark) {
      var circleFeature = new Feature["a" /* default */]({
        geometry: new Circle["a" /* default */](circleCenter, circleRadius),
        styleRemark: styleRemark,
        featureRemark: featureRemark,
        layerName: layerName
      });
      this.setFeatureGeom(targetId, circleFeature, layerName);
    },
    setPointFeature: function setPointFeature(targetId, pointCenter, styleRemark, layerName, featureRemark, routeSingn, popupName) {
      var pointFeature = new Feature["a" /* default */]({
        geometry: new Point["a" /* default */](pointCenter),
        styleRemark: styleRemark,
        featureRemark: featureRemark,
        layerName: layerName,
        popupName: popupName,
        sign: routeSingn
      });
      this.setFeatureGeom(targetId, pointFeature, layerName);
    },
    setPointClusterFeature: function setPointClusterFeature(targetId, pointCenter, styleRemark, layerName, featureRemark, routeSingn, rcn_id) {
      var pointFeature = new Feature["a" /* default */]({
        geometry: new Point["a" /* default */](pointCenter),
        styleRemark: styleRemark,
        featureRemark: featureRemark,
        layerName: layerName,
        popupName: rcn_id,
        sign: routeSingn
      });
      this.setFeatureGeomCluster(targetId, pointFeature, layerName);
    },
    setLineFeature: function setLineFeature(targetId, points, styleRemark, layerName, featureRemark) {
      var lineFeature = new Feature["a" /* default */]({
        geometry: new LineString["a" /* default */](points),
        styleRemark: styleRemark,
        featureRemark: featureRemark,
        layerName: layerName
      });
      this.setFeatureGeom(targetId, lineFeature, layerName);
    },
    setCustomStyleFeature: function setCustomStyleFeature(feature, styleRemark) {
      feature.set('styleRemark', styleRemark);
      feature.setStyle(null);
      this.customStyleFunction(feature);
    },
    // style
    customStyleFunction: function customStyleFunction(feature, resolution) {
      var resStyle = this.customStyles['default'];
      var tempSR = feature.getProperties().styleRemark;

      if (tempSR !== undefined) {
        resStyle = this.customStyles[tempSR];
      }

      if (resStyle !== undefined) {
        if (typeof resStyle == 'function') {
          return [resStyle(feature, resolution)];
        } else {
          return [resStyle];
        }
      } else {
        return [this.customStyles['default']];
      }
    },
    customClusterStyleFunction: function customClusterStyleFunction(feature, resolution) {
      var resStyle = this.customStyles['default'];
      var tempSR = feature.getProperties().features[0].get('styleRemark');

      if (tempSR !== undefined) {
        resStyle = this.customStyles[tempSR];
      }

      if (resStyle !== undefined) {
        if (typeof resStyle == 'function') {
          return [resStyle(feature, resolution)];
        } else {
          return [resStyle];
        }
      } else {
        return [this.customStyles['default']];
      }
    },
    // interaction
    setInteractionMap: function setInteractionMap(targetId, layerName, funObj, interactionType) {
      var tempSource = null;

      if (layerName !== undefined && layerName != null && layerName != '') {
        if (this.layers[targetId][layerName] !== undefined) {
          tempSource = this.layers[targetId][layerName].getSource();
        } else {
          tempSource = new source_Vector["a" /* default */]({
            wrapX: false
          });
          this.layers[targetId][layerName] = new Vector["a" /* default */]({
            name: layerName,
            source: tempSource
          });
          this.maps[targetId].addLayer(this.layers[targetId][layerName]);
        }
      } else {
        if (this.layers[targetId]['defaultLayer'] !== undefined) {
          tempSource = this.layers[targetId]['defaultLayer'].getSource();
        } else {
          tempSource = new source_Vector["a" /* default */]({
            wrapX: false
          });
          this.layers[targetId]['defaultLayer'] = new Vector["a" /* default */]({
            name: 'defaultLayer',
            source: tempSource
          });
          this.maps[targetId].addLayer(this.layers[targetId]['defaultLayer']);
        }
      }

      var draw = undefined;

      if (interactionType == 'Box') {
        draw = new Draw["b" /* default */]({
          source: tempSource,
          type: 'Circle',
          geometryFunction: Object(Draw["a" /* createBox */])()
        });
      } else {
        draw = new Draw["b" /* default */]({
          source: tempSource,
          type: interactionType
        });
      }

      draw.on('drawend', function (e) {
        if (funObj !== undefined && funObj.setCenterFun !== undefined) {
          funObj.setCenterFun(e.feature.getGeometry().getCenter());
        }

        if (funObj !== undefined && funObj.setRadiusFun !== undefined) {
          funObj.setRadiusFun(e.feature.getGeometry().getRadius());
        }

        if (funObj !== undefined && funObj.doAfterFun !== undefined) {
          funObj.doAfterFun(e.feature);
        }
      });

      if (this.interactions[targetId] === undefined) {
        this.interactions[targetId] = {};
      }

      this.interactions[targetId][interactionType] = draw;
      this.maps[targetId].addInteraction(draw);
    },
    setModifyInteraction: function setModifyInteraction(targetId, layerName) {
      var tempSource = this.getSourceByLayerName(targetId, layerName);
      var modify = new Modify["a" /* default */]({
        source: tempSource
      });

      if (this.interactions[targetId] === undefined) {
        this.interactions[targetId] = {};
      }

      this.interactions[targetId]['Modify'] = modify;
      this.maps[targetId].addInteraction(modify);
    },
    clearAllInteraction: function clearAllInteraction(targetId) {
      var tempMap = this.maps[targetId];

      if (this.interactions[targetId] !== undefined && this.interactions[targetId] != null) {
        Object.values(this.interactions[targetId]).forEach(function (interaction) {
          tempMap.removeInteraction(interaction);
        });
      }

      this.interactions[targetId] = {};
    },
    // event
    setMapChangeEvent: function setMapChangeEvent(targetId, doFunc) {
      this.maps[targetId].on('change', doFunc);
    },
    setMapMoveEndEvent: function setMapMoveEndEvent(targetId, doFunc) {
      this.maps[targetId].on('moveend', doFunc);
    },
    setMapPointerMoveEvent: function setMapPointerMoveEvent(targetId, doFunc) {
      this.maps[targetId].on('pointermove', doFunc);
    },
    setMapClickEvent: function setMapClickEvent(targetId, doFunc) {
      this.maps[targetId].on('click', doFunc);
    },
    setMapSingleClickEvent: function setMapSingleClickEvent(targetId, doFunc) {
      this.maps[targetId].on('singleclick', doFunc);
    },
    setViewChangeEvent: function setViewChangeEvent(targetId, doFunc) {
      this.getViewByMapId(targetId).on('change', doFunc);
    },
    setFeatureClickEvent: function setFeatureClickEvent(targetId, overlayName, doFunc) {
      var currentThis = this;
      this.maps[targetId].on('click', function (evt) {
        var feature = currentThis.maps[targetId].forEachFeatureAtPixel(evt.pixel, function (feature) {
          return feature;
        });
        var tempOverlay = currentThis.overlays[targetId][overlayName];

        if (feature) {
          var coordinates = feature.getGeometry().getCoordinates();

          if (doFunc.hasFeature !== undefined) {
            doFunc.hasFeature(tempOverlay.elementId, feature);
          }

          switch (feature.getGeometry().getType()) {
            case 'Point':
              break;

            case 'Circle':
              coordinates = feature.getGeometry().getCenter();
              break;

            default:
              evt.coordinate.push(0);
              coordinates = evt.coordinate;
              break;
          }

          tempOverlay.overlayObj.setPosition(coordinates);
        } else {
          if (doFunc.noFeature !== undefined) {
            doFunc.noFeature(tempOverlay.elementId);
          }

          tempOverlay.overlayObj.setPosition(undefined);
        }
      });
    },
    setFeatureClickDeleteEvent: function setFeatureClickDeleteEvent(targetId) {
      var currentThis = this;
      this.maps[targetId].on('click', function (evt) {
        var feature = currentThis.maps[targetId].forEachFeatureAtPixel(evt.pixel, function (feature) {
          return feature;
        });

        if (feature) {
          console.log(evt);
          console.log(feature);
        }
      });
    },
    setModifyInteractionModifyEndEvent: function setModifyInteractionModifyEndEvent(targetId, doFunc) {
      this.interactions[targetId]['Modify'].on('modifyend', doFunc);
    },
    // transform
    EPSG4326ToEPSG3857: function EPSG4326ToEPSG3857(point) {
      return Object(ol_proj["u" /* transform */])(point, 'EPSG:4326', 'EPSG:3857');
    },
    EPSG3826ToEPSG3857: function EPSG3826ToEPSG3857(point) {
      lib.defs('EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs');
      lib.defs('EPSG:3826', '+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
      lib.defs('EPSG:3857', '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs');
      register(lib);
      return Object(ol_proj["u" /* transform */])(point, 'EPSG:3826', 'EPSG:3857');
    },
    EPSG4326ToTWD97: function EPSG4326ToTWD97(point) {
      if (point[0] > 119) {
        return this.EPSG4326ToEPSG3826(point);
      } else {
        return this.EPSG4326ToEPSG3825(point);
      }
    },
    EPSG4326ToEPSG3826: function EPSG4326ToEPSG3826(point) {
      var tr_lng = point[0];
      var tr_lat = point[1]; // 臺灣本島

      var DEG_RAD = 0.01745329251994329572;
      var central = 121;
      var TWD97_A = 6378137.0;
      var TWD97_ECC = 0.0066943800229;
      var TWD97_ECC2 = 0.00673949677556;
      var TWD97_TM2 = 0.9999;
      var offset = 250000;
      var x0 = tr_lng * DEG_RAD;
      var y0 = tr_lat * DEG_RAD;
      var x1 = central * DEG_RAD;
      var y1 = 0;
      var m0 = this.mercator(y1, TWD97_A, TWD97_ECC);
      var m1 = this.mercator(y0, TWD97_A, TWD97_ECC);
      var n = TWD97_A / Math.sqrt(1 - TWD97_ECC * Math.pow(Math.sin(y0), 2.0));
      var t = Math.pow(Math.tan(y0), 2.0);
      var c = TWD97_ECC2 * Math.pow(Math.cos(y0), 2.0);
      var A = (x0 - x1) * Math.cos(y0);
      var X_LNG = TWD97_TM2 * n * (A + (1.0 - t + c) * A * A * A / 6.0 + (5.0 - 18.0 * t + t * t + 72.0 * c - 58.0 * TWD97_ECC2) * Math.pow(A, 5.0) / 120.0) + offset;
      var Y_LAT = TWD97_TM2 * (m1 - m0 + n * Math.tan(y0) * (A * A / 2.0 + (5.0 - t + 9.0 * c + 4 * c * c) * Math.pow(A, 4.0) / 24.0 + (61.0 - 58.0 * t + t * t + 600.0 * c - 330.0 * TWD97_ECC2) * Math.pow(A, 6.0) / 720.0));
      return [X_LNG, Y_LAT];
    },
    EPSG4326ToEPSG3825: function EPSG4326ToEPSG3825(point) {
      var tr_lng = point[0];
      var tr_lat = point[1]; // 澎湖金門馬祖

      var DEG_RAD = 0.01745329251994329572;
      var central = 119;
      var TWD97_A = 6378137.0;
      var TWD97_ECC = 0.0066943800229;
      var TWD97_ECC2 = 0.00673949677556;
      var TWD97_TM2 = 0.9999;
      var offset = 250000;
      var x0 = tr_lng * DEG_RAD;
      var y0 = tr_lat * DEG_RAD;
      var x1 = central * DEG_RAD;
      var y1 = 0;
      var m0 = this.mercator(y1, TWD97_A, TWD97_ECC);
      var m1 = this.mercator(y0, TWD97_A, TWD97_ECC);
      var n = TWD97_A / Math.sqrt(1 - TWD97_ECC * Math.pow(Math.sin(y0), 2.0));
      var t = Math.pow(Math.tan(y0), 2.0);
      var c = TWD97_ECC2 * Math.pow(Math.cos(y0), 2.0);
      var A = (x0 - x1) * Math.cos(y0);
      var X_LNG = TWD97_TM2 * n * (A + (1.0 - t + c) * A * A * A / 6.0 + (5.0 - 18.0 * t + t * t + 72.0 * c - 58.0 * TWD97_ECC2) * Math.pow(A, 5.0) / 120.0) + offset;
      var Y_LAT = TWD97_TM2 * (m1 - m0 + n * Math.tan(y0) * (A * A / 2.0 + (5.0 - t + 9.0 * c + 4 * c * c) * Math.pow(A, 4.0) / 24.0 + (61.0 - 58.0 * t + t * t + 600.0 * c - 330.0 * TWD97_ECC2) * Math.pow(A, 6.0) / 720.0));
      return [X_LNG, Y_LAT];
    },
    EPSG3857ToEPSG4326: function EPSG3857ToEPSG4326(point) {
      return Object(ol_proj["u" /* transform */])(point, 'EPSG:3857', 'EPSG:4326');
    },
    mercator: function mercator(y, a, ecc) {
      // 橫麥卡托(Transverse Mercator)
      if (y == 0.0) {
        return 0.0;
      } else {
        return a * ((1.0 - ecc / 4.0 - 3.0 * ecc * ecc / 64.0 - 5.0 * ecc * ecc * ecc / 256.0) * y - (3.0 * ecc / 8.0 + 3.0 * ecc * ecc / 32.0 + 45.0 * ecc * ecc * ecc / 1024.0) * Math.sin(2.0 * y) + (15.0 * ecc * ecc / 256.0 + 45.0 * ecc * ecc * ecc / 1024.0) * Math.sin(4.0 * y) - 35.0 * ecc * ecc * ecc / 3072.0 * Math.sin(6.0 * y));
      }
    },
    // check
    checkPopupPositioning: function checkPopupPositioning(x, y, x1, y1, x2, y2) {
      var resX = 'right';
      var resY = 'top';

      if (Math.abs(x1 - x) < Math.abs(x2 - x)) {
        resX = 'left';
      }

      if (Math.abs(y1 - y) < Math.abs(y2 - y)) {
        resY = 'bottom';
      }

      return resY + '-' + resX;
    },
    // extent
    getImageViewExtentByImgWidthAndImgHeightAndDomWidthAndDomHeight: function getImageViewExtentByImgWidthAndImgHeightAndDomWidthAndDomHeight(imgWidth, imgHeight, domWidth, domHeight) {
      var resWidth = imgHeight * (domWidth / domHeight);
      var resHeight = imgWidth * (domHeight / domWidth);

      if (resWidth > imgWidth) {
        var wMargin = (resWidth - imgWidth) / 2;
        return [0 - wMargin, 0, imgWidth + wMargin, imgHeight];
      } else if (resHeight > imgHeight) {
        var hMargin = (resHeight - imgHeight) / 2;
        return [0, 0 - hMargin, imgWidth, imgHeight + hMargin];
      } else {
        return [0, 0, imgWidth, imgHeight];
      }
    },
    // export image
    getPixelByMapIdAndCoordinate: function getPixelByMapIdAndCoordinate(targetId, coordinate) {
      return this.maps[targetId].getPixelFromCoordinate(coordinate);
    },
    getImage: function getImage(targetId, fileName, sourceX, sourceY, sourceWidth, sourceHeight) {
      var customSize = sourceX !== undefined && sourceY !== undefined && sourceWidth !== undefined && sourceHeight !== undefined;
      var currentThis = this;
      this.maps[targetId].once('rendercomplete', function () {
        var mapCanvas = document.createElement('canvas');

        if (customSize) {
          mapCanvas.width = sourceWidth;
          mapCanvas.height = sourceHeight;
        } else {
          var size = currentThis.maps[targetId].getSize();
          mapCanvas.width = size[0];
          mapCanvas.height = size[1];
        }

        var mapContext = mapCanvas.getContext('2d');
        Array.prototype.forEach.call(document.querySelectorAll('#' + targetId + ' .ol-layer canvas'), function (canvas) {
          if (canvas.width > 0) {
            var opacity = canvas.parentNode.style.opacity;
            mapContext.globalAlpha = opacity === '' ? 1 : Number(opacity);
            var transform = canvas.style.transform;
            var matrix = transform.match(/^matrix\(([^\(]*)\)$/)[1].split(',').map(Number);
            CanvasRenderingContext2D.prototype.setTransform.apply(mapContext, matrix);

            if (customSize) {
              mapContext.drawImage(canvas, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);
            } else {
              mapContext.drawImage(canvas, 0, 0);
            }
          }
        });
        currentThis.handleDownloadImage(fileName, mapCanvas.toDataURL());
      });
      this.maps[targetId].renderSync();
    }
  }
});
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (src_0);



/***/ }),

/***/ "fb20":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "fb4f":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "fc6a":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("44ad");
var requireObjectCoercible = __webpack_require__("1d80");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "fce3":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.exec('\n') && re.flags === 's');
});


/***/ }),

/***/ "fced":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export fromCode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return METERS_PER_UNIT; });
/**
 * @module ol/proj/Units
 */
/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
    /**
     * Radians
     * @api
     */
    RADIANS: 'radians',
    /**
     * Degrees
     * @api
     */
    DEGREES: 'degrees',
    /**
     * Feet
     * @api
     */
    FEET: 'ft',
    /**
     * Meters
     * @api
     */
    METERS: 'm',
    /**
     * Pixels
     * @api
     */
    PIXELS: 'pixels',
    /**
     * Tile Pixels
     * @api
     */
    TILE_PIXELS: 'tile-pixels',
    /**
     * US Feet
     * @api
     */
    USFEET: 'us-ft',
};
/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */
var unitByCode = {
    '9001': Units.METERS,
    '9002': Units.FEET,
    '9003': Units.USFEET,
    '9101': Units.RADIANS,
    '9102': Units.DEGREES,
};
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */
function fromCode(code) {
    return unitByCode[code];
}
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */
var METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.RADIANS] = 6370997 / (2 * Math.PI);
METERS_PER_UNIT[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
/* harmony default export */ __webpack_exports__["b"] = (Units);
//# sourceMappingURL=Units.js.map

/***/ }),

/***/ "fd4d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return forEach; });
/**
 * @module ol/geom/flat/segments
 */
/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
    var ret;
    offset += stride;
    for (; offset < end; offset += stride) {
        ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
        if (ret) {
            return ret;
        }
    }
    return false;
}
//# sourceMappingURL=segments.js.map

/***/ }),

/***/ "fdbc":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "fdbf":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__("4930");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "fde4":
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "fea9":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global.Promise;


/***/ }),

/***/ "ff18":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/typhoon_track04.63a46cf8.png";

/***/ }),

/***/ "ff80":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("6d83");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1300");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("256f");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @module ol/source/Source
 */




/**
 * A function that takes a {@link module:ol/PluggableMap~FrameState} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */
/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */
/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./State.js").default} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
var Source = /** @class */ (function (_super) {
    __extends(Source, _super);
    /**
     * @param {Options} options Source options.
     */
    function Source(options) {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {import("../proj/Projection.js").default}
         */
        _this.projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__[/* get */ "m"])(options.projection);
        /**
         * @private
         * @type {?Attribution}
         */
        _this.attributions_ = adaptAttributions(options.attributions);
        /**
         * @private
         * @type {boolean}
         */
        _this.attributionsCollapsible_ =
            options.attributionsCollapsible !== undefined
                ? options.attributionsCollapsible
                : true;
        /**
         * This source is currently loading data. Sources that defer loading to the
         * map's tile queue never set this to `true`.
         * @type {boolean}
         */
        _this.loading = false;
        /**
         * @private
         * @type {import("./State.js").default}
         */
        _this.state_ =
            options.state !== undefined ? options.state : _State_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].READY;
        /**
         * @private
         * @type {boolean}
         */
        _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
        /**
         * @private
         * @type {boolean}
         */
        _this.interpolate_ = !!options.interpolate;
        /**
         * @protected
         * @type {function(import("../View.js").ViewOptions):void}
         */
        _this.viewResolver = null;
        /**
         * @protected
         * @type {function(Error):void}
         */
        _this.viewRejector = null;
        var self = _this;
        /**
         * @private
         * @type {Promise<import("../View.js").ViewOptions>}
         */
        _this.viewPromise_ = new Promise(function (resolve, reject) {
            self.viewResolver = resolve;
            self.viewRejector = reject;
        });
        return _this;
    }
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */
    Source.prototype.getAttributions = function () {
        return this.attributions_;
    };
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */
    Source.prototype.getAttributionsCollapsible = function () {
        return this.attributionsCollapsible_;
    };
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     */
    Source.prototype.getProjection = function () {
        return this.projection;
    };
    /**
     * @abstract
     * @return {Array<number>|null} Resolutions.
     */
    Source.prototype.getResolutions = function () {
        return Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* abstract */ "b"])();
    };
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */
    Source.prototype.getView = function () {
        return this.viewPromise_;
    };
    /**
     * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
     * @return {import("./State.js").default} State.
     * @api
     */
    Source.prototype.getState = function () {
        return this.state_;
    };
    /**
     * @return {boolean|undefined} Wrap X.
     */
    Source.prototype.getWrapX = function () {
        return this.wrapX_;
    };
    /**
     * @return {boolean} Use linear interpolation when resampling.
     */
    Source.prototype.getInterpolate = function () {
        return this.interpolate_;
    };
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */
    Source.prototype.refresh = function () {
        this.changed();
    };
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */
    Source.prototype.setAttributions = function (attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
    };
    /**
     * Set the state of the source.
     * @param {import("./State.js").default} state State.
     */
    Source.prototype.setState = function (state) {
        this.state_ = state;
        this.changed();
    };
    return Source;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]));
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
    if (!attributionLike) {
        return null;
    }
    if (Array.isArray(attributionLike)) {
        return function (frameState) {
            return attributionLike;
        };
    }
    if (typeof attributionLike === 'function') {
        return attributionLike;
    }
    return function (frameState) {
        return [attributionLike];
    };
}
/* harmony default export */ __webpack_exports__["a"] = (Source);
//# sourceMappingURL=Source.js.map

/***/ })

/******/ });
});
//# sourceMappingURL=wg-ol-mixins.umd.js.map